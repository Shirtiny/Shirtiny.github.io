<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[HttpClient]]></title>
    <url>%2F2019%2F08%2F16%2FHttpClient%2F</url>
    <content type="text"><![CDATA[使用HttpClient模拟浏览器访问HttpClient 是Apache HttpComponents 下的子项目，是支持 HTTP 协议的客户端编程工具包。它被用来发送和接受 HTTP 消息，并不能处理http响应内容。 依赖12345 &lt;dependency&gt; &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt; &lt;artifactId&gt;httpclient&lt;/artifactId&gt; &lt;version&gt;4.5.6&lt;/version&gt;&lt;/dependency&gt; 基本使用Get1234567891011//httpClient的创建CloseableHttpClient httpClient = HttpClients.createDefault();//创建一个GET对象HttpGet get = new HttpGet("http://shirtiny.cn");//发送请求，得到一个response对象CloseableHttpResponse response = httpClient.execute(get);//取响应实体，转换成字符串打印HttpEntity entity = response.getEntity();String string = EntityUtils.toString(entity, "utf-8");//响应状态码int statusCode = response.getStatusLine().getStatusCode(); 当需要传递参数时，可以直接在url改，也可以使用URIBuilder构建url 参数 1234567891011//基础urlURIBuilder uriBuilder = new URIBuilder("https://api.kaaass.net/biliapi/video/resolve");//加入参数uriBuilder.addParameter("id","53175612");uriBuilder.addParameter("quality","80");//构建出urlURI uri = uriBuilder.build();//放入get请求对象中即可HttpGet get=new HttpGet(uri);//然后执行...httpClient.execute(get); POST与Get类似。当需要提交表格数据时： 123456789101112//创建一个post对象HttpPost post = new HttpPost("http://localhost:8082/httpclient/post.html");//创建一个Entity。模拟一个表单List&lt;NameValuePair&gt; kvList = new ArrayList&lt;&gt;();kvList.add(new BasicNameValuePair("username", "zhangsan"));kvList.add(new BasicNameValuePair("password", "123")); //包装成一个Entity对象StringEntity entity = new UrlEncodedFormEntity(kvList, "utf-8");//设置请求的内容post.setEntity(entity);//执行post请求CloseableHttpResponse response = httpClient.execute(post); 工具类一个方便其他服务调用的httpClient的工具类。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118package Http_Utils;import ...public class HttpClientUtil &#123; public static String doGet(String url, Map&lt;String, String&gt; param) &#123; // 创建Httpclient对象 CloseableHttpClient httpclient = HttpClients.createDefault(); String resultString = ""; CloseableHttpResponse response = null; try &#123; // 创建uri URIBuilder builder = new URIBuilder(url); if (param != null) &#123; for (String key : param.keySet()) &#123; builder.addParameter(key, param.get(key)); &#125; &#125; URI uri = builder.build(); // 创建http GET请求 HttpGet httpGet = new HttpGet(uri); // 执行请求 response = httpclient.execute(httpGet); // 判断返回状态是否为200 if (response.getStatusLine().getStatusCode() == 200) &#123; resultString = EntityUtils.toString(response.getEntity(), "UTF-8"); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; if (response != null) &#123; response.close(); &#125; httpclient.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; return resultString; &#125; public static String doGet(String url) &#123; return doGet(url, null); &#125; public static String doPost(String url, Map&lt;String, String&gt; param) &#123; // 创建Httpclient对象 CloseableHttpClient httpClient = HttpClients.createDefault(); CloseableHttpResponse response = null; String resultString = ""; try &#123; // 创建Http Post请求 HttpPost httpPost = new HttpPost(url); // 创建参数列表 if (param != null) &#123; List&lt;NameValuePair&gt; paramList = new ArrayList&lt;&gt;(); for (String key : param.keySet()) &#123; paramList.add(new BasicNameValuePair(key, param.get(key))); &#125; // 模拟表单 UrlEncodedFormEntity entity = new UrlEncodedFormEntity(paramList); httpPost.setEntity(entity); &#125; // 执行http请求 response = httpClient.execute(httpPost); resultString = EntityUtils.toString(response.getEntity(), "utf-8"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; response.close(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; return resultString; &#125; public static String doPost(String url) &#123; return doPost(url, null); &#125; public static String doPostJson(String url, String json) &#123; // 创建Httpclient对象 CloseableHttpClient httpClient = HttpClients.createDefault(); CloseableHttpResponse response = null; String resultString = ""; try &#123; // 创建Http Post请求 HttpPost httpPost = new HttpPost(url); // 创建请求内容 StringEntity entity = new StringEntity(json, ContentType.APPLICATION_JSON); httpPost.setEntity(entity); // 执行http请求 response = httpClient.execute(httpPost); resultString = EntityUtils.toString(response.getEntity(), "utf-8"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; response.close(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; return resultString; &#125;&#125;]]></content>
      <categories>
        <category>学习经验</category>
      </categories>
      <tags>
        <tag>httpclient</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二维数组⇌稀疏数组⇌数据文件]]></title>
    <url>%2F2019%2F08%2F11%2F%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84-%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84-%E6%95%B0%E6%8D%AE%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[数据结构与算法1. 什么是稀疏数组一个数组含有大量重复的值的时候，可以把它转化为稀疏数组来表示，这样会大量节省空间占用。 稀疏数组： 是个二维数组，只有3列，分别对应：行row、列col、值value 第一行表示原数组的行数、列数、有效值个数。（注意，0是第一行） 从第二行开始，每行都会对应一个有效值。 用row（第一列）表示有效值是在原数组中的第几行 用col（第二列）表示有效值是在原数组中的第几列 用value（第三列）表示有效值在原数组中的值 行数为原数组有效值个数+1 示例： 原数组 0，0，0，0，0 1，0，2，0，0 0，0，0，0，0 0，0，0，1，0 对应的稀疏数组： 4，5，3 //表示原数组有4行、5列、3个有效值 1，0，1 //表示一个有效值，位置在原数组的第2行、第1列、值为1 1，2，2 //同上，表示位置在原数组第2行、第3列、值为2 3，3，1 //表示位置在原数组第4行、第4列、值为1 2. 二维数组⇌稀疏数组java代码演示，相互转换的过程。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101package SparseArray;import java.util.Arrays;public class SparseArray &#123; public static void main(String[] args) &#123; //1. 新建一个二维数组 int[][] array1 = new int[4][5]; //2. 给数组赋一些值 array1[1][0]=1; array1[1][2]=2; array1[3][3]=1; //3. 格式化输出数组 for (int i=0;i&lt;array1.length;i++)&#123;//array1.length是行数 for (int j=0;j&lt;array1[0].length;j++)&#123;//array1[0].length是第0行的列数// System.out.print(array1[i][j]+"\t"); &#125;// System.out.println(); &#125; //4. 更好的输出方式foreach System.out.println("##############这是原数组1"); for (int[] row:array1)&#123; for (int value:row)&#123; System.out.print(value+"\t"); &#125; System.out.println(); &#125; //5. 转为稀疏数组，首先需要得到原数组中的有效值个数 System.out.println("##############"); int num=0; for (int[] row:array1)&#123; for(int value:row)&#123; if (value!=0)&#123; num++; &#125; &#125; &#125; System.out.println("原数组1有："+num+"个有效值"); //6. 创建稀疏数组，因为稀疏数组第一行是对原数组大小的描述，其他行都是对有效值的描述， //所以，稀疏数组行数是 原数组有效值个数+1。 int [][] sparseArray=new int[num+1][3]; //7. 对稀疏数组的第一行赋值，对应原数组的行数、列数、有效值个数 sparseArray[0][0]=4; sparseArray[0][1]=5; sparseArray[0][2]=3; //8. 为稀疏数组赋值，对原数组进行遍历，需要明确第几行第几列 int n=1; for (int i=0;i&lt;array1.length;i++)&#123; for (int j=0;j&lt;array1[0].length;j++)&#123; if (array1[i][j]!=0)&#123; sparseArray[n][0]=i; sparseArray[n][1]=j; sparseArray[n][2]=array1[i][j]; n++; &#125; &#125; &#125; //9. 输出稀疏数组 System.out.println("##############这是转换后的稀疏数组"); for (int[] row:sparseArray)&#123; for (int value:row)&#123; System.out.print(value+"\t"); &#125; System.out.println(); &#125; //10. 再恢复成原数组 // 创建一个原数组2，原数组2的行数，是稀疏数组的第一行第一列的值 // 原数组2的列数，是稀疏数组的第一行第二列的值 int[][] array2=new int[sparseArray[0][0]][sparseArray[0][1]]; //11. 把稀疏数组中的有效值读出，赋给原数组2， // 只需付给原数组2有效值，i从1开始，也就是第二行开始， // 稀疏数组第i行，第1列是有效值的行数，第2列是有效值的列数，第3列是有效值的值 // 因为稀疏数组固定只有3列，一个循环即可 for (int i=1;i&lt;sparseArray.length;i++)&#123; array2[sparseArray[i][0]][sparseArray[i][1]]=sparseArray[i][2]; &#125; //12. 输出回复后的原数组2 System.out.println("##############这是恢复后的原数组2"); for (int[] row:array2)&#123; for (int value:row)&#123; System.out.print(value+"\t"); &#125; System.out.println(); &#125; &#125;&#125; 输出结果： ##############这是原数组10 0 0 0 01 0 2 0 00 0 0 0 00 0 0 1 0 ##############原数组1有：3个有效值 ##############这是转换后的稀疏数组4 5 31 0 11 2 23 3 1 ##############这是恢复后的原数组20 0 0 0 01 0 2 0 00 0 0 0 00 0 0 1 0 3. 稀疏数组⇌数据文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//13. 将稀疏数组存入本地文件 File file =new File("D:\\aria2\\SparseArray.data"); Writer writer=new FileWriter(file); for (int[] row:sparseArray)&#123; for (int value:row)&#123; writer.write(value+"\t"); &#125; writer.write("\r\n"); &#125; writer.close();//14. 从本地文件读取稀疏数组 System.out.println("##############这是从文件恢复的稀疏数组2"); //1.创建源 File src = new File("D:\\aria2\\SparseArray.data"); //2.选择流 BufferedReader in = new BufferedReader(new FileReader(src)); //3.1进行数据的搬移，但是数组首要考虑的事情是数组要多大？ int row =0;//用于创建要创建的二维稀疏数组的大小确定 String line; //一行数据 //逐行读取，并将每个数组放入到数组中 while ((line = in.readLine()) != null) &#123; row++; &#125; int sparseArr2[][] = new int [row][3]; //3.2文本数据转移到稀疏数组中 int rowtmp = 0; //由于读取完毕整个文本文档，重启流 in.close(); in = new BufferedReader(new FileReader(src)); while ((line = in.readLine()) != null) &#123; String[] temp = line.split("\t"); for (int j = 0; j &lt; temp.length; j++) &#123; sparseArr2[rowtmp][j]=Integer.parseInt(temp[j]); &#125; rowtmp++; &#125; //4.关闭流 in.close(); //验证文件读取是否正确 for(int[]temp1:sparseArr2) &#123; for (int temp2 : temp1) &#123; System.out.printf("%d\t", temp2); &#125; System.out.println(); &#125; 参考文章：稀疏数组转换、稀疏数组到文件、array[0].length、\r\n的区别]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JsonP跨域请求]]></title>
    <url>%2F2019%2F08%2F11%2FJsonP%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%2F</url>
    <content type="text"><![CDATA[使用JsonP跨域获取json数据 JsonP示例JsonP的主要实现举例： 123456789101112131415161718192021222324252627282930var category = &#123;OBJ: $("#_JD_ALLSORT"), URL_Serv: "http://localhost:8082/category.json"&#125;,FN_GetData: function() &#123; //使用jsonp来实现跨域请求 $.getJSONP(this.URL_Serv, category.getDataService); //直接使用ajax请求json数据 /*$.getJSON(this.URL_Serv, function(json)&#123; category.getDataService(json); &#125;);*///解析json数据&#125;,getDataService: function(a) &#123; var b = [], c = this; $.each(a.data, function(a) &#123; this.index = a, "l" == this.t &amp;&amp; (this.i = c.FN_RefactorJSON(this.i, 7)), b.push(c.renderItem(this, a)) &#125;); b.push('&lt;div class="extra"&gt;&lt;a &#123;if pageConfig.isHome&#125;clstag="homepage|keycount|home2013|0614a"&#123;/if&#125; href="http://www.jd.com/allSort.aspx"&gt;\u5168\u90e8\u5546\u54c1\u5206\u7c7b&lt;/a&gt;&lt;/div&gt;'), this.OBJ.attr("load", "1").html(b.join("")), $.bigiframe(this.OBJ), this.FN_GetBrands(); var d = this, e = this.OBJ.outerWidth(), f = this.OBJ.outerHeight(); $("#_JD_ALLSORT").dropdown(&#123;delay: 0,onmouseleave: function() &#123; $("#_JD_ALLSORT .item").removeClass("hover") &#125;&#125;, function(a) &#123; var b, c, g = document.documentElement.scrollTop + document.body.scrollTop, h = $("#nav-2013").offset().top + 39; h &gt;= g ? (c = a.hasClass("fore13") ? 3 : 3, g = c) : (b = a.offset().top, g = g &gt; b - 5 ? b - h - 10 : Math.max(3, g - h)); var i = a.find(".i-mc"); if (i.css(&#123;top: g + "px"&#125;), d.OBJ.find("iframe")) &#123; var j = i.outerWidth() + e, k = i.outerHeight() &gt; f ? i.outerHeight() : f; d.OBJ.find("iframe").css(&#123;width: j,height: k,top: g&#125;) &#125; &#125;)&#125; 其中，http://localhost:8082/category.json的内容为： 1234567891011121314151617181920category.getDataService(&#123; "data": [ &#123; "u": "/products/1.html", "n": "&lt;a href='/products/1.html'&gt;图书、音像、电子书刊&lt;/a&gt;", "i": [ &#123; "u": "/products/2.html", "n": "电子书刊", "i": [ "/products/3.html|电子书", "/products/4.html|网络原创", "/products/5.html|数字杂志", "/products/6.html|多媒体图书" ] &#125; ]&#125;]&#125; ); 其实是一段js，把json包装在参数里。 跨域请求为什么不能直接用Ajax 直接使用ajax请求另一个端口上的json数据: 1234//直接使用ajax请求另一个端口上的json数据 $.getJSON(this.URL_Serv, function(json)&#123; category.getDataService(json); &#125;); 会出现以下异常： No &#39;Access-Control-Allow-Origin&#39; 什么是跨域 当一个请求url的协议、域名、端口三者之间任意一个与当前页面url不同即为跨域。 协议http-&gt;https、端口8081-&gt;8082、域名Shirtiny.cn-&gt;Github.com，都为跨域。 跨域问题的产生 同源策略（Sameoriginpolicy）是一种约定，它是浏览器最核心也最基本的安全功能。 同源策略会阻止一个域的javascript脚本和另外一个域的内容进行交互。所谓同源（即指在同一个域）就是两个页面具有相同的协议（protocol），主机（host）和端口号（port） 跨域的解决方式 document.domain 跨文档通信 API JSONP CORS JsonP流程JSONP 只支持get请求，不支持post请求。 核心思想：用特定方式请求 JSON 数据，服务器收到请求后，将数据放在一个指定名字的回调函数的参数位置传回来。 数据库查询-&gt;构建pojo对象首先需要把数据库中的数据查询出来，数据库中有时并不是直接保存的json数据，如存储的分类目录表： 12345678910111213CREATE TABLE `tb_item_cat` ( `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '类目ID', `parent_id` bigint(20) DEFAULT NULL COMMENT '父类目ID=0时，代表的是一级的类目', `name` varchar(50) DEFAULT NULL COMMENT '类目名称', `status` int(1) DEFAULT '1' COMMENT '状态。可选值:1(正常),2(删除)', `sort_order` int(4) DEFAULT NULL COMMENT '排列序号，表示同级类目的展现次序，如数值相等则按名称次序排列。取值范围:大于零的整数', `is_parent` tinyint(1) DEFAULT '1' COMMENT '该类目是否为父类目，1为true，0为false', `created` datetime DEFAULT NULL COMMENT '创建时间', `updated` datetime DEFAULT NULL COMMENT '创建时间', PRIMARY KEY (`id`), KEY `parent_id` (`parent_id`,`status`) USING BTREE, KEY `sort_order` (`sort_order`)) ENGINE=InnoDB AUTO_INCREMENT=1183 DEFAULT CHARSET=utf8 COMMENT='商品类目'; 为了能让查询到的数据转为json格式，我们需要构建Pojo对象。 需要的Json数据格式： 我们可以看到data是根节点，它有很多[0]、[1]、[2]这样的节点。节点包含属性u、n、i，而其中i又是一个子节点，它又包含了自己的u、n、i属性，其中i最终包含了若干字符串。 pojo类的构建我们把根节点data单独拿出来，构建出JsonData类，因为一个Json里会有1个存放节点集合的data根节点。 12345678910111213141516171819202122232425262728293031package com.SH.Rest.Pojo;import java.util.List;public class JsonData &#123; List&lt;?&gt; data; public List&lt;?&gt; getData() &#123; return data; &#125; public void setData(List&lt;?&gt; data) &#123; this.data = data; &#125; public JsonData(List&lt;?&gt; data) &#123; this.data = data; &#125; public JsonData() &#123; &#125; @Override public String toString() &#123; return "JsonData&#123;" + "data=" + data + '&#125;'; &#125;&#125; 每个data的节点以及节点的子节点，都有u、n、i 这3个属性，其中i都为一个集合，所以我们构建DataNode类，用来表示子节点。使用@JsonProperty(“”)注解，用来指定对应属性，转换成json数据对应的key名称。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package com.SH.Rest.Pojo;import com.fasterxml.jackson.annotation.JsonProperty;import java.util.List;public class DataNodes &#123; @JsonProperty("u") String url; @JsonProperty("n") String name; @JsonProperty("i") List&lt;?&gt; item; public DataNodes() &#123; &#125; public DataNodes(String url, String name, List&lt;?&gt; item) &#123; this.url = url; this.name = name; this.item = item; &#125; @Override public String toString() &#123; return "DataNodes&#123;" + "url='" + url + '\'' + ", name='" + name + '\'' + ", item=" + item + '&#125;'; &#125; public String getUrl() &#123; return url; &#125; public void setUrl(String url) &#123; this.url = url; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public List&lt;?&gt; getItem() &#123; return item; &#125; public void setItem(List&lt;?&gt; item) &#123; this.item = item; &#125;&#125; Service递归构建，得到节点pojo对象集合1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.SH.Rest.Service.serviceImpl;import ...@Servicepublic class JsonPserviceImpl implements IJsonPService &#123; @Autowired private TbItemCatMapper tbItemCatMapper; @Override public List&lt;?&gt; selectJson(long parentId) &#123; //设定查询条件，先查询库中所有parentId为0的目录，即所有顶层目录 TbItemCatExample example = new TbItemCatExample(); TbItemCatExample.Criteria criteria = example.createCriteria(); criteria.andParentIdEqualTo(parentId); List&lt;TbItemCat&gt; list = tbItemCatMapper.selectByExample(example);//执行 List resultList = new ArrayList&lt;&gt;(); //向list中添加节点 for (TbItemCat tbItemCat : list) &#123; //判断是否为父节点 if (tbItemCat.getIsParent()) &#123; DataNode dataNode = new DataNode(); if (parentId == 0) &#123; dataNode.setName("&lt;a href='/products/"+tbItemCat.getId()+".html'&gt;"+tbItemCat.getName()+"&lt;/a&gt;"); &#125; else &#123; dataNode.setName(tbItemCat.getName()); &#125; dataNode.setUrl("/products/"+tbItemCat.getId()+".html"); //递归 dataNode.setItem(selectJson(tbItemCat.getId())); resultList.add(dataNode); //如果是叶子节点 &#125; else &#123; resultList.add("/products/"+tbItemCat.getId()+".html|" + tbItemCat.getName()); &#125; &#125; return resultList; &#125;&#125; Controller把节点集合封装到data根节点对象，然后转换成json字符串12345678910111213141516171819202122232425262728package com.SH.Rest.Controller;import ...@Controllerpublic class JsonPController &#123; @Autowired private IJsonPService jsonPService; @RequestMapping(value = "/AllCategory",produces = "text/plain;charset=UTF-8") /*设置输出编码，或 @RequestMapping(value="/itemcat/list", produces=MediaType.APPLICATION_JSON_VALUE + ";charset=utf-8") */ @ResponseBody public String AllCategory(String callBack)&#123; List&lt;?&gt; dataNodelist = jsonPService.selectJson(0); JsonData data=new JsonData(); data.setData(dataNodelist); String json = JsonUtils.objectToJson(data); //拼接成js语句，callBack参数为请求中传递来的函数名 json=callBack+"("+json+");"; return json; &#125;&#125; 另一种方式（需要spring版本支持）： 12345678910@RequestMapping("/AllCategory") @ResponseBody public Object AllCategory(String callBack) &#123; List&lt;?&gt; dataNodelist = jsonPService.selectJson(0); JsonData data=new JsonData(); data.setData(dataNodelist); MappingJacksonValue mappingJacksonValue = new MappingJacksonValue(data); mappingJacksonValue.setJsonpFunction(callback); return mappingJacksonValue; &#125; 此时客户端只需要发请求： 1http://本机：端口/AllCategory?callBack=自定义函数 然后会自动调用自定义的函数，并将参数值（也就是json数据）传过来，详情可以看文章开头。]]></content>
      <categories>
        <category>学习经验</category>
      </categories>
      <tags>
        <tag>JsonP</tag>
        <tag>Js跨域请求</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Json格式数据转Html表格]]></title>
    <url>%2F2019%2F08%2F09%2FJson%E6%A0%BC%E5%BC%8F%E6%95%B0%E6%8D%AE%E8%BD%ACHtml%E9%A1%B5%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[Json数据→包含html语言的字符串输入数据数据库可以把下面的Json格式的字符串数据存储起来 123456789101112131415[ &#123;"group":"主体", "params":[ &#123;"k":"品牌","v":"1"&#125;, &#123;"k":"型号","v":"2"&#125;, &#123;"k":"颜色","v":"3"&#125;, &#123;"k":"上市年份","v":"4"&#125;]&#125;, &#123;"group":"网络", "params":[&#123;"k":"4G网络制式","v":"a"&#125;, &#123;"k":"3G网络制式","v":"b"&#125;, &#123;"k":"2G网络制式","v":"c"&#125;]&#125;, &#123;"group":"存储", "params":[&#123;"k":"机身内存","v":"de"&#125;, &#123;"k":"储存卡类型","v":"ef"&#125;]&#125;] 需要把json转成ListJson到java对象的转换，工具类： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package com.SH.utils;import java.util.List;import ... /*工具类，用于把json数据转成需要的java对象 */public class JsonUtils &#123; // 定义jackson对象 private static final ObjectMapper MAPPER = new ObjectMapper(); /** * 将对象转换成json字符串。 * &lt;p&gt;Title: pojoToJson&lt;/p&gt; * &lt;p&gt;Description: &lt;/p&gt; * @param data * @return */ public static String objectToJson(Object data) &#123; try &#123; String string = MAPPER.writeValueAsString(data); return string; &#125; catch (JsonProcessingException e) &#123; e.printStackTrace(); &#125; return null; &#125; /** * 将json结果集转化为对象 * * @param jsonData json数据 * @param clazz 对象中的object类型 * @return */ public static &lt;T&gt; T jsonToPojo(String jsonData, Class&lt;T&gt; beanType) &#123; try &#123; T t = MAPPER.readValue(jsonData, beanType); return t; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null; &#125; /** * 将json数据转换成pojo对象list * &lt;p&gt;Title: jsonToList&lt;/p&gt; * &lt;p&gt;Description: &lt;/p&gt; * @param jsonData * @param beanType * @return */ public static &lt;T&gt;List&lt;T&gt; jsonToList(String jsonData, Class&lt;T&gt; beanType) &#123; JavaType javaType = MAPPER.getTypeFactory().constructParametricType(List.class, beanType); try &#123; List&lt;T&gt; list = MAPPER.readValue(jsonData, javaType); return list; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null; &#125; &#125; 详细参考拿到数据库里的Json数据后，对其进行转换，两次遍历，利用map拿到value，然后使用StringBuffer生成html格式的字符串。 123456789101112131415161718192021222324252627282930@Servicepublic class SqlJson2JavaString &#123; public String json2String(String sqlData) &#123; String jsonData = sqlData; //生成html // 把规格参数json数据转换成java对象 List&lt;Map&gt; jsonList = JsonUtils.jsonToList(jsonData, Map.class); StringBuffer sb = new StringBuffer(); sb.append("&lt;table cellpadding=\"0\" cellspacing=\"1\" width=\"100%\" border=\"0\" class=\"Ptable\"&gt;\n"); sb.append(" &lt;tbody&gt;\n"); for(Map m1:jsonList) &#123; sb.append(" &lt;tr&gt;\n"); sb.append(" &lt;th class=\"tdTitle\" colspan=\"2\"&gt;"+m1.get("group")+"&lt;/th&gt;\n"); sb.append(" &lt;/tr&gt;\n"); List&lt;Map&gt; list2 = (List&lt;Map&gt;) m1.get("params"); for(Map m2:list2) &#123; sb.append(" &lt;tr&gt;\n"); sb.append(" &lt;td class=\"tdTitle\"&gt;"+m2.get("k")+"&lt;/td&gt;\n"); sb.append(" &lt;td&gt;"+m2.get("v")+"&lt;/td&gt;\n"); sb.append(" &lt;/tr&gt;\n"); &#125; &#125; sb.append(" &lt;/tbody&gt;\n"); sb.append("&lt;/table&gt;"); return sb.toString(); &#125;&#125; 这样，数据库存储中，这种&lt;K,V&gt;对形式的表格数据，可以用json数据保存，可以单表操作。 输出结果 使用工具类，处理数据库中json格式数据 123//将接收到的jsonData，转为map集合List&lt;Map&gt; jsonList = JsonUtils.jsonToList(jsonData, Map.class);System.out.println(jsonList); 打印转换的结果： 1[&#123;group=主体, params=[&#123;k=品牌, v=1&#125;, &#123;k=型号, v=2&#125;, &#123;k=颜色, v=3&#125;, &#123;k=上市年份, v=4&#125;]&#125;, &#123;group=网络, params=[&#123;k=4G网络制式, v=a&#125;, &#123;k=3G网络制式, v=b&#125;, &#123;k=2G网络制式, v=c&#125;]&#125;, &#123;group=存储, params=[&#123;k=机身内存, v=de&#125;, &#123;k=储存卡类型, v=ef&#125;]&#125;] 使用StringBuffer和遍历取出需要的数据： 123456789101112131415161718StringBuffer sb = new StringBuffer(); sb.append("&lt;table cellpadding=\"0\" cellspacing=\"1\" width=\"100%\" border=\"0\" class=\"Ptable\"&gt;\n"); sb.append(" &lt;tbody&gt;\n"); for(Map m1:jsonList) &#123; sb.append(" &lt;tr&gt;\n"); sb.append(" &lt;th class=\"tdTitle\" colspan=\"2\"&gt;"+m1.get("group")+"&lt;/th&gt;\n"); sb.append(" &lt;/tr&gt;\n"); List&lt;Map&gt; list2 = (List&lt;Map&gt;) m1.get("params"); for(Map m2:list2) &#123; sb.append(" &lt;tr&gt;\n"); sb.append(" &lt;td class=\"tdTitle\"&gt;"+m2.get("k")+"&lt;/td&gt;\n"); sb.append(" &lt;td&gt;"+m2.get("v")+"&lt;/td&gt;\n"); sb.append(" &lt;/tr&gt;\n"); &#125; &#125; sb.append(" &lt;/tbody&gt;\n"); sb.append("&lt;/table&gt;"); return sb.toString(); 最终结果为： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;table cellpadding="0" cellspacing="1" width="100%" border="0" class="Ptable"&gt; &lt;tbody&gt; &lt;tr&gt; &lt;th class="tdTitle" colspan="2"&gt;主体&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class="tdTitle"&gt;品牌&lt;/td&gt; &lt;td&gt;1&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class="tdTitle"&gt;型号&lt;/td&gt; &lt;td&gt;2&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class="tdTitle"&gt;颜色&lt;/td&gt; &lt;td&gt;3&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class="tdTitle"&gt;上市年份&lt;/td&gt; &lt;td&gt;4&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th class="tdTitle" colspan="2"&gt;网络&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class="tdTitle"&gt;4G网络制式&lt;/td&gt; &lt;td&gt;a&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class="tdTitle"&gt;3G网络制式&lt;/td&gt; &lt;td&gt;b&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class="tdTitle"&gt;2G网络制式&lt;/td&gt; &lt;td&gt;c&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th class="tdTitle" colspan="2"&gt;存储&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class="tdTitle"&gt;机身内存&lt;/td&gt; &lt;td&gt;de&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class="tdTitle"&gt;储存卡类型&lt;/td&gt; &lt;td&gt;ef&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt;]]></content>
      <categories>
        <category>学习经验</category>
      </categories>
      <tags>
        <tag>Json</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新增视频播放插件]]></title>
    <url>%2F2019%2F08%2F06%2F%E6%96%B0%E5%A2%9E%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[更新视频、音频插件支持 有了服务器支持，现在可以用自己的媒体源了，媒体内容可以不再受公网限制。之前做html视频嵌入示例，发现部分html内容在https下无法正常使用，于是博客新增了对视频源的播放支持。 效果： (function(){var player = new DPlayer({"container":document.getElementById("dplayer0"),"autoplay":true,"theme":"#FADFA3","loop":true,"video":{"url":"http://78.141.206.203/video/ys.mp4"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})() 这个插件是基于DPlayer的 ，若视频连接出错，多半是因为换了服务器ip或者暂时关闭了服务器，有的时间段会比较卡，也可能是协议的问题。 只需要安装对应插件，然后Github上有详细的文档说明，用起来也很方便。功能挺好的，只是有时候这播放器会出bug。 官方文档： 音乐播放插件：hexo-tag-aplayer 视频播放插件：hexo-tag-dplayer 安装插件： 1234#视频播放插件npm install hexo-tag-dplayer --save#音频播放插件，不过音乐是能正常播放的，暂时用不到这个npm install hexo-tag-aplayer --save 示例： 视频 12&lt;!-- 效果是上面的视频 ，沒声音是因为，这个视频源没加音频。有声音是因为文章下面有个背景音乐（显示中）--&gt;&#123;% dplayer "url=http://78.141.206.203/video/ys.mp4" "loop=yes" "theme=#FADFA3" "autoplay=true" %&#125; 其实相当于使用DPlayer： 123456789101112131415161718192021222324252627282930313233343536&#123;% raw %&#125;&lt;div id="player1" class="dplayer"&gt;&lt;/div&gt;&lt;script src="dist/DPlayer.min.js"&gt;&lt;/script&gt;&lt;!-- use your path --&gt;&lt;script&gt;var dp = new DPlayer(&#123;&#123; container: document.getElementById('dplayer'), autoplay: false, theme: '#FADFA3', loop: true, screenshot: true, hotkey: true, logo: 'logo.png', volume: 0.2, mutex: true, video: &#123; url: 'http://78.141.206.203/video/ys.mp4', pic: '', thumbnails: '', type: 'auto' &#125;, subtitle: &#123; &#125;, danmaku: &#123; &#125;, unlimited: true &#125;, contextmenu: [ &#123; &#125; ]&#125;);&lt;/script&gt;&#123;% endraw %&#125; 音频 1&#123;% aplayer "马宿" "Zelda" "http://78.141.206.203/music/masu.mp3" "autoplay" %&#125; var ap = new APlayer({ element: document.getElementById("aplayer-cFRehbwp"), narrow: false, autoplay: true, showlrc: false, music: { title: "马宿", author: "Zelda", url: "http://78.141.206.203/music/masu.mp3", pic: "", lrc: "" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 参考文章]]></content>
      <categories>
        <category>系统维护</category>
      </categories>
      <tags>
        <tag>博客维护</tag>
        <tag>播放插件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在线视频播放、直播]]></title>
    <url>%2F2019%2F08%2F06%2F%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE%E3%80%81%E7%9B%B4%E6%92%AD%2F</url>
    <content type="text"><![CDATA[Nginx：视频、直播前篇文章说了Sftp下的文件上传，访问时比如图片、json文件等是可以直接显示的。可压缩包或视频文件等，访问时只能下载，如何让视频在线播放？ 环境准备： 可用的服务器（CentOS 7系统）、Nginx、Nginx-Rtmp模块 、Ffmpeg、Jwplayer(可以从连接另存文件，不用登录) 工具：Xshell 6、Xftp 5 1. 在线视频播放其实要播放比较简单，主要问题是网速、负载等，这些是生产环境需要考虑的。 1.1. 安装Nginx服务器安装Nginx，包括远程工具，参照我之前的文章即可。 ### 1.2. 安装Nginx-Rtmp模块 在Github上下载nginx-rtmp-module-1.2.1.tar.gz 使用Xftp将下载的压缩包传到服务器的/usr/local文件夹。放哪都行，自己能找到就行。 使用tar命令解压该文件，得到nginx-rtmp-module-1.2.1文件夹，我的文件夹位置为： 1/usr/local/nginx-rtmp-module-1.2.1 此时，你需要找到之前Nginx解压后的文件夹，就是那个带版本号的文件夹。我的Nginx源码目录是： 1/usr/local/nginx-1.17.1 进入Nginx源码文件夹 1cd /usr/local/nginx-1.17.1 安装Nginx-Rtmp模块 此时，一定要进入nginx源码文件，不然找不到configure。还要注意找到之前rtmp模块解压后的文件夹位置，此时我nginx-1.17.1和nginx-rtmp-module-1.2.1都是放在/usr/local下的，所以用../就能找到。 123./configure --add-module=../nginx-rtmp-module-1.2.1 --with-http_ssl_modulemakemake install 模块安装完成。 参考：官方文档 1.3. 视频播放配置 打开/usr/local/nginx/conf目录下的nginx.conf配置文件，nginx是Nginx的安装目录 1vi /usr/local/nginx/conf/nginx.conf 键盘按i编辑，方向键移动光标，编辑完按 ” :wq “ 保存退出 编辑内容： 光标移动到文件最底部大括号外 （http｛｝代码块外），增加rtmp代码块： 12345678910111213141516rtmp&#123; server&#123; listen 2019; chunk_size 4096; #应用名随意，play播放指定目录或者 HTTP 地址的 flv 或者 mp4 文件 application video &#123; play /data/video; &#125;&#125;&#125; 此时虽然可以播放视频了，但http还找不到资源，所以还需要定义访问路径。 把光标移到http代码块里，按如下内容修改和增加代码，其实只加了个location，配置文件里#后内容是注释，忽略或删除。 123456789101112131415161718192021222324252627282930313233343536373839404142http &#123; include mime.types; default_type application/octet-stream; sendfile on; tcp_nopush on; keepalive_timeout 65; server &#123; listen 80; server_name localhost; #之前配置的根目录 location / &#123; root /data/www; index index.html index.htm; &#125; #之前配置的图片目录 location /images/ &#123; root /data; &#125; #新增的video目录，即浏览器访问http://ip地址/video时，会进入服务器的/data/video目录 location /video/ &#123; root /data; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; &#125; &#125; 保存并退出，然后重启Nginx服务。 1systemctl restart nginx.service 1.4. 测试视频播放 在服务器的/data/video目录下放入一个mll.mp4视频文件，目录/data/video要建个，根据你的配置的目录来。 浏览器访问http://ip地址/video/mll.mp4 如：http://108.160.134.51/video/mll.mp4 播放成功即可，我服务器速度贼慢，后面换个服务器试试效果。 这时，就可以把视频嵌入到html中播放了，比如： 1&lt;iframe src="http://78.141.206.203/video/ct.mp4" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" autoplay="" width="100%" height="450px"&gt; &lt;/iframe&gt; 效果： (function(){var player = new DPlayer({"container":document.getElementById("dplayer1"),"autoplay":true,"theme":"#FADFA3","video":{"url":"http://78.141.206.203/video/Hold Me Now.mp4"},"danmaku":{"api":"http://dplayer.daoapp.io","token":"tokendemo"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})() 博客视频标签 服务器我换成伦敦的了，现在速度好些了，有的时间段比较卡。 Vultr测ping、服务器数据迁移备份 2. 直播这里搭建一个简单的直播体系，实际要复杂的多。 直播应该有推流端、服务器处理端、和接收端。 2.1. 服务器端配置之前配过视频播放了，这里也用Nginx-Rtmp模块，配置一下nginx就行了。 还是打开/usr/local/nginx/conf目录下的nginx.conf配置文件 1vi /usr/local/nginx/conf/nginx.conf 键盘按i编辑，方向键移动光标，编辑完按 ” :wq “ 保存退出 编辑内容： rtmp代码块 123456789101112131415161718192021222324252627282930rtmp&#123; server&#123; #端口号，要记住 listen 2019; chunk_size 4096; application video &#123; play /data/video; &#125; #新增live应用，名字可自定。live on，开启直播，一对多广播 application live &#123; live on; &#125; #hls，暂时用不到，可以不写 application hls_alic&#123; live on; hls on; hls_path /tmp/hls; &#125;&#125;&#125; http代码块 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354http &#123; include mime.types; default_type application/octet-stream; sendfile on; tcp_nopush on; keepalive_timeout 65; server &#123; listen 80; server_name localhost; location / &#123; root /data/www; index index.html index.htm; &#125; location /images/ &#123; root /data; &#125; location /video/ &#123; root /data; &#125; #新增，访问http://ip/stat时，为当前 HTTP location 设置 RTMP statistics 处理程序。RTMP statistics 是一个静态的 XML 文档。可以使用 rtmp_stat_stylesheet 指令在浏览器中作为 XHTML 页面查看这个文档。添加 XML 样式表引用到 statistics XML 使其可以在浏览器中可视。 location /stat &#123; rtmp_stat all; rtmp_stat_stylesheet stat.xsl; &#125; #新增，能直接访问stat.xsl文件，上面的一块，就是能在浏览器看到rtmp的状态信息 location /stat.xsl &#123; root /usr/local/nginx-rtmp-module-1.2.1; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; &#125; &#125; 重启Nginx服务。 1systemctl restart nginx.service 顺便让防火墙开放你配置的端口，比如这里我配置的2019端口： 1234#添加2019端口配置防火墙firewall-cmd --zone=public --add-port=2019/tcp --permanent#重新加载firewall-cmd --reload 浏览器访问http://你的服务器Ip/stat，如http://108.160.134.51/stat，若出现以下页面，则服务器配置成功。 2.2. 推流端推流可以用FFmpeg，功能强大，使用命令行进行操作，可以在服务器上使用，就是参数比较多，对新手不友好。 还可以用OBS，有windows版本，是大家常用的直播工具了。 OBS 先说下Obs，这个软件比较常见。在设置里面，左侧菜单选输出，输出模式选高级，点录像，选择输出到URL URL的格式是：rtmp://你的服务器ip:端口号/服务器配置的应用名/自定义个名字，容器格式最好选flv，因为体积会小点，其他看自己情况选。 FFmpeg FFmpeg，这个可以装在windows本机上，也可以装在服务器上，使用方式是命令行，下面说一下服务器上怎么装。windows同理，无所谓，可以用其他软件。 【FFmpeg使用示例：】ffmpeg -i /data/video/am.mkv -vcodec h264 -s 1920*1080 /data/video/am.mp4 我的服务器系统：CentOs 7，安装流程： 先安装环境支持，EPEL Release 12sudo yum install -y epel-release rpm#若出现缺少Code提示，执行：sudo rpm --import /etc/pki/rpm-gpg/RPM-GPG-KEY-EPEL-7 安装Nux-Dextop 12sudo rpm --import http://li.nux.ro/download/nux/RPM-GPG-KEY-nux.rosudo rpm -Uvh http://li.nux.ro/download/nux/dextop/el7/x86_64/nux-dextop-release-0-1.el7.nux.noarch.rpm 正式安装FFmpeg 123sudo yum install -y ffmpeg#检查是否安装成功ffmpeg -version 使用 这里使用服务器上的视频/data/video/mll.mp4，模拟推流。 推流到rtmp://localhost:2019/live/test，本地2019端口下的live应用，当然也可以推到远处的服务器，后面的test是自定义的名字。 1ffmpeg -re -i /data/video/mll.mp4 -c copy -f flv rtmp://localhost:2019/live/test 可以根据网速自定义码率： -b:v 3000k 意为视频码率3000k -b:a 320k 指音频 1ffmpeg -re -i /data/video/mllo.mp4 -c copy -b:v 3000k -b:a 320k -f flv rtmp://localhost:2019/live/test 更多使用参考：ffmpeg基础使用 推流后，我们需要一个接收端才能看到推流的效果。 2.3. 接收端（拉流端）这里我用的JWPlayer 解压JWPlayer，新建个html，与jwPlayer文件夹同级目录。 Html内容如下： 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt; &lt;html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"&gt; &lt;head&gt; &lt;meta http-equiv="content-type" content="text/html; charset=utf-8" /&gt; &lt;title&gt;live-player&lt;/title&gt; &lt;style type="text/css"&gt; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;script type='text/javascript' src='jwplayer/jwplayer.js'&gt;&lt;/script&gt; &lt;center&gt; &lt;b&gt;RTMP直播系统&lt;/b&gt; &lt;div id='mediaspace'&gt;This text will be replaced&lt;/div&gt; &lt;script type='text/javascript'&gt; // var server = window.location.hostname; // mylive 对应nginx.conf配置项application的名字 // live_stream 对应Adobe Flash Stream Media Live Encoder配置的stream名称 var live_url = 'rtmp://108.160.134.51:2019/live/test'; //链接的服务器流，与推流一致jwplayer('mediaspace').setup(&#123; 'flashplayer': 'jwplayer/jwplayer.flash.swf', 'file': live_url, 'controlbar': 'bottom', 'width': '760', 'height': '428', //autostart: true, //如果打开此标志，在打开网页时会自动播放直播流 &#125;); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 其中live_url应与推流端的推流地址一致，此html可传到服务器上Nginx管理的目录下，直接访问。也可在本地运行。 运行效果如图： 一个简单的直播系统便建好了。 参考文章： 利用RTMP实现直播系统 Nginx+RTMP 搭建视频点播服务器 译·Nginx RTMP模块指令详解 CentOS 7.5下FFmpeg安装、简单使用总结 ffmpeg基础使用 利用nginx搭建RTMP视频点播、直播/回放 ffmpeg+nginx+rtmp+web实现视频直播网站 使用nginx+nginx-rtmp-module+ffmpeg搭建流媒体服务器 Linux&amp;Windows搭建基于nginx的视频点播服务器 Nginx优化静态文件访问]]></content>
      <categories>
        <category>学习经验</category>
      </categories>
      <tags>
        <tag>视频播放</tag>
        <tag>直播</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sftp文件上传、下载]]></title>
    <url>%2F2019%2F08%2F05%2FSftp%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E3%80%81%E4%B8%8B%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[Sftp协议下文件上传、下载使用JSch进行Sftp连接问题产生 我用common-net，ftp连接时使用21端口会超时，后来发现使用Xftp工具用21端口也超时 1Connection timed out: connect 查了下百度，端口问题。 ftp服务用的是20、21端口，客户端添加ftp信息的时候输入的是21端口 ssh服务用的是22端口，应用于远程ssh管理Linux服务器； 然后我换了22端口进行尝试。 12 Could not parse response code.Server Reply: SSH-2.0-OpenSSH_7.4 异常如上，百度了下，于是开始用sftp协议尝试。 参考文章：主要参考，详细参考 问题解决 我制作了一个工具类，以供调用。 maven依赖 12345678&lt;dependency&gt; &lt;groupId&gt;com.jcraft&lt;/groupId&gt; &lt;artifactId&gt;jsch&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.jcraft&lt;/groupId&gt; &lt;artifactId&gt;jzlib&lt;/artifactId&gt; &lt;/dependency&gt; 还有一些依赖，如springMVC的依赖。 简单上传 遇到了很多的问题，像如何简化、如何创建目录、如何检查目录是否存在、认证问题等，在注释里写得很详细。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250package IO_Utils;import com.jcraft.jsch.*;import java.io.*;import java.lang.reflect.Array;import java.util.ArrayList;import java.util.Properties;import java.util.Vector;/** 我的sftp上传工具* */public class ImageSftp &#123; /**方法内属性说明 * private static ChannelSftp Sftp = null; //用户名(由外部传参) private static String ImgServerUsername = "root"; //主机ip(由外部传参) private static String ImgServerIp = "78.141.206.203"; //密码(由外部传参) private static String ImgServerPassword = "123456"; //端口号(由外部传参) private static int ImgServerPort = 22; //上传到的服务器目录(由外部传参) private static String ImgServerDirectory = "/data/images/"; //上传到服务器的文件命名为(由外部传参) private static String ImgServerFileName=""; //要上传的本地文件// private static File clientFile=null; //下载到本地的目录（由外部传参） private static String ClientDirectory = "D:\\aria2\\"; //下载到本地的文件命名为（由外部传参） private static String ClientFileName ="";*/ private Channel channel=null; private Session sshSession=null; private ChannelSftp sftp =null;/** 获取连接对象的方法* */ public ChannelSftp getConnect(String imgServerIp, int imgServerPort,String imgServerUsername,String imgServerPassword) &#123; JSch jsch = new JSch(); try &#123; //用户名、ip、端口号 sshSession = jsch.getSession(imgServerUsername,imgServerIp, imgServerPort); //配置属性 Properties config = new Properties(); config.put("StrictHostKeyChecking","no"); config.put("PreferredAuthentications","password"); sshSession.setConfig(config); //不检查主机严格密钥// sshSession.setConfig("StrictHostKeyChecking", "no"); //关闭gssapi认证，只使用密码认证，减少耗时 //config.put("userauth.gssapi-with-mic", "no");// sshSession.setConfig("PreferredAuthentications","password"); //给密码设值 sshSession.setPassword(imgServerPassword); //设置多少毫秒超时（设了会报错）// sshSession.connect(600);// sshSession.setServerAliveInterval(92000);// 请求时长 System.out.println("正在与服务器建立连接"); //开启sshSession链接// sshSession.connect(); sshSession.connect(5000); //获取sftp通道 channel = sshSession.openChannel("sftp"); channel.connect(); ChannelSftp sftp = (ChannelSftp) channel; System.out.println("已成功建立连接"); return sftp; &#125;catch (JSchException e)&#123; e.printStackTrace(); System.out.println("建立连接失败"); return null; &#125; &#125; /** * 上传方法 * @param sftp 通过getConnect()方法获得的链接对象 * @param inputStream 要上传文件的输入流 * //@param serverDirectory 某类文件存放的目录，必须指明为根目录某处，如：/data/video/，斜杠必须带 * @param finalServerDirectory 上传文件最终所在的目录，=serverDirectory/nextDirectory * @param serverFileName 为上传到服务器后的文件名 * */ public boolean upload(ChannelSftp sftp,InputStream inputStream ,String finalServerDirectory,String serverFileName) throws IOException, SftpException &#123; //连接服务器// ChannelSftp sftp = getConnect(); if (sftp!=null) &#123; //进入要存储的服务器目录// sftp.cd(serverDirectory); SftpATTRS stat=null; //判断文件夹是不是存在，这里要捕获异常，不然会卡住 try &#123; stat = sftp.stat(finalServerDirectory); System.out.println("找到了目标文件（夹）："+stat+"\n\n\n"); &#125;catch (Exception e)&#123; System.out.println("找不到目标目录"); &#125; if (stat!=null)&#123;//stat有返回值，说明文件夹存在 //进入该文件夹 sftp.cd(finalServerDirectory); System.out.println("进入文件夹"); &#125;else &#123; //创建文件夹，然后进入 sftp.mkdir(finalServerDirectory); sftp.cd(finalServerDirectory); System.out.println("自动创建"+finalServerDirectory+"文件夹，并进入"); &#125; //本地文件，存到流，不需要，因为前台会直接收到MultipartFile类型的文件，并且能获得流// File clientFile = new File(filePath);// InputStream fileInputStream = new FileInputStream(clientFile); //上传到服务器后的名字，由外部传参// serverFileName="1.avi"; System.out.println("上传ing"); //获取文件大小（字节） long size = inputStream.available(); //执行上传（断点续传方式） sftp.put(inputStream, serverFileName,new SftpMonitor(size),ChannelSftp.RESUME); System.out.println("上传完毕");//交给单独方法去断开连接// System.out.println("关闭连接"); //断开连接// sftp.disconnect();//// System.out.println("连接是否已关闭"+sftp.isClosed()); return true; &#125;else &#123; return false; &#125; &#125; /** * 关闭连接 * */ public void close() throws Exception&#123; if (sftp!=null)&#123; sftp.quit(); &#125; if (channel!=null)&#123; channel.disconnect(); System.out.println("已关闭通道"); &#125; if (sshSession!=null)&#123; sshSession.disconnect(); System.out.println("已关闭连接"); &#125; &#125; /* * 下载方法 * 未写，因为暂时用不到 * 暂定 * */// public static String download() throws JSchException, SftpException, FileNotFoundException &#123;// ChannelSftp sftp = getConnect();//// clientFileName="123.png";// File clientFile=new File(clientDirectory+clientFileName);// serverDirectory="/data/images/";// serverFileName="123.png";// sftp.get(serverDirectory+serverFileName, new FileOutputStream(clientFile));// return clientDirectory+clientFileName;//// &#125; //测试 public static void main(String[] args) throws Exception &#123; String imgServerIp="78.141.206.203"; int imgServerPort=22; String imgServerUsername="root"; String imgServerPWD="123456"; ImageSftp imageSftp=new ImageSftp(); ChannelSftp connect = imageSftp.getConnect(imgServerIp, imgServerPort, imgServerUsername, imgServerPWD);// String filePath="C:\\Users\\Shirtiny\\Downloads\\masu.jpg";//要上传的文件的路径//现在是你直接给我个输入流 //获取输入流 String filePath="D:\\MY文档\\音乐\\折戸伸治 - 潮鳴り.mp3"; File file=new File(filePath);// long fileSize = file.length();// System.out.println("文件大小"+fileSize); FileInputStream fileInputStream = new FileInputStream(file); String finalServerDirectory="/data/music";//上传到的服务器目录,调用上传方法时，若找不到该目录，则程序自动创建。代表文件最终存放的目录 String serverFileName="潮鸣.mp3";//上传到服务器的文件命名为// Vector ls = connect.ls(finalServerDirectory);// connect.put("D:\\MY文档\\音乐\\折戸伸治 - 潮鳴り.mp3","123.mp3",new SftpMonitor(),ChannelSftp.OVERWRITE); boolean flag = imageSftp.upload(connect, fileInputStream, finalServerDirectory, serverFileName); System.out.println("是否完成："+flag); //关闭连接 connect.quit(); imageSftp.close(); &#125;&#125; 下载方法未写 下载时拒绝访问的问题 实例我现在需要将一个文件（图片为例）上传到服务器，使用sftp协议，需求如下： 点击上传按钮，选择文件后即可上传 能看到上传的进度和速度 能在上传成功、异常结束时得到反馈 要求在上传后，程序自动显示该图片 图片需要按照一定分类去存储，以方便管理，减少资源消耗 图片名称不能重复，并且图片能正确显示 全程支持中文 支持断点续传 首先，进度监控、断点续传很显然我们目前的这个工具类还不能满足我们的需求，它还需要两个功能： 1.实时监控，这样我们才能知道上传的速度、进度 2.断点续传，值得高兴的是，Jsch为我们提供了这个功能。 1. 实时监控SftpProgressMonitor Jsch提供了一个SftpProgressMonitor接口，包括了初始化时执行的init()方法、每传输一个数据块就会执行一次的count()方法、以及在传输结束时执行的end()方法。 基于这个接口，我们可以写出一个简单监控类： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package IO_Utils;import com.jcraft.jsch.SftpProgressMonitor;/** * 上传进程监控 * */public class SftpMonitor implements SftpProgressMonitor &#123; private long counted;//初始字节数，已经上传的字节数 private long fileSize;//最终文件大小 private long percent;//进度百分比值 public SftpMonitor() &#123; &#125; public SftpMonitor(long fileSize) &#123; this.fileSize = fileSize; &#125; @Override public void init(int op, String src, String dest, long errfileSize) &#123; System.out.println("初始化完成"+"文件大小为："+fileSize); &#125; @Override public boolean count(long count) &#123;// System.out.println("之前已上传"+counted+"("+percent+"%)"); counted +=count;// if (percent&gt;=this.count/fileSize)&#123;// return true;// &#125; percent= counted*100/fileSize; System.out.println("进度-----已传输："+counted/1024+" kb/"+fileSize/1024+" kb"+"("+percent+"%)"); return true; &#125; @Override public void end() &#123; System.out.println("end结束"); &#125;&#125; 它的使用方式： 123long size = inputStream.available();//通过流获取文件大小 //执行上传 sftp.put(inputStream, serverFileName,new SftpMonitor(size);//在执行put方法时初始化一个监控类 很抱歉，由于时间关系，我不能像以往那样详细说明，Jsch：put方法的重载。 SftpProgressMonitor+TimerTask+Pojo 我们需要获得传输的速度，所以需要有个Timer来帮忙，对此不了解的可查看Timer的使用. 我们可以通过重写TimerTask类的run()方法，来实现我们需要的功能。我写了一个start()方法用于创建timer对象，新建计划任务，stop()方法用于终止计时。run()方法会按照我们设置的计划，每隔一段时间执行一次，用单独的线程来执行。 我把需要的信息封装到一个pojo类里，你也可以不封装。 由此便有了一个新的监控类： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156package Sftp_service;import com.jcraft.jsch.SftpProgressMonitor;import org.springframework.beans.factory.annotation.Autowired;import java.text.DecimalFormat;import java.util.Timer;import java.util.TimerTask;public class mySftpTimerMonitor extends TimerTask implements SftpProgressMonitor &#123; private long fileSize;//文件总大小 private long counted;//已传输数据，单位字节 private long counted_Before=0;//上一秒的已传输数据，单位字节 private long i_ed=0;//已计时间，单位s private Timer timer;//计时器对象 private long timeInterval=2*1000;//时间间隔，单位ms private boolean timerIsStarted;//是否已经开始计时 private DecimalFormat format = new DecimalFormat( &quot;#.##&quot;);//用于转换数据显示格式 private SftpSpeedInfo speedInfo=new SftpSpeedInfo(); public mySftpTimerMonitor() &#123; &#125; mySftpTimerMonitor(long fileSize) &#123; this.fileSize = fileSize; &#125; @Override//监视器方法重写 public boolean count(long count) &#123;//每传输一次数据块，就会执行一次count方法 if (!timerIsStarted)&#123;//只在无计时器时，开启计时器 timerStart();//开始计时 &#125; incrementCounted(count);//执行自增 return true; &#125; //Timertask run @Override//计时器方法重写 public void run() &#123;//计时器控制的方法，每多少时间执行一次，用单独的线程执行。前提是启动计时器 /* *i++; *System.out.println(counted+&quot;已用时间&quot;+this.i+&quot;s&quot;); *可以这样。不过可能是考虑到多线程的原因应该这样做： * */ //这样取值更好，其他线程需要等待这个线程取完值，才能去取值 long i1 =getI_ed();//这样就有个新问题，如何使i自增，直接在run内i++是不行的，因为getI()的值没有变 long i2 = incrementI_ed(i1);//新建个方法，用来使秒数自增一次，自憎后的值为i2 long counted_latest=getCounted();//同理拿到当前的，已传输数据量counted的值 long counted_before = getCounted_Before();//拿到上一次的已传数据量 setCounted_Before(counted_latest);//把这次的已传数据量存起来 double speed=(double)(counted_latest-counted_before)/(1024*(timeInterval/1000));//计算传输速度，单位kb/s，speed=当前已传输量-上次的已传输量/(1024*时间间隔/1000) double percent=(double)counted_latest/(double)fileSize; speedInfo.setPercent(format.format(percent*100)+&quot;%&quot;);//百分比 speedInfo.setSpeed(format.format(speed)+&quot;kb/s&quot;);//速度 speedInfo.setCounted(format.format((double)counted/1024)+&quot;kb&quot;);//已传输量 speedInfo.setTimed(i2);//用时 s System.out.println(speedInfo); &#125; private void timerStart()&#123;//自定义的计时器方法，启动计时器 if (timer!=null)&#123; timer.cancel();//终止此计时器，丢弃所有当前已安排的任务。 timer.purge();//从此计时器的任务队列中移除所有已取消的任务。 &#125;else &#123; timer=new Timer();// 这个方法是调度一个task，在delay（ms）后开始调度，每次调度完后，最少等待period（ms）后才开始调度 timer.schedule(this,1000,timeInterval); timerIsStarted=true; System.out.println(&quot;Timer is started,计时器启动完成&quot;); &#125; &#125; public void stop()&#123;//自定义的计时器方法，停止计时器 if (timer != null) &#123; timer.cancel(); timer.purge(); timer = null; timerIsStarted=false; &#125; System.out.println(&quot;stop timer,停止计时&quot;); &#125; @Override//监视器方法重写 public void init(int i, String s, String s1, long l) &#123; speedInfo.setFileSize(format.format((double)this.fileSize/1024)+&quot;kb&quot;);//文件大小 &#125; @Override//监视器方法重写 public void end() &#123;//传输结束 stop();//停止计时器，并清空数据 &#125; //使用synchronized关键字，线程排队调用，即线程同步 public synchronized long getFileSize() &#123; return fileSize; &#125; private synchronized long getCounted_Before() &#123;//取出上一秒的数据量 return counted_Before; &#125; private synchronized void setCounted_Before(long counted_latest) &#123;//把这一秒的已传输数据量记录给counted_Before，为下一秒服务 this.counted_Before = counted_latest; &#125; private synchronized long getI_ed() &#123;//上一秒i的值，已计秒数 return i_ed; &#125; private synchronized long getCounted() &#123;//此次已传数据量的值 return counted; &#125; private synchronized void incrementCounted(long count)&#123;//已传数据量自增方法 counted=counted+count; &#125; // private synchronized long incrementI_ed(long i1)&#123;//已计秒数 自增方法 i_ed=i1+(timeInterval/1000);//自增一次，自增值为间隔时间（s） return i_ed; &#125;&#125; 2.断点续传好在Jsch提供了这个功能，我们不必再费脑筋。我们只需要在执行put()时，把mode的值改为ChannelSftp.RESUME即可。 12 long size = inputStream.available();sftp.put(inputStream, serverFileName,new mySftpTimerMonitor(size),ChannelSftp.RESUME); OVERWRITE是覆盖，APPEND是扩展。 其次，文件夹分类、文件名随机直接看代码即可，这是service层： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package com.SH.Service.ServiceImpl;import ID_Utils.ID_Imghelper;import com.SH.Service.IimgService;import Sftp_service.ImageSftp;import com.jcraft.jsch.ChannelSftp;import com.jcraft.jsch.SftpException;import org.springframework.beans.factory.annotation.Value;import org.springframework.stereotype.Service;import java.io.IOException;import java.io.InputStream;import java.text.SimpleDateFormat;import java.util.Date;@Servicepublic class imgServiceImpl implements IimgService &#123; @Value("$&#123;ImgServerIp&#125;") private String ImgServerIp;//图片服务器ip @Value("$&#123;ImgServerPort&#125;") private int ImgServerPort;//端口号 @Value("$&#123;ImgServerUsername&#125;") private String ImgServerUsername;//用户名 @Value("$&#123;ImgServerPassword&#125;") private String ImgServerPassword;//密码 @Value("$&#123;ImgServerDirectory&#125;") private String ImgServerDirectory;//存储路径 @Override public boolean Imgupload(InputStream inputStream,String suffix) throws Exception &#123; boolean flag; ImageSftp imageSftp=new ImageSftp(); String fileName= ID_Imghelper.getImgID()+suffix; ChannelSftp connect = imageSftp.getConnect(ImgServerIp, ImgServerPort, ImgServerUsername, ImgServerPassword); //根据时间创建一个字符串作为文件夹的名字，方便管理 String nextDirectory = new SimpleDateFormat("yyyy-MM-dd").format(new Date()); //最终文件存放的目录名 String finalServerDirectory=ImgServerDirectory + "/" + nextDirectory; try &#123; flag= imageSftp.upload(connect,inputStream,finalServerDirectory,fileName); System.out.println("上传返回值："+flag); &#125; catch (IOException e) &#123; e.printStackTrace(); return false; &#125; catch (SftpException e) &#123; return false; &#125; imageSftp.close(); return flag; &#125;&#125; 其中用imageSftp.properties存储服务器信息，使用@Value注解获取配置文件信息。 spring配置： 12345678&lt;bean id="dbproperties" class="org.springframework.beans.factory.config.PreferencesPlaceholderConfigurer"&gt; &lt;property name="locations"&gt; &lt;array&gt; &lt;!--数据库配置文件 --&gt; &lt;value&gt;classpath:db.properties&lt;/value&gt; &lt;!--图片服务器配置文件 --&gt; &lt;value&gt;classpath:imageSftp.properties&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;/bean&gt; imageSftp.properties： 12345ImgServerIp=78.141.206.203ImgServerPort=22ImgServerUsername=rootImgServerPassword=123456ImgServerDirectory=/data/images ID_Imghelper，根据时间随机生成图片Id（文件名）的工具类： 12345678910111213141516171819202122232425262728293031package ID_Utils;import java.util.Random;public class ID_Imghelper &#123; public static String getImgID()&#123; long timeMillis = System.currentTimeMillis(); Random random = new Random(); int randomInt = random.nextInt(9999); //%X 获得数字，把它转为16进制，大写字母 //%04X 增加的04，意思是，转化后的字符串占4个字符，不够用0填充 String imgID=timeMillis+String.format("%04X",randomInt); /*其他转化： * %x - 接受一个数字并将其转化为十六进制数格式, 使用小写字母 * %d, %i - 接受一个数字并将其转化为有符号的整数格式 * %s - 接受一个字符串并按照给定的参数格式化该字符串 * %e - 接受一个数字并将其转化为科学记数法格式, 使用小写字母e */ return imgID; &#125; public static void main(String[] args) &#123; String imgID = ID_Imghelper.getImgID(); System.out.println(imgID); &#125;&#125; 最后，图片回显、结果反馈、中文支持等图片回显只需要把服务器上的文件地址拼接出来即可。 这里给个参考，Controller： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.SH.Controller;import ...@Controllerpublic class testController &#123; @Autowired private IimgService imgService; @RequestMapping(value = "/upload",produces = "text/plain;charset=UTF-8") //produces属性，设置响应格式 @ResponseBody public String upload(MultipartFile file,Map&lt;String,Object&gt; map) throws Exception &#123; InputStream inputStream = file.getInputStream(); System.out.println("文件大小"+file.getSize()); String originalFilename = file.getOriginalFilename(); //截取字符串substring(start,stop)，从下标为start值的位置（第start个字符）开始截取,省略stop会截取start以后得全部字符串 //注意stop值为要截取到字符的对应下标+1，如字符串123，下标为012，从如要截取出字符串12，比喻成区间（下标）为[0,1)，写法为substring(0,2) //lastIndexOf(".")字符串倒数第一个.的下标 String suffix = originalFilename.substring(originalFilename.lastIndexOf(".")); System.out.println(originalFilename); System.out.println(suffix); System.out.println((file.getSize()/1024.00)+"kb"); boolean flag = imgService.Imgupload(inputStream, suffix); //json转换对象 ObjectMapper MAPPER=new ObjectMapper(); if (flag)&#123; map.put("上传成功",flag); //把对象转换为json格式字符串 return MAPPER.writeValueAsString(map); &#125;else &#123; map.put("上传失败",flag); return MAPPER.writeValueAsString(map); &#125; &#125;&#125; 参考文章： https://blog.csdn.net/weixin_36910300/article/details/80532868 https://blog.csdn.net/qq_33390789/article/details/78614466 https://www.cnblogs.com/longyg/archive/2012/06/25/2556576.html https://www.cnblogs.com/ssslinppp/p/6248763.html https://blog.csdn.net/chaogewudi1/article/details/81629183 https://www.cnblogs.com/awkflf11/articles/5179156.html https://www.cnblogs.com/longyg/archive/2012/06/25/2556576.html https://blog.csdn.net/ecjtuxuan/article/details/2093757 https://blog.csdn.net/hl_java/article/details/79035237 https://blog.csdn.net/zjy15203167987/article/details/82531772 https://www.jb51.net/article/135720.htm]]></content>
      <categories>
        <category>学习经验</category>
      </categories>
      <tags>
        <tag>ftp</tag>
        <tag>上传下载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭梯子访问墙外网站]]></title>
    <url>%2F2019%2F08%2F04%2F%E6%90%AD%E6%A2%AF%E5%AD%90%E8%AE%BF%E9%97%AE%E5%A2%99%E5%A4%96%E7%BD%91%E7%AB%99%2F</url>
    <content type="text"><![CDATA[翻墙搭梯子首先你需要一个境外服务器、远程可以用Xshell 6，不熟的可以看站内linux的教程。 安卓客户端： Shadowsocks 参考文章：半醉人间、polarxiong 命令列表： 123#这里所有安装遇到选项一律输y，回车#安装python setuptoolsyum install python-setuptools 12#下载pip压缩包wget https://pypi.python.org/packages/source/p/pip/pip-1.3.1.tar.gz --no-check-certificate 123456789101112#下载完后，解压它tar -xzvf pip-1.3.1.tar.gz#进入解压出的文件夹cd pip-1.3.1#安装pythonpython setup.py install#安装shadowsockspip install shadowsocks#创建shadowsocks文件夹mkdir /etc/shadowsocks#创建并编辑shadowsocks配置文件vi /etc/shadowsocks/config.json 进入config.json文件后按I进入Insert模式，可以进行编辑。 复制粘贴以下内容，注意要填一些东西。 12345678910&#123; "server":"你的服务器的ip地址", "port_password": &#123; "8888": "123456", "8889": "123456" &#125;, "timeout":600, "method":"aes-256-cfb", "fast_open": false&#125; 然后按Esc、:wq（输入冒号wq，意为保存并退出） 这里是设置服务器端的Shadowsocks，后面需要用到上面你填入的信息，对应为： 主要信息： 服务器ip：你的服务器的ip地址 配置端口：8888、8889 密码都为：123456 加密方式：aes-256-cfb 123#开启服务ssserver -c /etc/shadowsocks/config.json -d start#关闭后面改为stop 12#创建并编辑shadowsocks.service，这里是要配置开机自启动vi /etc/systemd/system/shadowsocks.service 与刚刚一样，进入了这个文件，按i可以进行编辑，把以下内容复制到里面： 123456789101112131415161718[Unit]Description=ShadowsocksAfter=network.target[Service]Type=forkingPIDFile=/run/shadowsocks/server.pidPermissionsStartOnly=trueExecStartPre=/bin/mkdir -p /run/shadowsocksExecStartPre=/bin/chown root:root /run/shadowsocksExecStart=/usr/bin/ssserver --pid-file /var/run/shadowsocks/server.pid -c /etc/shadowsocks/config.json -d startRestart=on-abortUser=rootGroup=rootUMask=0027[Install]WantedBy=multi-user.target esc，:wq 保存退出后，再输入以下命令： 1234567891011#权限chmod 755 /etc/systemd/system/shadowsocks.service#启动、启用systemctl start shadowsockssystemctl enable shadowsocks#配置防火墙开放端口firewall-cmd --zone=public --add-port=8888/tcp --permanentfirewall-cmd --zone=public --add-port=8889/tcp --permanentfirewall-cmd --reload 然后在手机上安装Shadowsocks，填入上面对应的主要信息（服务器ip、端口、密码、加密方式），就可以使用代理了，若握手成功，此时谷歌、Youtube等网站都可以访问了。 填好后，点下面的纸飞机进行连接。]]></content>
      <categories>
        <category>闲谈</category>
      </categories>
      <tags>
        <tag>vpn</tag>
        <tag>梯子</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[远程连接Linux部署项目]]></title>
    <url>%2F2019%2F08%2F03%2F%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5Linux%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[Linux操作、远程连接、项目部署1. 安装工具环境准备： 各种安装包：Xshell Plus 6|Xshell 6、Xftp 5、linux版本的jdk、Linux版本的MySQL、Linux版本的Nginx 现在下载jdk需要登录Oracle：Oracle账号分享 我当时用的账号 用户名：nicabeta@email-wizard.com 密码：MQEemoh3pOsRAn2c4tjh 注册机：NetSarang_AIO_7in1_Keygen_v1.4_DFoX_URET 百度网盘（可能会失效）： Xshell Plus 6 【j5r8】 Xftp 5 【d3jq】 注册机 【6zcp】 RDM 【2m91】 Nginx-Linux 【xnno】 jdk-Linux 【bph9】 开始安装 Xshell Plus 6 或 Xshell 6 运行注册机，选择你安装的软件,点击Fix Host+Register，然后点击Generate，然后复制生成的序列号 输入上一步获得的序列号，用户名和公司名称随意，选择路径后安装即可。 Xftp同上： ​ 点下一步，安装即可。 2. 更换服务器的JDK2.1. 拿到服务器ip买的服务器会直接给你ip的，这里我用的虚拟机，桥接模式下与我本机的ip应该是一样的。 点左上角Applications，点Favorites下的 Terminal： 在弹出的命令行窗口，输入： 12ifconfig#获取ip配置信息，windows下命令是ipconfig 回车，即可看到ip信息，复制ens33里的inet后的ip地址： 2.2. 使用Xshell建立连接打开Xshell 6，新建会话，名称随意，主机是刚刚的ip地址： 点击连接，在提示框输入服务器需要的用户名密码，都正确的话会连接成功，有时候第一次连接会报错，再连一次就好了。连接成功会显示： 2.3. 卸载open JDK1.Xshell输入： 1java -version 可看到当前java版本： 2.Xshell输入： 12rpm -qa | grep jdk#抓取jdk 3.Xshell输入： 123rpm -e --nodeps #加要删除对象的完整名称（上面抓取时显示了），需要root身份，这里是：rpm -e --nodeps java-1.8.0-openjdk-1.8.0.181-7.b13.el7.x86_64rpm -e --nodeps java-1.8.0-openjdk-headless-1.8.0.181-7.b13.el7.x86_64 不报错，并且输入java -version提示找不到文件，即卸载成功： 2.4. 安装准备的JDK1.Xshell输入： 12pwd#获取当前所在的目录（文件夹）路径 此时在/root目录下。 2.Xshell输入： 123456cd /usr/local#进入指定目录，可用pwd确认当前所在的目录mkdir java#在当前目录 创建java文件夹cd java#进入java文件夹内，可用pwd确认当前所在的目录 点击帮助正下方的绿色按钮，打开Xftp，右边一般会自动定位到服务器的当前目录，左边是本机电脑，把下载好的jdk拖到右边就行了，注意目录： 3.Xshell输入 123456789101112131415ls#列出当前目录的文件名称ll#列出当前目录文件的详细信息tar -zxvf 文件名#解压tar包压缩文件，此处为：tar -zxvf jdk-8u221-linux-x64.tar.gzls#列出当前目录的文件名称cd jdk1.8.0_221#进入jdk解压后的文件夹ls#列出当前目录的文件名称 4.Xshell输入 12vim /etc/profile#编辑指定的文件，这里是配置环境变量 5.键盘按I键，进入Insert编辑，按方向键把光标移到最下方： 输入（##是注释）： 1234##jdk1.8export JAVA_HOME=/usr/local/java/jdk1.8.0_221export PATH=$JAVA_HOME/bin:$PATHexport CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar 键盘按esc，输入冒号wq（意为保存并退出），回车。 此处输入： 12:wq#保存并退出 扩展知识： 12:q!#不保存强制退出s 6.Xshell输入： 123456cat /etc/profile#将指定文件显示出来，这里是看一下刚刚的文件是否已保存source /etc/profile#使刚刚的配置文件生效java -version#验证jdk 正常的结果： 到此JDK安装配置结束。 3. 安装MySQL。以后装 4. 安装Redis4.1. 准备安装包或wget下载离线下载 或 服务器上选个存放安装包的目录，用wget下载 1234#进入存放目录cd /usr/local#wget加下载地址wget http://download.redis.io/releases/redis-5.0.5.tar.gz 4.2. 准备安装环境安装需要gcc编译，所以安装前需要看一下gcc的版本 12#查看gcc版本gcc -v 确认gcc版本是不是4.2以上，若没有gcc或版本不够，需要再安装gcc 12#安装gccyum install gcc 装好后确认一下gcc版本。 4.3. Redis安装解压下载好的Redis的压缩包 1234#解压tar -zxvf redis-5.0.5.tar.gz#进入解压出的文件夹cd redis-5.0.5 尝试安装测试（必要） 1234#若报错，去百度对应提示make MALLOC=libc#测试安装，不管有没有错误，都会回滚。出错的话，根据错误提示去百度解决make test 我这里错误是提示需要tcl支持，所以要安装tcl 1234#安装tclyum install tcl#继续make测试，直到无错误提示make test 正式安装 12cd srcmake install 无错，即成功。 4.4. 运行Redis前台运行在Redis安装目录下 12#前台运行redis./redis-server 前台运行的话，不能关闭那个界面，关闭的话就会关闭服务。 后台运行配置服务 应该使用后台运行的方式，需要进行如下配置： ①修改redis配置文件为后台模式启动 12#修改redis配置文件vi /usr/local/redis-5.0.5/redis.conf 按i进入编辑模式，将daemonize no改为daemonize yes，esc，:wq保存退出。 daemonize意思为：是否守护线程启动（是否后台模式启动） 修改ip绑定，将bind 127.0.0.1 修改为bind 0.0.0.0 （4个0），表示所有ip都可以连接。注意别改错了，是没有#号的bind 127.0.0.1。 123#bind 127.0.0.1#-&gt;bind 0.0.0.0 设置密码（可选） esc退出编辑模式，输入/require（搜索require），把#号去掉，然后requirepass后的值就是你的密码 1requirepass password ②将redis配置文件redis.conf复制到/etc/redis目录下，并改名为6379.conf 12345678cd /etcmkdir rediscd redis#把目标文件复制到当前目录cp /usr/local/redis-5.0.5/redis.conf ./#把目标文件移动到本目录，并重命名为mv redis.conf 6379.conf#tips：把目标文件覆盖复制到当前目录并改名为（cp -f 目标目录 6379.conf） ③复制启动脚本到/etc/rc.d/init.d/，并改名为redisd 启动脚本为：/usr/local/redis-5.0.5/utils/redis_init_script 123456#把目标文件复制到指定目录下，并命名为redisdcp /usr/local/redis-5.0.5/utils/redis_init_script /etc/rc.d/init.d/redisd#或手动改名：#cd /etc/rc.d/init.d/#ls#mv redis_init_script redisd ④修改刚刚重命名的redisd文件，让它成为服务 12cd /etc/rc.d/init.d/vim redisd 按i进入编辑模式 老版本需要在脚本文件的第一行后，加入一行（包括#号）： 1#chkconfig:2345 80 90 新版不用加。 然后，修改EXEC、CLIEXEC的路径： 1234567#原内容EXEC=/usr/local/bin/redis-serverCLIEXEC=/usr/local/bin/redis-cli#修改后的内容EXEC=/usr/local/redis-5.0.5/src/redis-serverCLIEXEC=/usr/local/redis-5.0.5/src/redis-cli 最后，找到case**in什么的那一块代码，在$EXEC $CONF 后面加上 &amp;（空格+&amp;符号+空格） 启动Redis 12345#添加开机启动chkconfig redisd on#防火墙开放6379端口firewall-cmd --zone=public --add-port=6379/tcp --permanentfirewall-cmd --reload 123456789101112#运行redisservice redisd start#停止redisservice redisd stop#修改redis配置文件vi /etc/redis/6379.conf#查看运行状态ps -ef | grep redis#强行kill进程，14399是目标进程的idkill -9 14399 #移除pid文件rm -f /var/run/redis_6379.pid 4.5. Redis使用1234cd /usr/local/redis-5.0.5/src/ls#redis客户端redis-cli redis的一些命令，自行百度 123456#设置set abc 123#取值get abc#显示全部keykeys * Redis命令表 RDM 提取码：【2m91】 5. 安装Nginx5.1. 准备安装包把安装文件传到服务器。 或者使用weget方式在服务器内下载也行： 123cd /usr/localweget http://nginx.org/download/nginx-1.17.1.tar.gz#下载安装包到usr/local 解压 1234tar -zxvf nginx-1.17.1.tar.gz#解压，z表示gzip压缩格式，x表示提取文件，v表示显示解压过程，f指定文件ll#显示当前文件夹的文件 5.2. 准备安装环境安装前必须安装nginx所需的依赖库。 安装依赖，仔细执行： 12345678yum install gcc-c++yum install pcreyum install pcre-develyum install zlibyum install zlib-develyum install opensslyum install openssl-devel#遇到选项输y即可 5.3. Nginx安装1234567ll#显示当前文件夹的文件cd nginx-1.17.1ll#显示当前文件夹的文件./configure#执行configure文件，输一半名字按tab会自动补全文件名的 执行make安装 12345678910make install#注意在nginx-1.17.1目录下执行#它会将nginx安装到/usr/local/nginx目录下cd ..#返回上一目录ll#显示当前文件夹的文件cd nginxpwd#显示当前所在的目录 配置Nginx开机启动 1234cd /lib/systemd/systemvim nginx.service#创建nginx.service文件并编辑，也可以用touch命令创建。#vim不行就vi 按I，添加如下内容： 12345678910111213[Unit]Description=nginxAfter=network.target[Service]Type=forkingExecStart=/usr/local/nginx/sbin/nginxExecReload=/usr/local/nginx/sbin/nginx reloadExecStop=/usr/local/nginx/sbin/nginx quitPrivateTmp=true[Install]WantedBy=multi-user.target esc :wq 保存并退出，用cat检查下刚刚的文件。 接着输入： 12systemctl enable nginx.service#使其开机启动 安装配置，到此就完成了。 5.4. Nginx指令、运行检查12345678systemctl start nginx.service#启动systemctl stop nginx.service#停止systemctl restart nginx.service#重启 启动Nginx，浏览器输入ip，若访问不到： 1234#添加80端口配置防火墙firewall-cmd --zone=public --add-port=80/tcp --permanent#重新加载firewall-cmd --reload 再去访问即可。 12chmod a+x /usr/local/nginx#访问权限,a+x ==&gt; all user can execute 所有用户可执行 关于路径 nginx根目录是/nginx/html文件夹。我的是：/usr/local/nginx/html 比如在html文件夹下建images文件夹，里面放张图片123.png，那么图片的路径就是：http://ip地址/images/123.png 路径配置 比如在根部吗建立data文件夹，在data下建立www和images两个文件夹： 123456mkdir /datacd /datamkdir wwwcd ..mkdir imagesll 然后打开nginx的配置文件/usr/local/nginx/conf/nginx.conf 注释掉原文http｛｝代码块，或者再其基础上修改成: 123456789101112131415161718http&#123;server &#123; #root的路径实际是nginx文件夹内的相对路径,/是主机根目录 #把访问时的ip地址/，设置为本机根目录下的/data/www文件夹 # 首页设为其文件夹下的index.html或index.htm location / &#123; root /data/www; index index.html index.htm; &#125; #地址栏里"/"后的路径是直接匹配目录/data下的路径 #如访问ip地址/images时,配匹配/data/images #把访问时的ip/images路径，设置为 location /images/ &#123; root /data; &#125;&#125;&#125; 关于SSL证书]]></content>
      <categories>
        <category>学习经验</category>
      </categories>
      <tags>
        <tag>开发知识</tag>
        <tag>Linux系统</tag>
        <tag>远程连接</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[虚拟机、Linux系统(CentOs)的安装]]></title>
    <url>%2F2019%2F08%2F03%2F%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%81Linux%E7%B3%BB%E7%BB%9F-CentOs-%E7%9A%84%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[虚拟机、Linux系统环境准备： 虚拟机工具：VMwear安装包【提取码：8k77】 Linux系统：CentOS7镜像 1. 安装虚拟机1.1. 安装VMwear运行VMwear安装包，过程很简单。 1.2. 创建虚拟机 VMwear安装完成后，打开它: 选择创建新的虚拟机，若选典型会自动为新手配置一些东西，这里选自定义： 兼容性问题，VMwear是高版本兼容低版本的，低版本不兼容高版本，这里选当前VMwear的版本就好，我给的资源版本号是12： 下一步，选稍后安装系统： 选择Linux系统，版本是CentOs 64位： 为虚拟机指定名称和位置，我新建了一个目录来存放，方便自己以后查找： 根据自己的实际需求来分配cpu，以后使用中CPU不够的话可以加，这里我选的11： 分配内存，要考虑到本机的空闲内存： 我计算机是8G内存，日常使用中，除开系统占用，开了几个浏览器、视频，只剩余了3G内存。 又考虑到会模拟多台服务器的运行，所以分配内存不能太大，也不能过低。 我选的1G内存，装了半天的系统，不过没关系，后面在设置里可以改的。 选择网络类型，这里选桥接： tips： 桥接：选择桥接模式的话虚拟机和宿主机在网络上就是平级的关系，相当于连接在同一交换机上。 NAT：NAT模式就是虚拟机要联网得先通过宿主机才能和外面进行通信。 仅主机：虚拟机与宿主机直接连起来 I/O控制器类型&amp;和磁盘类型选默认的即可： 由于是第一次使用虚拟机，选择创建新的虚拟磁盘： 磁盘空间分配： 我在VMwear下新建了一个VsFile文件夹，用来保存虚拟磁盘的文件： tips: 磁盘容量暂时分配50G即可后期可以随时增加，不要勾选立即分配所有磁盘，否则虚拟机会将50G直接分配给CentOS，会导致宿主机所剩硬盘容量减少。 勾选将虚拟磁盘拆分成多个文件，这样可以使虚拟机方便用储存设备拷贝复制。 自定义硬件： 移除不需要的硬件，如声卡、打印机。 然后点击完成，即可创建一个虚拟机。 2. 安装Linux系统(CentOs)2.1. 连接光盘右击刚创建的虚拟机，选择设置，选择下载好的CentOS映像，注意勾选启动时链接 2.2. 运行虚拟机虚拟机创建完成后，点开启此虚拟机即可。 2.3. 安装系统 安装向导 启动后会看到以下选项： Install CentOS 7 安装CentOS 7 Test this media &amp; install CentOS 7 测试安装文件并安装CentOS 7 Troubleshooting 修复故障 选择选项：Install CentOS 7，回车。 选择语言English、时间、时区，这个按自己需要选，不再赘述。 在Software selection里面选Server with GUI，然点左上角的done，就行了。 设置主机名与网卡信息 暂时选自动挂载分区（实际开发中需要仔细配置） 点击右下角开始安装，设置密码（用户可不设置），以后用Root登录 等待安装即可。 完毕后会让你点Reboot重启： 重启后，需要同意协议 点finish,到此Linux系统就安装完成了。 关于更多的配置，我找到一个很详细的文章，可以参照。]]></content>
      <categories>
        <category>学习经验</category>
      </categories>
      <tags>
        <tag>开发知识</tag>
        <tag>Linux系统</tag>
        <tag>虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lombok插件]]></title>
    <url>%2F2019%2F08%2F01%2FIdea%E5%A2%9E%E5%8A%A0Lombok%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[为IDE装上Lombok插件Lombok提供了一套注解，可以大量的简化java代码。 Lombok支持Eclipse或Idea，需要先下载zip文件：下载地址 IDEA主要介绍下插件在Idea的使用 下载插件后在IDEA界面，右下角Configure，选Plugins 进入插件界面后，点齿轮设置,选Install Plugin from Disk… 选刚刚下载插件的zip文件 点重启IDEA。 重启后在Setting里设置：勾选Enable annotation processing Lombok的文档 Introduction Installation Lombok Annotations @Getter and @Setter @NonNull @ToString @EqualsAndHashCode @Data @Cleanup @Synchronized @SneakyThrows Costs and Benefits What are we missing? Limitations Controversy Summary References 详情： Introduction“Boilerplate” is a term used to describe code that is repeated in many parts of an application with little alteration. One of the most frequently voiced criticisms of the Java language is the volume of this type of code that is found in most projects. This problem is frequently a result of design decisions in various libraries, but is exacerbated by limitations in the language itself. Project Lombok aims to reduce the prevalence of some of the worst offenders by replacing them with a simple set of annotations. While it is not uncommon for annotations to be used to indicate usage, to implement bindings or even to generate code used by frameworks, they are generally not used for the generation of code that is directly utilized by the application. This is partly because doing so would require that the annotations be eagerly processed at development time. Project Lombok does just that. By integrating into the IDE, Project Lombok is able to inject code that is immediately available to the developer. For example, simply adding the @Data annotation to a data class, as below, results in a number of new methods in the IDE: InstallationProject Lombok is available as a single jar file on the project site. It includes the APIs for development as an installer for IDE integration. On most systems, simply double-clicking the jar file will launch the installer. If the system is not configured to correctly launch jar files, it can also be run from the command line as follows: 1java -jar lombok.jar The installer will attempt to detect the location of a supported IDE. If it cannot correctly determine where the IDE is installed, the location can be specified manually. Simply click “Install/Update” and IDE integration is complete. At the time of this article’s writing, only Eclipse and NetBeans are supported. However, the release of the IntelliJ IDEA source code has placed IDEA support as a possibility for future releases, and limited success has already been reported with JDeveloper. The jar file will still need to be included in the classpath of any projects that will use Project Lombok annotations. Maven users can include Lombok as a dependency by adding this to the project pom.xml file: 12345678910111213&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;0.9.2&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;projectlombok.org&lt;/id&gt; &lt;url&gt;http://projectlombok.org/mavenrepo&lt;/url&gt; &lt;/repository&gt;&lt;/repositories&gt; Lombok AnnotationsIt is not uncommon for a typical Java project to devote hundreds of lines of code to the boilerplate required for defining simple data classes. These classes generally contain a number of fields, getters and setters for those fields, as well as equals and hashCode implementations. In the simplest scenarios, Project Lombok can reduce these classes to the required fields and a single @Data annotation. Of course, the simplest scenarios are not necessarily the ones that developers face on a day-to-day basis. For that reason, there are a number of annotations in Project Lombok to allow for more fine grained control over the structure and behavior of a class. @Getter and @SetterThe @Getter and @Setter annotations generate a getter and setter for a field, respectively. The getters generated correctly follow convention for boolean properties, resulting in an isFoo getter method name instead of getFoofor any boolean field foo. It should be noted that if the class to which the annotated field belongs contains a method of the same name as the getter or setter to be generated, regardless of parameter or return types, no corresponding method will be generated. Both the @Getter and @Setter annotations take an optional parameter to specify the access level for the generated method. Lombok annotated code: 12@Getter @Setter private boolean employed = true;@Setter(AccessLevel.PROTECTED) private String name; Equivalent Java source code: 1234567891011121314private boolean employed = true;private String name;public boolean isEmployed() &#123; return employed;&#125;public void setEmployed(final boolean employed) &#123; this.employed = employed;&#125;protected void setName(final String name) &#123; this.name = name;&#125; @NonNullThe @NonNull annotation is used to indicate the need for a fast-fail null check on the corresponding member. When placed on a field for which Lombok is generating a setter method, a null check will be generated that will result in a NullPointerException should a null value be provided. Additionally, if Lombok is generating a constructor for the owning class then the field will be added to the constructor signature and the null check will be included in the generated constructor code. This annotation mirrors @NotNull and @NonNull annotations found in IntelliJ IDEA and FindBugs, among others. Lombok is annotation agnostic with regards to these variations on the theme. If Lombok comes across any member annotated with any annotation of the name @NotNull or @NonNull, it will honor it by generating the appropriate corresponding code. The authors of Project Lombok further comment that, in the event that annotation of this type is added to Java, then the Lombok version will be subject to removal. Lombok annotated code from the class Family: 12@Getter @Setter @NonNullprivate List&lt;Person&gt; members; Equivalent Java source code: 1234567891011121314151617@NonNullprivate List&lt;Person&gt; members;public Family(@NonNull final List&lt;Person&gt; members) &#123; if (members == null) throw new java.lang.NullPointerException(&quot;members&quot;); this.members = members;&#125; @NonNullpublic List&lt;Person&gt; getMembers() &#123; return members;&#125;public void setMembers(@NonNull final List&lt;Person&gt; members) &#123; if (members == null) throw new java.lang.NullPointerException(&quot;members&quot;); this.members = members;&#125; @ToStringThis annotation generates an implementation of the toString method. By default, any non-static fields will be included in the output of the method in name-value pairs. If desired, the inclusion of the property names in the output can be suppressed by setting the annotation parameter includeFieldNames to false. Specific fields can be excluded from the output of the generated method by including their field names in the exclude parameter. Alternatively, the of parameter can be used to list only those fields which are desired in the output. The output of the toString method of a superclass can also be included by setting the callSuper parameter to true. Lombok annotated code: 123456@ToString(callSuper=true,exclude=&quot;someExcludedField&quot;)public class Foo extends Bar &#123; private boolean someBoolean = true; private String someStringField; private float someExcludedField;&#125; Equivalent Java source code: 123456789101112public class Foo extends Bar &#123; private boolean someBoolean = true; private String someStringField; private float someExcludedField; @java.lang.Override public java.lang.String toString() &#123; return &quot;Foo(super=&quot; + super.toString() + &quot;, someBoolean=&quot; + someBoolean + &quot;, someStringField=&quot; + someStringField + &quot;)&quot;; &#125;&#125; @EqualsAndHashCodeThis class level annotation will cause Lombok to generate both equals and hashCode methods, as the two are tied together intrinsically by the hashCode contract. By default, any field in the class that is not static or transient will be considered by both methods. Much like @ToString, the exclude parameter is provided to prevent field from being included in the generated logic. One can also use the of parameter to list only those fields should be considered. Also like @ToString, there is a callSuper parameter for this annotation. Setting it to true will cause equals to verify equality by calling the equals from the superclass before considering fields in the current class. For thehashCode method, it results in the incorporation of the results of the superclass’s hashCode in the calculation of the hash. When setting callSuper to true, be careful to make sure that the equals method in the parent class properly handles instance type checking. If the parent class checks that the class is of a specific type and not merely that the classes of the two objects are the same, this can result in undesired results. If the superclass is using a Lombok generated equals method, this is not an issue. However, other implementations may not handle this situation correctly. Also note that setting callSuper to true cannot be done when the class only extends Object, as it would result in an instance equality check that short-circuits the comparison of fields. This is due to the generated method calling the equals implementation on Object, which returns false if the two instances being compared are not the same instance. As a result, Lombok will generate a compile time error in this situation. Lombok annotated code: 12345678910111213@EqualsAndHashCode(callSuper=true,exclude=&#123;&quot;address&quot;,&quot;city&quot;,&quot;state&quot;,&quot;zip&quot;&#125;)public class Person extends SentientBeing &#123; enum Gender &#123; Male, Female &#125; @NonNull private String name; @NonNull private Gender gender; private String ssn; private String address; private String city; private String state; private String zip;&#125; Equivalent Java source code: 12345678910111213141516171819202122232425262728293031323334353637383940public class Person extends SentientBeing &#123; enum Gender &#123; /*public static final*/ Male /* = new Gender() */, /*public static final*/ Female /* = new Gender() */; &#125; @NonNull private String name; @NonNull private Gender gender; private String ssn; private String address; private String city; private String state; private String zip; @java.lang.Override public boolean equals(final java.lang.Object o) &#123; if (o == this) return true; if (o == null) return false; if (o.getClass() != this.getClass()) return false; if (!super.equals(o)) return false; final Person other = (Person)o; if (this.name == null ? other.name != null : !this.name.equals(other.name)) return false; if (this.gender == null ? other.gender != null : !this.gender.equals(other.gender)) return false; if (this.ssn == null ? other.ssn != null : !this.ssn.equals(other.ssn)) return false; return true; &#125; @java.lang.Override public int hashCode() &#123; final int PRIME = 31; int result = 1; result = result * PRIME + super.hashCode(); result = result * PRIME + (this.name == null ? 0 : this.name.hashCode()); result = result * PRIME + (this.gender == null ? 0 : this.gender.hashCode()); result = result * PRIME + (this.ssn == null ? 0 : this.ssn.hashCode()); return result; &#125;&#125; @DataThe @Data annotation is likely the most frequently used annotation in the Project Lombok toolset. It combines the functionality of @ToString, @EqualsAndHashCode, @Getter and @Setter. Essentially, using @Data on a class is the same as annotating the class with a default @ToString and @EqualsAndHashCode as well as annotating each field with both @Getter and @Setter. Annotation a class with @Data also triggers Lombok’s constructor generation. This adds a public constructor that takes any @NonNull or final fields as parameters. This provides everything needed for a Plain Old Java Object (POJO). While @Data is extremely useful, it does not provide the same granularity of control as the other Lombok annotations. In order to override the default method generation behaviors, annotate the class, field or method with one of the other Lombok annotations and specify the necessary parameter values to achieve the desired effect. @Data does provide a single parameter option that can be used to generate a static factory method. Setting the value of the staticConstructor parameter to the desired method name will cause Lombok to make the generated constructor private and expose a a static factory method of the given name. Lombok annotated code: 123456@Data(staticConstructor=&quot;of&quot;)public class Company &#123; private final Person founder; private String name; private List&lt;Person&gt; employees;&#125; Equivalent Java source code: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class Company &#123; private final Person founder; private String name; private List&lt;Person&gt; employees; private Company(final Person founder) &#123; this.founder = founder; &#125; public static Company of(final Person founder) &#123; return new Company(founder); &#125; public Person getFounder() &#123; return founder; &#125; public String getName() &#123; return name; &#125; public void setName(final String name) &#123; this.name = name; &#125; public List&lt;Person&gt; getEmployees() &#123; return employees; &#125; public void setEmployees(final List&lt;Person&gt; employees) &#123; this.employees = employees; &#125; @java.lang.Override public boolean equals(final java.lang.Object o) &#123; if (o == this) return true; if (o == null) return false; if (o.getClass() != this.getClass()) return false; final Company other = (Company)o; if (this.founder == null ? other.founder != null : !this.founder.equals(other.founder)) return false; if (this.name == null ? other.name != null : !this.name.equals(other.name)) return false; if (this.employees == null ? other.employees != null : !this.employees.equals(other.employees)) return false; return true; &#125; @java.lang.Override public int hashCode() &#123; final int PRIME = 31; int result = 1; result = result * PRIME + (this.founder == null ? 0 : this.founder.hashCode()); result = result * PRIME + (this.name == null ? 0 : this.name.hashCode()); result = result * PRIME + (this.employees == null ? 0 : this.employees.hashCode()); return result; &#125; @java.lang.Override public java.lang.String toString() &#123; return &quot;Company(founder=&quot; + founder + &quot;, name=&quot; + name + &quot;, employees=&quot; + employees + &quot;)&quot;; &#125;&#125; @CleanupThe @Cleanup annotation can be used to ensure that allocated resources are released. When a local variable is annotated with @Cleanup, any subsequent code is wrapped in a try/finally block that guarantees that the cleanup method is called at the end of the current scope. By default @Cleanup assumes that the cleanup method is named “close”, as with input and output streams. However, a different method name can be provided to the annotation’svalue parameter. Only cleanup methods which take no parameters are able to be used with this annotation. There is also a caveat to consider when using the @Cleanup annotation. In the event that an exception is thrown by the cleanup method, it will preempt any exception that was thrown in the method body. This can result in the actual cause of an issue being buried and should be considered when choosing to use Project Lombok’s resource management. Furthermore, with automatic resource management on the horizon in Java 7, this particular annotation is likely to be relatively short-lived. Lombok annotated code: 123456789public void testCleanUp() &#123; try &#123; @Cleanup ByteArrayOutputStream baos = new ByteArrayOutputStream(); baos.write(new byte[] &#123;&apos;Y&apos;,&apos;e&apos;,&apos;s&apos;&#125;); System.out.println(baos.toString()); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; Equivalent Java source code: 12345678910111213public void testCleanUp() &#123; try &#123; ByteArrayOutputStream baos = new ByteArrayOutputStream(); try &#123; baos.write(new byte[]&#123;&apos;Y&apos;, &apos;e&apos;, &apos;s&apos;&#125;); System.out.println(baos.toString()); &#125; finally &#123; baos.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; @SynchronizedUsing the synchronized keyword on a method can result in unfortunate effects, as any developer who has worked on multi-threaded software can attest. The synchronized keyword will lock on the current object (this) in the case of an instance method or on the class object for a static method. This means that there is the potential for code outside of the control of the developer to lock on the same object, resulting in a deadlock. It is generally advisable to instead lock explicitly on a separate object that is dedicated solely to that purpose and not exposed in such a way as to allow unsolicited locking. Project Lombok provides the @Synchronized annotation for that very purpose. Annotating an instance method with @Synchronized will prompt Lombok to generate a private locking field named $lock on which the method will lock prior to executing. Similarly, annotating a static method in the same way will generate a private static object named $LOCK for the static method to use in an identical fashion. A different locking object can be specified by providing a field name to the annotation’s value parameter. When a field name is provided, the developer must define the property as Lombok will not generate it. Lombok annotated code: 123456private DateFormat format = new SimpleDateFormat(&quot;MM-dd-YYYY&quot;);@Synchronizedpublic String synchronizedFormat(Date date) &#123; return format.format(date);&#125; Equivalent Java source code: 12345678private final java.lang.Object $lock = new java.lang.Object[0];private DateFormat format = new SimpleDateFormat(&quot;MM-dd-YYYY&quot;);public String synchronizedFormat(Date date) &#123; synchronized ($lock) &#123; return format.format(date); &#125;&#125; @SneakyThrows@SneakyThrows is probably the Project Lombok annotation with the most detractors, since it is a direct assault on checked exceptions. There is a lot of disagreement with regards to the use of checked exceptions, with a large number of developers holding that they are a failed experiment. These developers will love @SneakyThrows. Those developers on the other side of the checked/unchecked exception fence will most likely view this as hiding potential problems. Throwing IllegalAccessException would normally generate an “Unhandled exception” error if IllegalAccessException, or some parent class, is not listed in a throws clause: When annotated with @SneakyThrows, the error goes away. By default, @SneakyThrows will allow any checked exception to be thrown without declaring in the throws clause. This can be limited to a particular set of exceptions by providing an array of throwable classes ( Class&lt;? extends Throwable&gt;) to the value parameter of the annotation. Lombok annotated code: 1234@SneakyThrowspublic void testSneakyThrows() &#123; throw new IllegalAccessException();&#125; Equivalent Java source code: 1234567public void testSneakyThrows() &#123; try &#123; throw new IllegalAccessException(); &#125; catch (java.lang.Throwable $ex) &#123; throw lombok.Lombok.sneakyThrow($ex); &#125;&#125; A look at the above code and the signature of Lombok.sneakyThrow(Throwable) would lead most to believe that the exception is being wrapped in a RuntimeException and re-thrown, however this is not the case. ThesneakyThrow method will never return normally and will instead throw the provided throwable completely unaltered. Costs and BenefitsAs with any technology choice, there are both positive and negative effects of using Project Lombok. Incorporating Lombok’s annotations in a project can greatly reduce the number of lines of boilerplate code that are either generated in the IDE or written by hand. This results in reduced maintenance overhead, fewer bugs and more readable classes. That is not to say that there are not downsides to using Project Lombok annotations in your project. Project Lombok is largely aimed at filling gaps in the Java language. As such, there is the possibility that changes to the language will take place that preclude the use of Lombok’s annotations, such as the addition of first class property support. Additionally, when used in combination with annotation-based object-relational mapping (ORM) frameworks, the number of annotations on data classes can begin to get unwieldy. This is largely offset by the amount of code that is superseded by the Lombok annotations. However, those who shun the frequent use of annotations may choose to look the other way. What is missing?Project Lombok provides the delombok utility for replacing the Lombok annotations with equivalent source code. This can be done for an entire source directory via the command line. 1java -jar lombok.jar delombok src -d src-delomboked Alternatively, an Ant task is provided for incorporation into a build process. 1234567&lt;target name=&quot;delombok&quot;&gt; &lt;taskdef classname=&quot;lombok.delombok.ant.DelombokTask&quot; classpath=&quot;WebRoot/WEB-INF/lib/lombok.jar&quot; name=&quot;delombok&quot; /&gt; &lt;mkdir dir=&quot;src-delomboked&quot; /&gt; &lt;delombok verbose=&quot;true&quot; encoding=&quot;UTF-8&quot; to=&quot;src-delomboked&quot; from=&quot;src&quot; /&gt;&lt;/target&gt; Both delombok and the corresponding Ant task come packaged in the core lombok.jar download. Along with allowing Lombok annotations to be useful in applications built using Google Web Toolkit (GWT) or other incompatible frameworks, running delombok on the Person class makes it easy to contrast the class as written using the Lombok annotations against code that includes the equivalent boilerplate inline. 123456789101112131415161718192021222324package com.ociweb.jnb.lombok;import java.util.Date;import lombok.Data;import lombok.EqualsAndHashCode;import lombok.NonNull;@Data@EqualsAndHashCode(exclude=&#123;&quot;address&quot;,&quot;city&quot;,&quot;state&quot;,&quot;zip&quot;&#125;)public class Person &#123; enum Gender &#123; Male, Female &#125; @NonNull private String firstName; @NonNull private String lastName; @NonNull private final Gender gender; @NonNull private final Date dateOfBirth; private String ssn; private String address; private String city; private String state; private String zip;&#125; The code utilizing the Project Lombok annotations is significantly more concise than the equivalent class with the boilerplate included. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167package com.ociweb.jnb.lombok;import java.util.Date;import lombok.NonNull;public class Person &#123; enum Gender &#123; /*public static final*/ Male /* = new Gender() */, /*public static final*/ Female /* = new Gender() */; &#125; @NonNull private String firstName; @NonNull private String lastName; @NonNull private final Gender gender; @NonNull private final Date dateOfBirth; private String ssn; private String address; private String city; private String state; private String zip; public Person(@NonNull final String firstName, @NonNull final String lastName, @NonNull final Gender gender, @NonNull final Date dateOfBirth) &#123; if (firstName == null) throw new java.lang.NullPointerException(&quot;firstName&quot;); if (lastName == null) throw new java.lang.NullPointerException(&quot;lastName&quot;); if (gender == null) throw new java.lang.NullPointerException(&quot;gender&quot;); if (dateOfBirth == null) throw new java.lang.NullPointerException(&quot;dateOfBirth&quot;); this.firstName = firstName; this.lastName = lastName; this.gender = gender; this.dateOfBirth = dateOfBirth; &#125; @NonNull public String getFirstName() &#123; return firstName; &#125; public void setFirstName(@NonNull final String firstName) &#123; if (firstName == null) throw new java.lang.NullPointerException(&quot;firstName&quot;); this.firstName = firstName; &#125; @NonNull public String getLastName() &#123; return lastName; &#125; public void setLastName(@NonNull final String lastName) &#123; if (lastName == null) throw new java.lang.NullPointerException(&quot;lastName&quot;); this.lastName = lastName; &#125; @NonNull public Gender getGender() &#123; return gender; &#125; @NonNull public Date getDateOfBirth() &#123; return dateOfBirth; &#125; public String getSsn() &#123; return ssn; &#125; public void setSsn(final String ssn) &#123; this.ssn = ssn; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(final String address) &#123; this.address = address; &#125; public String getCity() &#123; return city; &#125; public void setCity(final String city) &#123; this.city = city; &#125; public String getState() &#123; return state; &#125; public void setState(final String state) &#123; this.state = state; &#125; public String getZip() &#123; return zip; &#125; public void setZip(final String zip) &#123; this.zip = zip; &#125; @java.lang.Override public java.lang.String toString() &#123; return &quot;Person(firstName=&quot; + firstName + &quot;, lastName=&quot; + lastName + &quot;, gender=&quot; + gender + &quot;, dateOfBirth=&quot; + dateOfBirth + &quot;, ssn=&quot; + ssn + &quot;, address=&quot; + address + &quot;, city=&quot; + city + &quot;, state=&quot; + state + &quot;, zip=&quot; + zip + &quot;)&quot;; &#125; @java.lang.Override public boolean equals(final java.lang.Object o) &#123; if (o == this) return true; if (o == null) return false; if (o.getClass() != this.getClass()) return false; final Person other = (Person)o; if (this.firstName == null ? other.firstName != null : !this.firstName.equals(other.firstName)) return false; if (this.lastName == null ? other.lastName != null : !this.lastName.equals(other.lastName)) return false; if (this.gender == null ? other.gender != null : !this.gender.equals(other.gender)) return false; if (this.dateOfBirth == null ? other.dateOfBirth != null : !this.dateOfBirth.equals(other.dateOfBirth)) return false; if (this.ssn == null ? other.ssn != null : !this.ssn.equals(other.ssn)) return false; return true; &#125; @java.lang.Override public int hashCode() &#123; final int PRIME = 31; int result = 1; result = result * PRIME + (this.firstName == null ? 0 : this.firstName.hashCode()); result = result * PRIME + (this.lastName == null ? 0 : this.lastName.hashCode()); result = result * PRIME + (this.gender == null ? 0 : this.gender.hashCode()); result = result * PRIME + (this.dateOfBirth == null ? 0 : this.dateOfBirth.hashCode()); result = result * PRIME + (this.ssn == null ? 0 : this.ssn.hashCode()); return result; &#125;&#125; Keep in mind that this is not just code that normally has to be written, but must also be read by maintaining developers. This means that, when using the annotations provided by Project Lombok, developers do not have to wade through countless lines of code in order to determine if the class in question is a simple data class or something more sinister. LimitationsWhile Project Lombok does some dramatic things to make a developer’s life easier, it has its limitations. Browsing the issues list will quickly illuminate some of the current shortcomings, most of which are minor. One important problem is the inability to detect the constructors of a superclass. This means that if a superclass has no default constructor any subclasses cannot use the @Data annotation without explicitly writing a constructor to make use of the available superclass constructor. Since Project Lombok respects any methods that match the name of a method to be generated, the majority of its feature shortcomings can be overcome using this approach. ControversyA number of issues have been raised against the use of Project Lombok. The most common argument holds that annotations were intended for “meta” information and are not to be used in such a way that would leave the codebase unable to be compiled were they removed. This is certainly the situation with Lombok annotations. New methods result from these annotations that are intended to be used not only by a framework, but by other parts of the application. Project Lombok’s development-time support is its bread and butter, but this does have consequences, not the least of which is limited IDE support. As previously stated, @SneakyThrows is bound to stir up the age-old argument over checked and unchecked exceptions. Opinions on this debate are often almost religious in their ferocity. As such, the arguments against the use of @SneakyThrows are also sure to excite fervor among the passionate. Another point of contention is the implementation of both the code supporting IDE integration as well as the javac annotation processor. Both of these pieces of Project Lombok make use of non-public APIs to accomplish their sorcery. This means that there is a risk that Project Lombok will be broken with subsequent IDE or JDK releases. Here is how one of the project founders, Reinier Zwitserloot described the situation: 12345678910111213It&apos;s a total hack. Using non-public API. Presumptuous casting (knowing that anannotation processor running in javac will get an instance of JavacAnnotationProcessor,which is the internal implementation of AnnotationProcessor (an interface), whichso happens to have a couple of extra methods that are used to get at the live AST).On eclipse, it&apos;s arguably worse (and yet more robust) - a java agent is used to injectcode into the eclipse grammar and parser class, which is of course entirely non-publicAPI and totally off limits.If you could do what lombok does with standard API, I would have done it that way, butyou can&apos;t. Still, for what its worth, I developed the eclipse plugin for eclipse v3.5running on java 1.6, and without making any changes it worked on eclipse v3.4 runningon java 1.5 as well, so it&apos;s not completely fragile. SummaryProject Lombok is a powerful tool for the pragmatic developer. It provides a set of useful annotations for eliminating a tremendous amount of boilerplate code from your Java classes. In the best cases, a mere five characters can replace hundreds of lines of code. The result is Java classes that are clean, concise and easy to maintain. These benefits do come with a cost however. Using Project Lombok in an IntelliJ IDEA shop is simply not yet a viable option. There is a risk of breakage with IDE and JDK upgrades as well as controversy surrounding the goals and implementation of the project. What all this translates to is no different than what must be considered for any technology choice. There are always gains to be made and losses to be had. The question is simply whether or not Project Lombok can provide more value than cost for the project at hand. If nothing else, Project Lombok is sure to inject some new life into the discussion of language features that have withered on the vine thus far and that is a win from any perspective. References Project Lombok -http://projectlombok.org Lombok API Documentation -http://projectlombok.org/api/index.html Project Lombok Issues List -http://code.google.com/p/projectlombok/issues/list Use Lombok via Maven -http://projectlombok.org/mavenrepo/index.html Project Lombok Google Group -http://groups.google.com/group/project-lombok Reviewing Project Lombok or the Right Way to Write a Library -http://www.cforcoding.com/2009/11/reviewing-project-lombok-or-right-way.html Morbok: Extensions for Lombok -http://code.google.com/p/morbok Using Project Lombok with JDeveloper -http://kingsfleet.blogspot.com/2009/09/project-lombok-interesting-bean.html Example Code -LombokExample.zip Thanks to Mark Volkmann, Eric Burke, Mario Aquino and Lance Finney for reviewing and providing suggestions for this article, and a special thanks to Mark Volkmann for introducing me to Project Lombok. http://jnb.ociweb.com/jnb/jnbJan2010.html]]></content>
      <categories>
        <category>学习经验</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>开发知识</tag>
        <tag>IntelliJ IDEA</tag>
        <tag>Lombok插件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Idea Maven父子工程+多模块创建]]></title>
    <url>%2F2019%2F07%2F31%2FIdea-%E7%88%B6%E5%AD%90%E5%B7%A5%E7%A8%8B-%E5%A4%9A%E6%A8%A1%E5%9D%97%E5%88%9B%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[使用IDEA创建Maven聚合工程Zero. 工作空间我新建了一个名为Idea_SSM04_WebProject的文件夹，用于存放这个项目： 1. 创建一个Maven工程新建一个Maven工程，作为项目的父工程，可不勾选骨架，用于统一版本号。 将pom依赖导入 2. 创建子工程在上一步建好的工程上右键，新建Module，注意在后续选项中把add as Module改为None： 新工程名：WebShop-Common 修改路径为：E:\Idea_SSM04_WebProject\WebShop-Common （然后再创建第二个子工程，与上步骤一样。） 第二个子工程名：WebShop-SysManager 修改路径为：E:\Idea_SSM04_WebProject\WebShop-SysManager 3. 子工程之间的依赖使用dependency来指定依赖关系 如WebShop-SysManager的pom文件中增加： 12345678910&lt;artifactId&gt;WebShop-SysManager&lt;/artifactId&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.SH&lt;/groupId&gt; &lt;artifactId&gt;WebShop-Common&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 4. 创建模块接着在子工程里创建模块，直接在子工程右键新建Module即可。 新建模块路径默认即可： SysManager-Dao SysManager-Service SysManager-Pojo SysManager-Web 其中Web模块需要勾选webapp骨架，其他模块无需勾选骨架。 5. 运行Maven项目在含有webapp的工程pom里，这里是WebShop-SysManager，增加Tomcat7插件： 12345678910111213&lt;build&gt; &lt;!-- 配置插件 --&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;port&gt;8080&lt;/port&gt; &lt;path&gt;/&lt;/path&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 在右侧点击Maven，可查看当前项目的Maven详情： 在Add Configuration中点击加号，选Maven： 配置如下，名字随便起： 运行前，需要先把被依赖的工程install，接着install其他工程，install前请clean。webapp模块不需要安装，每次运行前最好都这样重复清理安装:]]></content>
      <categories>
        <category>学习经验</category>
      </categories>
      <tags>
        <tag>开发知识</tag>
        <tag>IntelliJ IDEA</tag>
        <tag>Maven聚合工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[改回来用Gitment评论系统]]></title>
    <url>%2F2019%2F07%2F29%2F%E6%94%B9%E5%9B%9E%E6%9D%A5%E7%94%A8Gitment%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[先前使用Gitment评论系统，由于作者证书失效，跨域服务不可用，改用了一段时间的Valine。Valine不需要登录，昵称和邮箱都是自定义的，身份只能靠浏览器、ip来识别。评论起来方便是方便，不过可读性不高，头像也比较单一。 相比起来，Gitment是使用Github账户登录的，身份唯一，在github互动也方便，可读性强。 今天偶然看到一篇文章，写得很详细，加上同样都是next主题（我比较懒，没怎么搞主题）可以傻瓜式操作，直接cv大法把js链接copy来了，感谢。 修改内容： 关闭valine,开启gitment,修改mint为false 路径 D:\HexoBlog\ShirtinyBlog\themes\next\_config.yml 123456789101112131415# Gitment# Introduction: https://github.com/imsun/gitmentgitment: enable: true mint: false # RECOMMEND, A mint on Gitment, to support count, language and proxy_gateway count: true # Show comments count in post meta area lazy: false # Comments lazy loading with a button cleanly: true # Hide 'Powered by ...' on footer, and more language: # Force language, or auto switch by theme github_user: Shirtiny # MUST HAVE, Your Github Username github_repo: Shirtiny.github.io # MUST HAVE, The name of the repo you use to store Gitment comments client_id: &#123;id（保密）&#125; # MUST HAVE, Github client id for the Gitment client_secret: &#123;密钥（保密）&#125; # EITHER this or proxy_gateway, Github access secret token for the Gitment proxy_gateway: # Address of api proxy, See: https://github.com/aimingoo/intersect redirect_protocol: # Protocol of redirect_uri with force_redirect_protocol when mint enabled 修改引入的CSS、Js的url 路径 D:\HexoBlog\ShirtinyBlog\themes\next\layout\_third-party\comments\gitment.swing 1234567891011121314151617&lt;!-- LOCAL: You can save these files to your site and update links --&gt;&#123;% if theme.gitment.mint %&#125; &#123;% set CommentsClass = 'Gitmint' %&#125; &lt;link rel="stylesheet" href="https://aimingoo.github.io/gitmint/style/default.css"&gt; &lt;script src="https://aimingoo.github.io/gitmint/dist/gitmint.browser.js"&gt;&lt;/script&gt;&#123;% else %&#125; &#123;% set CommentsClass = 'Gitment' %&#125; &lt;!--修改前 &lt;link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"&gt; --&gt; &lt;!-- &lt;script src="https://imsun.github.io/gitment/dist/gitment.browser.js"&gt;&lt;/script&gt; --&gt;&lt;!--改后 --&gt; &lt;link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/theme-next/theme-next-gitment@1/default.css"&gt; &lt;script src="https://cdn.jsdelivr.net/gh/theme-next/theme-next-gitment@1/gitment.browser.js"&gt;&lt;/script&gt; &#123;% endif %&#125;&lt;link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/theme-next/theme-next-gitment@1/default.css"/&gt;&lt;!-- END LOCAL --&gt; 也可使用： 12&lt;link rel="stylesheet" href="https://jjeejj.github.io/css/gitment.css"&gt;&lt;script src="https://jjeejj.github.io/js/gitment.js"&gt;&lt;/script&gt; 或 12&lt;link rel="stylesheet" href="https://jjeejj.github.io/css/gitment.css"&gt;&lt;script src="https://www.wenjunjiang.win/js/gitment.js"&gt;&lt;/script&gt; 我的Giment样式、js（最终修改） 12&lt;link rel="stylesheet" href="https://shirtiny.cn/css/myGitment.css"&gt;&lt;script src="https://shirtiny.cn/js/myGitment.js"&gt;&lt;/script&gt;]]></content>
      <categories>
        <category>系统维护</category>
      </categories>
      <tags>
        <tag>博客维护</tag>
        <tag>评论系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSM_SysManager_Security]]></title>
    <url>%2F2019%2F07%2F15%2FSSM-Security%2F</url>
    <content type="text"><![CDATA[SSM_后台数据管理+安全认证数据列表1. 商品表Product 变量名 类型 备注 id String 主键 productNum String 商品编号 productName String 商品名 cityName String 出发城市 departureTime Date 出发时间 departureTimeStr String 出发时间的字符串，不在数据库中 productPrice double 商品价格 productDesc String 商品描述 productStatus Integer 值0为关闭状态，值1为打开状态 productStatusStr String 商品状态的字符串，不在数据库中 1.1. Date与String之间的类型转换 赋值 Controller接收参数时，需要把用户输入的String类型的departureTime转为date类型，这里我设置了全局的类型转换器，由springMVC处理转换： 12345678910111213public class StringToDate implements Converter&lt;String, Date&gt; &#123; @Override public Date convert(String string) &#123; SimpleDateFormat sdf=new SimpleDateFormat("yyyy-MM-dd HH:mm"); Date date = null; try &#123; date = sdf.parse(string); &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; return date; &#125;&#125; springMVC配置： 12345678910111213141516171819&lt;!-- 配置类型转换器de固定步骤--&gt; &lt;!-- 01、 先将写好的转换器类放入IOC容器--&gt; &lt;bean id="SToDateConvertor" class="com.SH.Converters.StringToDate"&gt;&lt;/bean&gt; &lt;bean id="DToStringConvertor" class="com.SH.Converters.DateToString"&gt;&lt;/bean&gt; &lt;!-- 02、 再将自定义的转换器设置到springMVC中的转换器里 --&gt; &lt;!-- &lt;bean id="springConvertors" class="org.springframework.context.support.ConversionServiceFactoryBean"&gt;这是转换器的类--&gt; &lt;!-- 由于数据格式化的类是.format.support.FormattingConversionServiceFactoryBean包括了转换器的类，所以可以用格式化的类同时实现两个功能--&gt; &lt;bean id="springConvertors" class="org.springframework.format.support.FormattingConversionServiceFactoryBean"&gt; &lt;property name="converters" &gt; &lt;set&gt; &lt;ref bean="SToDateConvertor"/&gt; &lt;ref bean="xxx"/&gt; ... &lt;/set&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 03、 在&lt;mvc:annotation-driven&gt;里的conversion-service注册 02的bean --&gt; &lt;!-- 开启SpringMVC注解支持 --&gt; &lt;mvc:annotation-driven conversion-service="springConvertors"/&gt; 取值 输出时，可以使用事先定义的departureTimeStr，这样可以保持departureTime不变，需要对departureTimeStr赋值，在get方法中写： 1234567public String getDepartureTimeStr() &#123; if (departureTime!=null)&#123; String pattern="yyyy-MM-dd HH:mm"; departureTimeStr = DateAndString.DateToString(departureTime, pattern); &#125; return departureTimeStr; &#125; DateAndString是自定义的工具类，将date转为string，详情： 1234567public class DateAndString &#123; public static String DateToString(Date date,String pattern)&#123; SimpleDateFormat sdf=new SimpleDateFormat(pattern); return sdf.format(date); &#125;&#125; 注解方式 详情：@DateTimeFormat与@JsonFormat 2. 订单表Orders 变量名 类型 备注 id String 无意义，主键id orderNum String 订单编号 不为空 且唯一 orderTime Date 下单时间 orderTimeStr String 用于输出下单时间，不在数据库中 peopleCount int 出行人数 orderDesc String 订单备注和描述信息 payType int 支付方式（0支付宝，1微信，2其他） payTypeStr String 用于输出支付方式，不在数据库中 orderStatus int 订单的状态（0未支付 1已支付） orderStatusStr; String 用于输出下单状态，不在数据库中 productId int 产品的id，外键 memberid int 会员（联系人）id外键 travellers List 旅客 member Member 会员 2.1. 订单查询一个订单对应一个产品、一个会员（联系人）、多个旅客，使用注解方式查询数据时，使用@Results指定关系，一对一多对一使用@One指定方法，一对多多对多使用@Many指定方法 123456789101112131415//查询一个订单的具体信息@Select("select * from orders where id=#&#123;orderId&#125;") @Results(&#123; @Result(column = "id",property = "id",id = true), @Result(column = "orderNum",property = "orderNum"), @Result(property = "orderTime",column = "orderTime",javaType = Date.class,jdbcType =JdbcType.TIMESTAMP), @Result(property = "orderStatus",column = "orderStatus"), @Result(property = "peopleCount",column = "peopleCount"), @Result(property = "product",column = "productId",javaType = Product.class,one = @One(select = "com.SH.Dao.IproductDao.selectByid")), @Result(property = "travellers",column = "id",javaType = List.class,many = @Many(select = "com.SH.Dao.ItravellerDao.selectByid")), @Result(property = "member",column = "memberId",javaType = Member.class,one = @One(select = "com.SH.Dao.ImemberDao.selectById")), @Result(property = "payType",column = "payType"), @Result(property = "orderDesc",column = "orderDesc") &#125;) Orders selectById(String orderId) throws Exception; 3. 会员表Member 变量名 类型 备注 id String 无意义、主键id name String 姓名 nickName String 昵称 phoneNum String 电话号码 email String 邮箱 3.1. 单个会员查询：12@Select("select * from member where id=#&#123;id&#125;") Member selectById(String id); 4. 旅客表Traveller 变量名 类型 备注 id String 无意义、主键id name String 姓名 sex String 性别 phoneNum String 电话号码 credentialsType int 证件类型 0身份证 1护照 2军官证 credentialsTypeStr String 用于输出证件类型，不在数据库中 credentialsNum String 证件号码 travellerType int 旅客类型(人群) 0 成人 1 儿童 travellerTypeStr String 用于输出旅客类型，不在数据库中 5. 旅客与订单之间的多对多关系，order_traveller中间表 字段名 字段类型 字段描述 orderId varchar(32) 订单id，与对应表绑定外键 travellerId varchar(32) 旅客id，与对应表绑定外键 5.1. 根据指定订单号，多个旅客的查询：1234@Select("select * from traveller where id in( select travellerId from order_traveller where orderId=#&#123;orderId&#125; )") List&lt;Traveller&gt; selectByid(String orderId); 6. 用户表Users 变量名 类型 备注 id String 无意义，主键id email String 非空，唯一 username String 用户名 password String 密码（加密) phoneNum String 电话 status int 状态0 未开启 1 开启 roles List 角色集 6.1. 用户的查询：123456789101112//查询所有用户 @Select("select * from users") @Results(&#123; @Result(id = true,property = "id",column = "id"), @Result(property = "email",column = "email"), @Result(property = "username",column = "username"), @Result(property = "password",column = "password"), @Result(property = "phoneNum",column = "phoneNum"), @Result(property = "status",column = "status"), @Result(property = "roles",column = "id",javaType = List.class,many = @Many(select = "com.SH.Dao.IroleDao.selectByUserid")) &#125;) List&lt;UserInfo&gt; selectAllUser() throws Exception; 7. 角色表Role 变量名 类型 备注 id String 无意义，主键id roleName String 角色名 roleDesc String 角色描述 UserInfos List 用户集 permissions List 权限集 8. 用户与角色的多对多关系，user_role中间表 变量名 类型 备注 userId String 用户id,与用户id外键关联 roleId String 角色id，与角色id外键关联 8.1. 根据用户查询角色集合：123//根据用户id查询角色集 @Select("select * from role where id in(select roleId from user_role where userId=#&#123;userid&#125;)") List&lt;Role&gt; selectByUserid(String userid); 9. 权限表Permission 变量名 类型 备注 id String 无意义，主键id permissionName String 权限名 url String 资源路径 roles List 角色集 10. 角色与权限多对多关系，role_permission中间表 变量名 类型 备注 permissionId String 权限id，与权限id关联外键 roleId String 角色id，与角色id关联外键 Spring Security安全框架Spring Security是一种基于 Spring AOP 和 Servlet 过滤器的安全框架,它提供全面的安全性解决方案，同时在 Web 请求级和方法调用级处理认证和授权。 1.Pom依赖12345678910111213141516171819202122232425&lt;properties&gt; &lt;spring.security.version&gt;5.0.1.RELEASE&lt;/spring.security.version&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.security.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-config&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.security.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-core&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.security.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-taglibs&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.security.version&#125;&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 2. spring-Security.xml配置文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:security="http://www.springframework.org/schema/security" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/security http://www.springframework.org/schema/security/spring-security.xsd"&gt;&lt;!-- 不拦截的资源--&gt; &lt;security:http pattern="/css/**" security="none"/&gt; &lt;security:http pattern="/img/**" security="none"/&gt; &lt;security:http pattern="/plugins/**" security="none"/&gt; &lt;security:http pattern="/page/login.jsp" security="none"/&gt; &lt;security:http pattern="/page/fail.jsp" security="none"/&gt; &lt;!-- 配置具体的规则 auto-config="true" 不用自己编写登录的页面，框架提供默认登录页面 use-expressions="false" 是否使用SPEL表达式 --&gt; &lt;security:http auto-config="true" use-expressions="false"&gt; &lt;!-- 配置具体的拦截的规则, 限制用户添加页面的访问角色 ，小范围在前，大范围在后 --&gt; &lt;security:intercept-url pattern="/page/user-add.jsp" access="ROLE_GM"/&gt; &lt;!-- pattern="请求路径的规则" access="访问系统的人，必须有USER或GM的角色，ROLE_ 是框架需要的前缀" --&gt; &lt;security:intercept-url pattern="/**" access="ROLE_USER,ROLE_GM"/&gt; &lt;!-- 设置跳转的页面 --&gt; &lt;security:form-login login-page="/page/login.jsp" login-processing-url="/login.action" default-target-url="/page/main.jsp" authentication-failure-url="/page/fail.jsp" authentication-success-forward-url="/page/main.jsp" username-parameter="username" password-parameter="password" /&gt; &lt;!-- 关闭跨域请求，csrf主要是为了防止攻击 --&gt; &lt;security:csrf disabled="true"/&gt; &lt;!-- 用户注销，退出 --&gt; &lt;security:logout invalidate-session="true" logout-url="/logout.action" logout-success-url="/page/login.jsp" /&gt; &lt;/security:http&gt; &lt;!-- 切换成数据库中的用户名和密码 --&gt; &lt;security:authentication-manager&gt; &lt;!--配置userService类，它实现了继承了UserDetailsService的IuserService接口，重写了loadUserByUsername(String username)方法，返回一个UserDetails类对象，使用security提供的User对象封装数据库查询到的userinfo信息 --&gt; &lt;security:authentication-provider user-service-ref="userService"&gt; &lt;!-- 配置加密的方式，引用上面配置的加密类，指定密码被加密的方式，框架才能识别，以便找到合适的密码验证方式，不然会报There is no PasswordEncoder mapped for the id "null", 注意！若在xml中配置了加密类，&#123;id&#125;(密码前加&#123;noop&#125;、&#123;bcrypt&#125;等)将不可用，框架会直接使用指定加密类匹配字符串，不会再判断字符串加密类型 --&gt;&lt;!-- &lt;security:password-encoder ref="passwordEncoder"/&gt;--&gt; &lt;/security:authentication-provider&gt;&lt;/security:authentication-manager&gt; &lt;!-- 配置加密类，存储密码明文的加盐哈希 hash(m+salt)，不可逆加密，验证时匹配哈希值,注意，此项放在 &lt;security:authentication-manager&gt;前会在密码验证时影响&#123;id&#125;是否使用--&gt; &lt;bean id="passwordEncoder" class="org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder"/&gt; &lt;!-- 提供了入门的方式，在内存中存入用户名和密码 --&gt;&lt;!-- &lt;security:authentication-manager&gt;--&gt;&lt;!-- &lt;security:authentication-provider&gt;--&gt;&lt;!-- &lt;security:user-service&gt;--&gt;&lt;!-- &lt;security:user name="sh" password="&#123;noop&#125;123" authorities="ROLE_USER"/&gt;--&gt;&lt;!-- &lt;/security:user-service&gt;--&gt;&lt;!-- &lt;/security:authentication-provider&gt;--&gt;&lt;!-- &lt;/security:authentication-manager&gt;--&gt;&lt;/beans&gt; 3. Web.xml配置文件1234567891011121314151617181920212223&lt;!--监听器 --&gt;&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt;&lt;!--指定spring配置文件与security配置文件的位置 --&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:ApplicationContext.xml,classpath:spring- Security.xml&lt;/param-value&gt; &lt;/context-param&gt;&lt;!-- 过滤器,filter-name值必须为springSecurityFilterChain--&gt; &lt;filter&gt; &lt;filter-name&gt;springSecurityFilterChain&lt;/filter-name&gt; &lt;filter-class&gt; org.springframework.web.filter.DelegatingFilterProxy &lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;springSecurityFilterChain&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 4. 密码加密流程由于用户注册时，数据库中的用户密码需要加密保存，以保护用户信息安全。Spring Security提供的加密方式里，有一种为BCryptPasswordEncoder类，使用BCrypt强哈希方法来加密密码。这是种加盐哈希方式，每次加密产生的密文都不同，密码验证时通过匹配hash值来进行认证，可以抵御彩虹表，提高破解难度。 使用时，只需在接收用户信息后，调用BCryptPasswordEncoder对象的encode方法，对用户密码进行加密，然后将加密后的用户信息放入数据库即可,由于加密后数据比较长，注意数据库字符长度。如： 12345678910111213141516171819202122232425262728@Service("userService")@Transactionalpublic class userServiceImpl implements IuserService &#123; @Autowired private IuserDao userDao; @Autowired private BCryptPasswordEncoder passwordEncoder; @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123;...&#125;//添加用户，加密测试 @Override public void addUser(UserInfo userInfo) throws Exception &#123; //获取用户密码 String password=userInfo.getPassword(); //加密密码 String encode = passwordEncoder.encode(password); //修改用户密码 userInfo.setPassword(encode); //打印，以查看加密结果 System.out.println(encode); //插入数据库 userDao.insertOne(userInfo); &#125; 5. 登录认证流程5.1. 创建UserInfo类，用来封装数据库返回的用户信息1234567891011121314public class UserInfo &#123; private String id; private String email; private String username; private String password; private String phoneNum; private int status; private String statusStr; private List&lt;Role&gt; roles; .... //省略setter、getter、构造器 &#125; 5.2. Dao层查询出用户信息123456789101112//按照用户名查找单个用户，验证登录 @Select("select * from users where username=#&#123;username&#125;") @Results(&#123; @Result(id = true,property = "id",column = "id"), @Result(property = "email",column = "email"), @Result(property = "username",column = "username"), @Result(property = "password",column = "password"), @Result(property = "phoneNum",column = "phoneNum"), @Result(property = "status",column = "status"), @Result(property = "roles",column = "id",javaType = List.class,many = @Many(select = "com.SH.Dao.IroleDao.selectByUserid")) &#125;) UserInfo selectUserByName(String username); 5.3. 创建IuserService接口，继承UserDetailsService接口123public interface IuserService extends UserDetailsService &#123;&#125; 5.4. 创建userServiceImpl类，实现IuserService接口12345678910111213141516171819202122232425262728293031323334353637383940//放入IOC容器，取名为userService，供xml中配置@Service("userService")//事务管理@Transactionalpublic class userServiceImpl implements IuserService &#123; @Autowired private IuserDao userDao; //重写loadUserByUsername方法 @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123; //查询出对应用户信息 UserInfo userInfo = userDao.selectUserByName(username); //获取用户的角色集合 List&lt;Role&gt; roles = userInfo.getRoles(); //遍历权限并放入SimpleGrantedAuthority集合 SimpleGrantedAuthority authority; List&lt;SimpleGrantedAuthority&gt; authorities = new ArrayList&lt;&gt;(); for (Role role : roles) &#123; String roleName = role.getRoleName(); authority = new SimpleGrantedAuthority("ROLE_" + roleName); authorities.add(authority); &#125; //获取用户密码 String uPwd = userInfo.getPassword(); //使用Security提供的User类，至少需要用户名、密码、权限 User user; if (uPwd.length() &lt;= 50) &#123;//判断密码长度，以区分是否是加密的密码，因为加密后的密码比较长 //此时密码未进行加密，所以要加"&#123;noop&#125;"前缀，让框架识别 user = new User(userInfo.getUsername(), "&#123;noop&#125;" + uPwd, authorities); &#125; else &#123; //此时密码已经加密(正常情况下密码用户的密码应该不会大于50吧)，加"&#123;bcrypt&#125;"前缀，因为加密方式为bcrypt，让框架识别 user = new User(userInfo.getUsername(), "&#123;bcrypt&#125;" + uPwd, authorities); //若在xml中配置了加密方式，&#123;id&#125;就会失效，只使用配置的加密方式匹配密码，加密类的bean也不能靠前 &#125; //直接返回User类对象，因为User类实现了UserDetails return user; &#125; tips： 5.4.1. 关于”{noop}”前缀在spring5.0之后，springsecurity存储密码的格式发生了改变，新的密码存储格式为：加密方式和加密后的密码，{id}encodedPassword 1234567891011//均为字符串&#123;noop&#125;password//无加密，明文密码，前缀使用&#123;noop&#125;让框架识别，noop是no operate的意思 //各种加密方式的前缀，和对应的密文样式&#123;bcrypt&#125;$2a$10$dXJ3SW6G7P50lGmMkkmwe.20cQQubK3.HZWzG3YB1tlRy.fqvM/BG //BCryptPasswordEncoder类加密&#123;pbkdf2&#125;5d923b44a6d129f3ddf3e3c8d29412723dcbde72445e8ef6bf3b508fbf17fa4ed4d6b99ca763d8dc &#123;scrypt&#125;$e0801$8bWJaSu2IKSn9Z9kM+TPXfOc/9bdYSrN1oD9qfVThWEwdRTnO7re7Ei+fUZRJ68k9lTyuTeUp4of4g24hHnazw==$OAOec05+bXxvuu/1qZ6NUR+xQYvYv7BeL1QxwRpY5Pc= &#123;sha256&#125;97cde38028ad898ebc02e690819fa220e88c62e0699403e94fff291cfffaf8410849f27605abcbc0 5.4.2. 关于框架提供的User类Security的User类，提供了两个构造方法： 12345678910111213141516171819202122232425262728//Security提供的User类public class User implements UserDetails, CredentialsContainer &#123; private static final long serialVersionUID = 500L; private String password; private final String username; private final Set&lt;GrantedAuthority&gt; authorities; private final boolean accountNonExpired; private final boolean accountNonLocked; private final boolean credentialsNonExpired; private final boolean enabled; public User(String username, String password, Collection&lt;? extends GrantedAuthority&gt; authorities) &#123; this(username, password, true, true, true, true, authorities); &#125; public User(String username, String password, boolean enabled, boolean accountNonExpired, boolean credentialsNonExpired, boolean accountNonLocked, Collection&lt;? extends GrantedAuthority&gt; authorities) &#123; if (username != null &amp;&amp; !"".equals(username) &amp;&amp; password != null) &#123; this.username = username; this.password = password; this.enabled = enabled; this.accountNonExpired = accountNonExpired; this.credentialsNonExpired = credentialsNonExpired; this.accountNonLocked = accountNonLocked; this.authorities = Collections.unmodifiableSet(sortAuthorities(authorities)); &#125; else &#123; throw new IllegalArgumentException("Cannot pass null or empty values to constructor"); &#125; &#125; 三参构造（用户名，密码，权限集合 ），如： 1user = new User(userInfo.getUsername(), "&#123;bcrypt&#125;" + uPwd, authorities); 七參构造（用户名，密码，是否启用，账号是否过期，认证信息是否过期，是否被锁定，权限集合），如： 12User user = new User(userInfo.getUsername(), "&#123;bcrypt&#125;" + userInfo.getPassword(),userInfo.getStatus() == 0 ? false : true, true, true, true, authoritys); 5.5. 在Security的xml文件配置userService即可1234567 &lt;security:authentication-manager&gt; &lt;!--配置userService类，它实现了继承了UserDetailsService的IuserService接口，重写了loadUserByUsername(String username)方法，返回一个UserDetails类对象，使用security提供的User对象封装数据库查询到的userinfo信息 --&gt; &lt;security:authentication-provider user-service-ref="userService"&gt; &lt;/security:authentication-provider&gt;&lt;/security:authentication-manager&gt; 6. 注解方式的权限控制注解都默认关闭,使用前均需开启，在Spring-Security.xml中配置: 123&lt;!-- 启用注解,用于进行权限控制--&gt;&lt;!-- 开启JSR250注解、secured注解,支持spel表达式的注解--&gt;&lt;security:global-method-security jsr250-annotations="enabled" secured-annotations="enabled" pre-post-annotations="enabled"/&gt; 6.1. JSR250注解依赖、jar包: 12345&lt;dependency&gt; &lt;groupId&gt;javax.annotation&lt;/groupId&gt; &lt;artifactId&gt;jsr250-api&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt;&lt;/dependency&gt; @RolesAllowed注解，指定类、或方法需要的角色，无需加ROLE_前缀，使用： 1234567891011121314151617181920212223242526272829303132@Controller@RequestMapping(value = "/userController")//指定类内方法都默认需要GM的身份@RolesAllowed("GM")public class userController &#123; @Autowired private IuserService userService; //添加用户@RequestMapping(value = "/addUser") public String addUser(UserInfo userInfo) throws Exception &#123; userService.addUser(userInfo); return "redirect:/userController/findAll.action"; &#125; //查询所有用户 @RequestMapping(value = "/findAll") //指定此方法GM和USER都可以访问 @RolesAllowed(&#123;"GM","USER"&#125;) public ModelAndView findAllUser() throws Exception &#123; List&lt;UserInfo&gt; users = userService.selectAllUser(); ModelAndView mv=new ModelAndView(); mv.addObject("userList",users); mv.setViewName("user-list"); return mv; &#125;&#125; @PermitAll注解，表示允许所有的角色进行访问，也就是说不进行权限控制 @DenyAll注解，是和PermitAll相反的，表示无论什么角色都不能访问 6.2. @Secured注解此注解为Spring Security自带注解,用法与@RolesAllowed大致相同，不过角色要加ROLE_前缀,如: 123456789101112131415161718192021222324252627282930@Controller@RequestMapping(value = "/userController")//指定类内方法都默认需要GM的身份@Secured("ROLE_GM")public class userController &#123; @Autowired private IuserService userService; //添加用户@RequestMapping(value = "/addUser") public String addUser(UserInfo userInfo) throws Exception &#123; userService.addUser(userInfo); return "redirect:/userController/findAll.action"; &#125; //查询所有用户 @RequestMapping(value = "/findAll") //指定此方法GM和USER都可以访问 @Secured(&#123;"ROLE_USER","ROLE_GM"&#125;) public ModelAndView findAllUser() throws Exception &#123; List&lt;UserInfo&gt; users = userService.selectAllUser(); ModelAndView mv=new ModelAndView(); mv.addObject("userList",users); mv.setViewName("user-list"); return mv; &#125;&#125; 6.3. 支持SPEL表达式的注解常用的权限表达式： 表达式 说明 permitAll 永远返回true denyAll 永远返回false anonymous 当前用户是anonymous时返回true rememberMe 当前用户是rememberMe用户时返回true authenticated 当前用户不是anonymous时返回true fullAuthenticated 当前用户既不是anonymous也不是rememberMe用户时返回true hasRole（role） 用户拥有指定的角色权限时返回true hasAnyRole（[role1，role2]） 用户拥有任意一个指定的角色权限时返回true hasAuthority（authority） 用户拥有指定的权限时返回true hasAnyAuthority（[authority1,authority2]） 用户拥有任意一个指定的权限时返回true hasIpAddress（’192.168.1.0’） 请求发送的Ip匹配时返回true @PreAuthorize注解， 在方法调用之前,基于表达式的计算结果来限制对方法的访问如： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950@Controller@RequestMapping(value = "/userController")/*指定类内方法都默认需要GM的身份* @PreAuthorize("hasRole('ROLE_GM')") * 或 * @PreAuthorize("hasAuthority('ROLE_GM')") */public class userController &#123; @Autowired private IuserService userService; //添加用户@RequestMapping(value = "/addUser") public String addUser(UserInfo userInfo) throws Exception &#123; userService.addUser(userInfo); return "redirect:/userController/findAll.action"; &#125; //查询所有用户 @RequestMapping(value = "/findAll")/* * 指定此方法GM和USER都可以访问* @PreAuthorize("hasAnyRole('ROLE_GM','ROLE_USER')")* 或 * @PreAuthorize("hasAnyAuthority('ROLE_GM','ROLE_USER')")**/ public ModelAndView findAllUser() throws Exception &#123; List&lt;UserInfo&gt; users = userService.selectAllUser(); ModelAndView mv=new ModelAndView(); mv.addObject("userList",users); mv.setViewName("user-list"); return mv; &#125; //修改密码（测试） @RequestMapping(value = "/changeP") //取方法形参中的username，如果传入参数的值与登录用户的值相同，或者拥有GM权限，便可访问 @PreAuthorize("#username == authentication.principal.username or hasAuthority('ROLE_GM')") public String changeP(@P("username") String username) throws Exception&#123; return "ok"; &#125;&#125; @PostAuthorize 注解，允许方法调用,但是如果表达式计算结果为false,将抛出一个安全性异常示例： 123@PostAuthorizeUser getUser("returnObject.userId == authentication.principal.userId orhasPermission(returnObject, 'ADMIN')"); @PostFilter 注解，允许方法调用,但必须按照表达式来过滤方法的结果@PreFilter 注解，允许方法调用,但必须在进入方法之前过滤输入值 7. 权限控制标签依赖、jar（已有）： 1234567891011&lt;properties&gt; &lt;spring.security.version&gt;5.0.1.RELEASE&lt;/spring.security.version&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-taglibs&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.security.version&#125;&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; jsp页面引入taglib: 1&lt;%@taglib prefix="security" uri="http://www.springframework.org/security/tags" %&gt; 常用标签: authentication 允许访问当前的Authentication对象，获得属性的值，用来取值和获取对象。 1&lt;security:authentication property="" htmlEscape="" scope="" var=""/&gt; property： 只允许指定Authentication所拥有的属性，可以进行属性的级联获取 如“principle.username”，不允许直接通过方法进行调用 htmlEscape：表示是否需要将html进行转义。默认为true。 scope：与var属性一起使用，用于指定存放获取的结果的属性名的作用范围，默认我pageContext。Jsp中拥有的作用范围都进行进行指定 var： 用于指定一个属性名，这样当获取到了authentication的相关信息后会将其以var指定的属性名进行存放，默认是存放在pageConext中 实例： 1234567891011121314151617&lt;%@ page contentType="text/html;charset=UTF-8" language="java" isELIgnored="false" %&gt;&lt;%@ taglib prefix="security" uri="http://www.springframework.org/security/tags" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;用户属性&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;%--将用户对象在session中命名为user--%&gt;&lt;security:authentication property="principal" var="user" scope="session"/&gt; &lt;p&gt;$&#123;user&#125;&lt;/p&gt; &lt;p&gt;$&#123;user.username&#125;&lt;/p&gt; &lt;%--或直接输出值--%&gt;&lt;security:authentication property="principal.username"/&gt;&lt;/body&gt;&lt;/html&gt; 当然，你可以在你的MVC控制器中访问Authentication对象 （通过调用SecurityContextHolder.getContext().getAuthentication()） 然后直接在模型中添加数据，来渲染视图: 1234// Authentication authentication = SecurityContextHolder.getContext().getAuthentication();//User principal = (User)authentication.getPrincipal();//principal.getUsername(); authorize authorize是用来判断普通权限的，通过判断用户是否具有对应的权限而控制其所包含内容的显示。 1&lt;security:authorize access="" method="" url="" var=""&gt;&lt;/security:authorize&gt; access： 需要使用表达式来判断权限，当表达式的返回结果为true时表示拥有对应的权限 method：是配合url属性一起使用的，表示用户应当具有指定url指定method访问的权限，method的默认值为GET，可选值为http请求的7种方法 url：表示如果用户拥有访问指定url的权限即表示可以显示authorize标签包含的内容 var：用于指定将权限鉴定的结果存放在pageContext的哪个属性中 accesscontrollist accesscontrollist标签是用于鉴定ACL权限的。其一共定义了三个属性：hasPermission、domainObject和var，其中前两个是必须指定的。 1&lt;security:accesscontrollist hasPermission="" domainObject="" var=""&gt;&lt;/security:accesscontrollist&gt; hasPermission：用于指定以逗号分隔的权限列表 domainObject：用于指定对应的域对象 var：则是用以将鉴定的结果以指定的属性名存入pageContext中，以供同一页面的其它地方使用 操作日志记录每个用户的操作详情，方便管理和监控。这里使用Spring AOP的前置通知、后置通知，来控制日志的生成。 1. 日志表sysLog1.1. 数据库表 字段名称 字段类型 字段描述 id VARCHAR 无意义，完成时间的字符串 visitTime timestamp 访问时间 username VARCHAR 操作者用户名 ip VARCHAR 访问ip url VARCHAR 访问资源url executionTime int 执行时长 method VARCHAR 访问方法 1.1.1. 插入日志12@Insert("insert into syslog(id,visitTime,username,ip,url,executionTime,method) values(#&#123;id&#125;,#&#123;visitTime&#125;,#&#123;username&#125;,#&#123;ip&#125;,#&#123;url&#125;,#&#123;executionTime&#125;,#&#123;method&#125;)") boolean insertOne(SysLog sysLog); 1.1.2. 查询日志12345678910111213@Select("select * from syslog") @Results(&#123; @Result(id = true,property = "id",column = "id"), @Result(property = "visitTime",column = "visitTime",javaType = Date.class,jdbcType = JdbcType.TIMESTAMP), @Result(property = "username",column = "username"), @Result(property = "ip",column = "ip"), @Result(property = "url",column = "url"), @Result(property = "executionTime",column = "executionTime",javaType = long.class,jdbcType = JdbcType.INTEGER), @Result(property = "method",column = "method") &#125;) List&lt;SysLog&gt; selectAll() throws Exception; 1.2. 实体类123456789101112public class SysLog &#123;private String id;private Date visitTime;private String visitTimeStr;private String username;private String ip;private String url;private Long executionTime;private String method; //setter&amp;getter｝ 1.3. AOP生成数据开启spring-MVC对AOP的注解支持 123456&lt;!-- 支持AOP的注解支持，AOP底层使用代理技术 JDK动态代理，要求必须有接口 cglib代理，生成子类对象，proxy-target-class="true" 默认使用cglib的方式--&gt;&lt;aop:aspectj-autoproxy proxy-target-class="true"/&gt; 创建sysLogAOP类，使用aop的前置通知、后置通知，生成需要的数据，详细如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148package com.SH.AOP;import ...@Component@Aspectpublic class sysLogAOP &#123; @Autowired private HttpServletRequest request; @Autowired private IsysLogService sysLogService; private Class aClass; private Method method; private Date visitTime; private String visitTimeStr=""; private String ip=""; private String url=""; private String username=""; /* * 前置通知 * 生成访问方法时的时间 *获取操作者的信息 *获取ip *获取访问方法的类、类名、方法、方法名 *利用方法、类获取requestMapping的valueof[0]，拼接成url * 单个方法作为切入点 * @Before("execution(public String com.SH.Controller.productController.findAll(java.util.Map&lt;java.lang.String,java.lang.Object&gt;))") * */// 全部类型的 com.SH.Controller包下 全部类的全部方法 @Before("execution(* com.SH.Controller.*.*(..))")//前置通知 public void BeforeAd(JoinPoint joinPoint) throws NoSuchMethodException,SecurityException &#123;//异常由Class对象中的getMethod方法产生 //当前访问时间 visitTime = new Date(); //转为年-月-日 时:分:秒字符串 visitTimeStr = DateAndString.DateToString(visitTime, "yyyy-MM-dd HH:mm:ss"); //获取操作者信息 SecurityContext context = SecurityContextHolder.getContext(); User user = (User) context.getAuthentication().getPrincipal(); username = user.getUsername();//用户名 Collection&lt;GrantedAuthority&gt; authorities = user.getAuthorities();//角色 //获取操作者IP地址 ip = request.getRemoteAddr(); //获取访问的类和方法，拼接成url //获取切入对象的类 aClass = joinPoint.getTarget().getClass(); //★获取方法 //1. 获取切入对象（方法）的名字 String methodName=joinPoint.getSignature().getName(); //2. 获得方法的参数 Object[] args = joinPoint.getArgs(); //3. 判断要获取的方法是否有参数 if (args==null||args.length==0)//没有参数 &#123; //通过方法名获取方法//无参方法获取 method = aClass.getMethod(methodName); &#125;else &#123;//有参数 //创建一个argsClass数组 Class[] argsClass=new Class[args.length]; //循环，获取args数组里每个参数的类，并且装入argsClass数组 for (int i=0;i&lt;args.length;i++)&#123; argsClass[i]= args[i].getClass(); &#125; //通过方法名+参数类型获取方法//有参方法获取 method= aClass.getMethod(methodName,argsClass);//有的方法，参数是基本数据类型如int，方法内int参数换成Integer包装类 &#125; //拼接url String classURL="";//类路径 String methodURL="";//类后方法路径// class和method都拿到后，就可以拿到requestMapping注解里的值 if (aClass!=null&amp;&amp;method!=null&amp;&amp;aClass!=sysLogAOP.class)&#123;//防止空指针，并且class不为自身（？看有人这么写）//获取类和方法的RequestMapping对象 RequestMapping classAnnotation =(RequestMapping) aClass.getAnnotation(RequestMapping.class); RequestMapping methodAnnotation =(RequestMapping) method.getAnnotation(RequestMapping.class); if (classAnnotation!=null)&#123; classURL=classAnnotation.value()[0]; &#125; if (methodAnnotation!=null)&#123; methodURL=methodAnnotation.value()[0]; &#125;//.value()值为数组 url=classURL+methodURL; &#125; //打印输出，方便测试 System.out.println("访问时间"+ visitTimeStr); System.out.println("用户："+username+"；身份："+authorities+"IP地址："+ip); System.out.println("访问的类"+aClass+"；方法"+methodName+"\n；URL："+url); System.out.println("传递参数值："+ Arrays.toString(args)); &#125; /* * 后置通知 * 生成方法的完成时间 * 计算耗时 * 封装日志数据 * 调用service处理 * */ @After("execution(* com.SH.Controller.*.*(..))") public void AfterAd() throws Exception&#123; //记录方法完成的时间 Date completeTime=new Date(); //转换成指定格式字符串 String completeTimeStr =DateAndString.DateToString(completeTime,"yyyy-MM-dd HH:mm:ss"); //计算耗时 Long usedTime=completeTime.getTime()-visitTime.getTime(); //封装数据 SysLog sysLog=new SysLog(); sysLog.setId(completeTimeStr); sysLog.setVisitTime(visitTime); sysLog.setVisitTimeStr(visitTimeStr); sysLog.setUsername(username); sysLog.setIp(ip); sysLog.setUrl(url); sysLog.setExecutionTime(usedTime); sysLog.setMethod(method.getName()); //存入数据库 boolean flag = sysLogService.insertOne(sysLog); //打印输出，方便测试 System.out.println("完成时间："+completeTimeStr+"；耗时："+usedTime+"毫秒"); System.out.println("封装日志："+sysLog); System.out.println("将日志，存入数据库结果："+flag); &#125;&#125; tips： 1.3.1. 关于获取IPspring提供了一个RequestContextListener，可以在spring中直接使用（先注入）HttpServletRequest对象。在web.xml中配置监听器： 123456&lt;!-- 为spring提供 request对象,监听器--&gt;&lt;listener&gt; &lt;listener-class&gt; org.springframework.web.context.request.RequestContextListener &lt;/listener-class&gt;&lt;/listener&gt; 1.3.2. 关于获取用户信息可以通过SecurityContextHolder.getContext()获取sercurity上下文对象，从而可以getAuthentication().getPrincipal()获得用户对象，这个上文在权限控制标签中说过。 12SecurityContext context = SecurityContextHolder.getContext();//获取Security上下文对象User user = (User) context.getAuthentication().getPrincipal();//获取用户对象 创建sysLogAOP类，使用aop的前置通知、后置通知，详细如下： 1.3.3. 关于获取URL这里的url是拼接Controller类&amp;方法的@RequestMapping值得到的。 首先需要获取类、方法。 类使用JoinPoint获取： 1234//获取对象的类aClass = joinPoint.getTarget().getClass();//或dClass = joinPoint.getSignature().getDeclaringType(); 至于方法，因为将调用的Class对象的getMethod方法为： 12345678910@CallerSensitive public Method getMethod(String name, Class&lt;?&gt;... parameterTypes) throws NoSuchMethodException, SecurityException &#123; checkMemberAccess(Member.PUBLIC, Reflection.getCallerClass(), true); Method method = getMethod0(name, parameterTypes, true); if (method == null) &#123; throw new NoSuchMethodException(getName() + "." + name + argumentTypesToString(parameterTypes)); &#125; return method; &#125; 所以要按有无参数分开获取： 先使用JoinPoint得到方法名和方法的参数： 1234//1. 获取切入对象（方法）的名字String methodName=joinPoint.getSignature().getName();//2. 获得方法的参数（一个Object数组）Object[] args = joinPoint.getArgs(); 通过判断参数是否为空，来确认方法是否有參。 若无参数： 12345//3. 判断要获取的方法是否有参数 if (args==null||args.length==0)//没有参数 &#123; //通过方法名获取方法//无参方法获取 method = aClass.getMethod(methodName); 若有参数： 123456789101112&#125;else &#123;//有参数 //创建一个argsClass数组 Class[] argsClass=new Class[args.length]; //循环，获取args数组里每个参数的类，并且装入argsClass数组 for (int i=0;i&lt;args.length;i++)&#123; argsClass[i]= args[i].getClass();//这里会将int等基础数据类型获取成Integer包装类型// System.out.println("参数："+args[i]); &#125; //通过方法名+参数类型获取方法//有参方法获取 method= aClass.getMethod(methodName,argsClass);//有的方法，参数是基本数据类型如int，需要将方法内int参数换成Integer包装类,也就Controller层形参都使用Inter类型 &#125; 此处参数类型问题的详情： 这里参数获取类型（arg.getClass()），会把基本数据类型（如int等）获取成包装类型（如Integer等），而实际上是基本数据类型，这会使class.getMethod(String name, Class&lt;?&gt;... parameterTypes)执行时找不到匹配的方法对象，报NoSuchMethodException异常，以及后续的空指针异常。因为获取时便是Integer，使用isPrimitive()（确认是否为基本数据类型）的结果始终为false，目前我并未找到完美的解决方法。 临时的解决方式： ①让Controller内方法的参数类型只使用Integer等包装类，不能使用int等基本数据类型。直接把Controller内的int、char等类型改成Integer、Char就行了，不再用代码举例了。 ②创建一个HashMap用来存放包装类型与基本类型的&lt;K、V&gt;对，将获取的包装类型转换为基本类型。这样做就会使Controller类内方法的参数类型只能用int等基本数据类型，不能使用Integer等包装类型。当然，其他类型是不影响的。详细代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364@Component@Aspectpublic class sysLogAOP &#123; //创建一个HashMap，存放包装类与基本类型的KV对，用来将包装类型转为基本数据类型private static HashMap&lt;String, Class&gt; map = new HashMap&lt;String, Class&gt;() &#123; &#123; put("java.lang.Integer", int.class); put("java.lang.Double", double.class); put("java.lang.Float", float.class); put("java.lang.Long", long.class); put("java.lang.Short", short.class); put("java.lang.Boolean", boolean.class); put("java.lang.Char", char.class); &#125; &#125;; //获取切入对象的类 aClass = joinPoint.getTarget().getClass(); //★获取方法 String methodName=joinPoint.getSignature().getName();//1. 获取切入对象（方法）的名字 Object[] args = joinPoint.getArgs();//2. 获得方法的参数 //3. 判断要获取的方法是否有参数 Class[] argsClass=null;//参数类型数组 if (args==null||args.length==0)//没有参数 &#123; //通过方法名获取方法//无参方法获取 method = aClass.getMethod(methodName);//获取指定的方法，第二个参数可以不传 &#125;else &#123;//有参数 argsClass=new Class[args.length];//创建一个argsClass数组,长度与参数数组相同 for (int i=0;i&lt;args.length;i++)&#123;//循环 argsClass[i]= args[i].getClass();//获取args数组里每个参数的类，并且装入argsClass数组 //打印，以供观察 System.out.println("遍历出的参数的类名为："+args[i].getClass().getName()); if (map.get(args[i].getClass().getName())!=null)&#123;//能根据参数的类名在自定义的hashMap中找到对应的基本类型 argsClass[i]=map.get(args[i].getClass().getName());//则放入class数组,覆盖掉之前的class数组值，此时通过map将参数类型转为了基本数据类型 //打印，以供观察 System.out.println("参数类型转换为："+argsClass[i]); &#125;else &#123;//如果根据参数的类名在自定义的map集合中取不到值，则说明参数是其他类型 //打印，以供观察 System.out.println("参数是其他类型，或者是基本类型，保持class不变"); &#125; &#125; //打印出最终参数类型 System.out.println("最终参数类型："+ Arrays.toString(argsClass)); //通过方法名+参数类型获取方法//有参方法获取 method= aClass.getMethod(methodName,argsClass);//此时Controller类内方法参数类型就不能为包装类型了，只能用int、char等基本数据类型 &#125; 补充：还有个同样的问题，它有时还会把其他类型的参数获取成特定类型，如java.util.Map会获取成org.springframework.validation.support.BindingAwareModelMap。我将Controller类内方法的Map类型替换为BindingAwareModelMap类型，暂时避免异常。 BindingAwareModelMap类的信息如图所示，目前使用中尚未出现其他问题。 获取类和方法后，就可获取需要的注解（需要转换），这里是@RequestMapping注解 12RequestMapping classAnnotation =(RequestMapping) aClass.getAnnotation(RequestMapping.class);//类的RequestMapping注解 RequestMapping methodAnnotation =(RequestMapping) method.getAnnotation(RequestMapping.class);//方法的RequestMapping注解 当然前提是类和方法不为null 1if (aClass!=null&amp;&amp;method!=null) 然后就可以通过获得的RequestMapping对象，获得需要的属性。 注意： 虽然是Controller类，但类和方法不能保证都一定有@RequestMapping注解，并且value属性是数组 123456if (classAnnotation!=null)&#123; classURL=classAnnotation.value()[0]; &#125; if (methodAnnotation!=null)&#123; methodURL=methodAnnotation.value()[0]; &#125; 将两个RequestMapping的value值拼接起来，就拿到一个Controller-方法的URL了 1String URL=classURL+methodURL; 1.3.4. 关于获取参数值和参数名先获取参数 12//获得方法的参数（一个Object数组）Object[] args = joinPoint.getArgs(); 1.参数值 for循环打印出参数值 1234//循环，打印args数组里的值 for (int i=0;i&lt;args.length;i++)&#123; System.out.println("参数："+args[i]); &#125; 利用Array的toString方法打印参数值 1System.out.println("传递参数值："+ Arrays.toString(args)); 参考：数组输出的三种方式 2.参数名 123ParameterNameDiscoverer dpnd = new DefaultParameterNameDiscoverer();String[] argsNames = dpnd.getParameterNames(method);//method是之间获取方法时，得到的Method对象System.out.println("参数名："+ Arrays.toString(argsNames)); 然后做个数据分页即可，操作日志就完成了 2. 登录足迹loginLog我的做法是：在上文Security登录流程中的userServiceImpl类里，获取用户登录时间、ip。将数据拿到后封装，插入到数据库即可。 12345678910111213141516171819202122232425262728package com.SH.Service.ServiceImpl;import ...@Service("userService")//起个名字，供xml中配置@Transactionalpublic class userServiceImpl implements IuserService &#123; @Autowired private HttpServletRequest request; ... @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123; ... //获取用户ip、登录时间 String ip = request.getRemoteAddr();// Date logintime=new Date(); String logintime=DateAndString.DateToString(new Date(),"yyyy-MM-dd HH:mm:ss"); //打印以观察 System.out.println("用户："+username+"登陆ip"+ip+"；时间："+logintime); //将数据插入数据库即可 ... &#125; @Override public void addUser(UserInfo userInfo) throws Exception &#123;... &#125; 3. 日志数据分页依然是使用MyBatis的分页插件PageHelper，分页上次说过，这里简要复习，有一些知识的更新。 3.1. 依赖、Jar包12345&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;5.1.2&lt;/version&gt;&lt;/dependency&gt; 3.2. 分页后台这里使用了@RequestParam注解，属性name是前端参数名、required为是否必要、defaultValue为默认值。 分页插件的使用： 分页需要pageNum、pageSize两个参数，int或Integer类型。 PageHelper.startPage(int pageNum,int pageSize)方法后直接跟需要分页的方法即可，在service层写好后调用service也是可以的。 将查询方法返回的List集合交给PageInfo封装 在request域放入PageInfo对象即可 12345678910111213141516@RequestMapping("/selectBypage") public ModelAndView selectBypage(@RequestParam(name = "pageNum",required = true,defaultValue = "1") int pageNum, @RequestParam(name = "pageSize",required = true,defaultValue = "10") int pageSize) throws Exception &#123; //分页 PageHelper.startPage(pageNum,pageSize); List&lt;SysLog&gt; sysLogList = sysLogService.selectAll(); //pageInfo封装 PageInfo pageInfo=new PageInfo&lt;&gt;(sysLogList); ModelAndView mv=new ModelAndView(); mv.setViewName("syslog-list"); mv.addObject("pageInfo",pageInfo); return mv; &#125; PageInfo包装类的属性： 12345678910111213141516171819202122232425262728293031323334353637383940414243//当前页private int pageNum;//每页的数量private int pageSize;//当前页的数量private int size;//排序private String orderBy;//可以在页面中"显示startRow到endRow 共size条数据"//当前页面第一个元素在数据库中的行号private int startRow;//当前页面最后一个元素在数据库中的行号private int endRow;//总记录数private long total;//总页数private int pages;//结果集private List&lt;T&gt; list;//第一页private int firstPage;//前一页private int prePage;//下一页private int nextPage;//最后一页private int lastPage;//是否为第一页private boolean isFirstPage = false;//是否为最后一页private boolean isLastPage = false;//是否有前一页private boolean hasPreviousPage = false;//是否有下一页private boolean hasNextPage = false;//导航页码数private int navigatePages;//所有导航页号private int[] navigatepageNums; 3.3. 分页前端3.3.1. 环境准备EL表达式 前端Jsp页面使用EL表达式较为方便，要使用EL表达式注意将isELIgnored设为false，是否需要设置，要根据web.xml文件的声明部分的xsd版本而定，因为有的版本默认这个属性是true，会将EL表达式当字符串处理。 .jsp页面设置isELIgnored=”false”： 12&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8" isELIgnored="false" %&gt; web.xml，一个默认开启EL的版本： 12345&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://xmlns.jcp.org/xml/ns/javaee" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd" version="3.1"&gt; JSTL标签 在jsp页面头部引入JSP标准标签库 1&lt;%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core"%&gt; 3.3.2. 功能实现 数据展示 1234567891011121314151617&lt;!--数据列表--&gt;...前略&lt;!--使用jstl的forEach标签，进行数据遍历，items是要遍历的集合--&gt;&lt;c:forEach items="$&#123;pageInfo.list&#125;" var="syslog"&gt; &lt;tr&gt; &lt;td&gt;&lt;input name="ids" type="checkbox"&gt;&lt;/td&gt; &lt;td&gt;$&#123;syslog.id&#125;&lt;/td&gt; &lt;td&gt;$&#123;syslog.visitTimeStr &#125;&lt;/td&gt; &lt;td&gt;$&#123;syslog.username &#125;&lt;/td&gt; &lt;td&gt;$&#123;syslog.ip &#125;&lt;/td&gt; &lt;td&gt;$&#123;syslog.url&#125;&lt;/td&gt; &lt;td&gt;$&#123;syslog.executionTime&#125;毫秒&lt;/td&gt; &lt;td&gt;$&#123;syslog.method&#125;&lt;/td&gt; &lt;/tr&gt;&lt;/c:forEach&gt;...后略&lt;!--数据列表/--&gt; 分页按钮 1234567891011121314151617 &lt;a href="$&#123;pageContext.request.contextPath&#125;/sysLogController/selectBypage.action?pageNum=1&amp;pageSize=$&#123;pageInfo.size&#125;" &gt;首页&lt;/a&gt;&lt;a href="$&#123;pageContext.request.contextPath&#125;/sysLogController/selectBypage.action?pageNum=$&#123;pageInfo.pageNum-1&#125;&amp;pageSize=$&#123;pageInfo.size&#125;"&gt;上一页&lt;/a&gt; &lt;!-- 第一页、第二页、第三页...--&gt;&lt;ul&gt;&lt;c:forEach begin="1" end="$&#123;pageInfo.pages&#125;" var="num"&gt; &lt;li&gt;&lt;a href="$&#123;pageContext.request.contextPath&#125;/sysLogController/selectBypage.action?pageNum=$&#123;num&#125;&amp;pageSize=$&#123;pageInfo.size&#125;"&gt;$&#123;num&#125;&lt;/a&gt;&lt;/li&gt; &lt;/c:forEach&gt; &lt;/ul&gt; &lt;a href="$&#123;pageContext.request.contextPath&#125;/sysLogController/selectBypage.action?pageNum=$&#123;pageInfo.pageNum+1&#125;&amp;pageSize=$&#123;pageInfo.size&#125;"&gt;下一页&lt;/a&gt; &lt;a href="$&#123;pageContext.request.contextPath&#125;/sysLogController/selectBypage.action?pageNum=$&#123;pageInfo.pages&#125;&amp;pageSize=$&#123;pageInfo.size&#125;"&gt;尾页&lt;/a&gt; 改变每页容量 123456789101112131415161718&lt;div class="form-group form-inline"&gt;总共$&#123;pageInfo.pages&#125; 页，共$&#123;pageInfo.total&#125; 条数据。 每页 &lt;select id="selectSize" class="form-control" onchange="checkChange()"&gt; &lt;option&gt;10&lt;/option&gt; &lt;option&gt;15&lt;/option&gt; &lt;option&gt;20&lt;/option&gt; &lt;option&gt;50&lt;/option&gt; &lt;option&gt;80&lt;/option&gt; &lt;/select&gt; 条&lt;/div&gt;&lt;script&gt;//改变每页条数jsfunction checkChange()&#123;var size=$("#selectSize").val();location.href= "$&#123;pageContext.request.contextPath&#125;/sysLogController/selectBypage.action?pageNum=$&#123;pageInfo.pageNum&#125;&amp;pageSize="+size;&#125;&lt;/script&gt; 项目中使用了AdminLTE来美化页面。 AdminLTE：一款建立在bootstrap和jquery之上的开源的模板主题工具，它提供了一系列响应的、可重复使用的组件，并内置了多个模板页面；同时自适应多种屏幕分辨率，兼容PC和移动端。]]></content>
      <categories>
        <category>学习经验</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Maven聚合工程</tag>
        <tag>SSM</tag>
        <tag>用户关系管理项目</tag>
        <tag>Spring-security</tag>
        <tag>权限安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSM基础整合]]></title>
    <url>%2F2019%2F07%2F08%2FSSM%E5%9F%BA%E7%A1%80%E6%95%B4%E5%90%88%2F</url>
    <content type="text"><![CDATA[SSM基础整合Zero. 创建Maven项目， pom依赖： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.SH&lt;/groupId&gt; &lt;artifactId&gt;SSM_01Project&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;name&gt;SSM_01Project Maven Webapp&lt;/name&gt; &lt;!-- FIXME change it to the project's website --&gt; &lt;url&gt;http://www.example.com&lt;/url&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt; &lt;spring.version&gt;4.3.3.RELEASE&lt;/spring.version&gt; &lt;slf4j.version&gt;1.6.6&lt;/slf4j.version&gt; &lt;log4j.version&gt;1.2.12&lt;/log4j.version&gt; &lt;mysql.version&gt;5.1.6&lt;/mysql.version&gt; &lt;mybatis.version&gt;3.4.5&lt;/mybatis.version&gt; &lt;jackson.version&gt;2.6.1&lt;/jackson.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.6.8&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;$&#123;mysql.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- log start --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;$&#123;log4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- log end --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;c3p0&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.1.2&lt;/version&gt; &lt;type&gt;jar&lt;/type&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-dbcp&lt;/groupId&gt; &lt;artifactId&gt;commons-dbcp&lt;/artifactId&gt; &lt;version&gt;1.4&lt;/version&gt; &lt;/dependency&gt;&lt;!--json数据格式--&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;$&#123;jackson.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;$&#123;jackson.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--sql 解析工具依赖,配合分页使用--&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.jsqlparser&lt;/groupId&gt; &lt;artifactId&gt;jsqlparser&lt;/artifactId&gt; &lt;version&gt;0.9.5&lt;/version&gt; &lt;/dependency&gt; &lt;!--myBatis分页插件 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;5.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;SSM_01Project&lt;/finalName&gt; &lt;pluginManagement&gt;&lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/plugin&gt; &lt;!-- see http://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_war_packaging --&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.8.0&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;version&gt;2.22.1&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;version&gt;3.2.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-install-plugin&lt;/artifactId&gt; &lt;version&gt;2.5.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt; &lt;version&gt;2.8.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.2&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;showWarnings&gt;true&lt;/showWarnings&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;/build&gt;&lt;/project&gt; 1. ApplicationContext.xml 新建db.properties，写数据库配置需要的数据 加载db.properties，class为：PreferencesPlaceholderConfigurer，属性locations下用array，value，classpath引用db.properties datasource，class为：BasicDatasource，property下配置数据库链接信息 sqlSessionFactory，Class为：SqlSessionFactroyBean，属性需要引用datasource和mapperlocations值为classpath：*.xml加载mybatis的mapperxml mappers批量生成mapper接口的对象，class为：MapperScannerConfigurer，注意属性basePackage的值用value，而不是ref 开启注解扫描，component-scan，并且使用排除Controller注解（annotation），（org.springframework.stereotype.Controller） 配置事务管理，DataSourceTransactionManager，其属性中引入datasource，开启事务注解支持:&lt;tx:annotation-driven,空格后配置transaction-manager属性将上面bean的id值输入 代码： db.properties 1234driver=com.mysql.jdbc.Driverurl=jdbc:mysql://localhost:3306/databaseusername=rootpassword=123456 log4j.properties 123456789101112131415161718# Set root category priority to INFO and its only appender to CONSOLE.#log4j.rootCategory=INFO, CONSOLE debug info warn error fatallog4j.rootCategory=info, CONSOLE, LOGFILE# Set the enterprise logger category to FATAL and its only appender to CONSOLE.log4j.logger.org.apache.axis.enterprise=FATAL, CONSOLE# CONSOLE is set to be a ConsoleAppender using a PatternLayout.log4j.appender.CONSOLE=org.apache.log4j.ConsoleAppenderlog4j.appender.CONSOLE.layout=org.apache.log4j.PatternLayoutlog4j.appender.CONSOLE.layout.ConversionPattern=%d&#123;ISO8601&#125; %-6r [%15.15t] %-5p %30.30c %x - %m\n# LOGFILE is set to be a File appender using a PatternLayout.log4j.appender.LOGFILE=org.apache.log4j.FileAppenderlog4j.appender.LOGFILE.File=d:\axis.loglog4j.appender.LOGFILE.Append=truelog4j.appender.LOGFILE.layout=org.apache.log4j.PatternLayoutlog4j.appender.LOGFILE.layout.ConversionPattern=%d&#123;ISO8601&#125; %-6r [%15.15t] %-5p %30.30c %x - %m\n ApplicationContext.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd"&gt;&lt;!-- 数据源--&gt;&lt;bean id="dbproperties" class="org.springframework.beans.factory.config.PreferencesPlaceholderConfigurer"&gt; &lt;property name="locations"&gt; &lt;array&gt; &lt;value&gt;classpath:db.properties&lt;/value&gt; &lt;/array&gt; &lt;/property&gt;&lt;/bean&gt; &lt;bean id="datasource" class="org.apache.commons.dbcp.BasicDataSource"&gt; &lt;property name="driverClassName" value="$&#123;driver&#125;"/&gt; &lt;property name="url" value="$&#123;url&#125;"/&gt; &lt;property name="username" value="$&#123;username&#125;"/&gt; &lt;property name="password" value="$&#123;password&#125;"/&gt;&lt;/bean&gt;&lt;bean id="sqlsessionFactroy" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;property name="dataSource" ref="datasource"/&gt; &lt;property name="mapperLocations" value="classpath:MapperXml/*.xml"/&gt;&lt;!-- 插件列表--&gt; &lt;property name="plugins"&gt; &lt;array&gt;&lt;!-- myBatis分页--&gt; &lt;bean class="com.github.pagehelper.PageInterceptor"&gt; &lt;property name="properties"&gt; &lt;value&gt;helperDialect=mysql&lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/array&gt; &lt;/property&gt;&lt;/bean&gt;&lt;!-- 批量生成mapper对象--&gt;&lt;bean id="mappers" class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;property name="basePackage" value="com.SH.mapper"/&gt;&lt;/bean&gt;&lt;!-- 注解扫描，不扫描Controller--&gt; &lt;context:component-scan base-package="com.SH"&gt; &lt;context:exclude-filter type="annotation" expression="org.springframework.stereotype.Controller"/&gt; &lt;/context:component-scan&gt;&lt;!--事务管理--&gt; &lt;bean id="transManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="datasource"/&gt; &lt;/bean&gt;&lt;!-- 事务注解支持--&gt; &lt;tx:annotation-driven transaction-manager="transManager"/&gt;&lt;/beans&gt; 2. mpper.xml 配置mybaitis的mpper.xml 代码： MapperXml/VocaloidMapper.xml（放置在resources/MapperXml包下） 12345678910111213&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.SH.mapper.VocaloidMapper"&gt; &lt;select id="selectAll" resultType="com.SH.bean.Vocaloid"&gt; select * from vocaloid &lt;/select&gt;&lt;/mapper&gt; 3. 建立数据库表的对应类 生成set、get方法，构造器，重写toString 代码： com.SH.bean.Vocaloid 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package com.SH.bean;public class Vocaloid &#123;private Integer id;private String name;private Integer sex;private String color;private Integer team_id; public Vocaloid() &#123; &#125; @Override public String toString() &#123; return "Vocaloid&#123;" + "id=" + id + ", name='" + name + '\'' + ", sex=" + sex + ", color='" + color + '\'' + ", team_id=" + team_id + '&#125;'; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getSex() &#123; return sex; &#125; public void setSex(Integer sex) &#123; this.sex = sex; &#125; public String getColor() &#123; return color; &#125; public void setColor(String color) &#123; this.color = color; &#125; public Integer getTeam_id() &#123; return team_id; &#125; public void setTeam_id(Integer team_id) &#123; this.team_id = team_id; &#125; public Vocaloid(Integer id, String name, Integer sex, String color, Integer team_id) &#123; this.id = id; this.name = name; this.sex = sex; this.color = color; this.team_id = team_id; &#125;&#125; 3. Mapper接口 建立mapper.xml对应的接口 代码： com.SH.mapper.VocaloidMapper 123456789101112package com.SH.mapper;import com.SH.bean.Vocaloid;import java.util.HashMap;import java.util.List;public interface VocaloidMapper &#123; List&lt;Vocaloid&gt; selectAll();&#125; 4. springMVC.xml 开启mvc注解支持，annotation-driven 开启注解扫描component-scan，使用base-package只扫描Controller包 配置视图解析器InternalResourceViewResolver,prefix前缀，suffix后缀 代码： springMVC.xml 1234567891011121314151617181920212223242526272829303132&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt;&lt;!-- 配置组件扫描，注解扫描，只扫描Controller包--&gt;&lt;context:component-scan base-package="com.SH.controller"/&gt;&lt;!-- 开启mvc注解驱动，处理器映射器，处理器解析器--&gt; &lt;mvc:annotation-driven/&gt;&lt;!-- 视图解析器--&gt; &lt;bean id="internalviewresovler" class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/resources/jsp/"/&gt; &lt;property name="suffix" value=".jsp"/&gt; &lt;/bean&gt;&lt;!--释放静态资源，对静态资源使用原生态servlet--&gt;&lt;mvc:default-servlet-handler/&gt;&lt;!-- 配置放置静态资源的路径--&gt;&lt;!-- &lt;mvc:resources mapping="/resources/**" location="/resources/"/&gt;--&gt;&lt;/beans&gt; 5. web.xml 配置spring，使用listener,class为ContextLoaderListener,再使用Context-Param指定spring配置文件的位置 配置springMVC，使用servlet标签，class为DispatcherServlet,使用init-param初始化参数，使用load-on-start配置随服务器加载，最后再servlet-mapping设置需要拦截的请求，如*.action 配置解决中文的过滤器(filter)，class为：CharacterEncodingFilter,使用init-param初始化参数（参数名为encoding，值为utf-8） ,在filter-mapping里拦截所有请求（/*） classPath的使用 代码： web.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE web-app PUBLIC "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN" "http://java.sun.com/dtd/web-app_2_3.dtd" &gt;&lt;web-app&gt; &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt; &lt;!--配置spring--&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:ApplicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt;&lt;!-- 配置springMVC--&gt;&lt;servlet&gt; &lt;servlet-name&gt;Dispatchservlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springMVC.xml&lt;/param-value&gt; &lt;/init-param&gt;&lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;Dispatchservlet&lt;/servlet-name&gt; &lt;url-pattern&gt;*.action&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;!-- 配置解决中文乱码的过滤器--&gt; &lt;filter&gt; &lt;filter-name&gt;charactEncoding&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;charactEncoding&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt;]]></content>
      <categories>
        <category>学习经验</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>开发知识</tag>
        <tag>SSM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[int和Integer的区别]]></title>
    <url>%2F2019%2F07%2F06%2Fint%E5%92%8CInteger%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[int和Integer的区别 int是八大基本数据类型（byte，char，short，int，long，float，double，boolean）之一，而Integer是int 包装类，所以 int的默认值是0 Integer的默认值是null 在JDK1.5以后，Integer 有自动装箱和拆箱的语法糖。 自动装箱,假如写个Integer a： 其实为：Integer a=Integer.valueOf(int a); 自动拆箱，当涉及到计算时，如a+b： 其实为：a.intValue()+b.intValue(); Integer创建对象时，若数值在[-128,127]区间，第一次声明会将值放入缓存，第二次时会直接将上次缓存里的值给对象，所以地址不变，不是重新创建一个Ingeter 对象。 public static void main(String[] args) { Integer i = 10; Integer j = 10; System.out.println(i == j); }//结果为true 分析源码我们可以知道在 i &gt;= -128 并且 i &lt;= 127 的时候，第一次声明会将 i 的值放入缓存中，第二次直接取缓存里面的数据，而不是重新创建一个Ingeter 对象。 那么第一个打印结果因为 i = 10 在缓存表示范围内，所以为 true。 当值为128时，不放入缓存,会重新创建对象，地址变化: Integer i =128; Integer j = 128; System.out.println(i == j); }//结果为false 两个Integer对象比较时，使用equals 定义泛型时，必须使用Integer，而不是int，泛型参数必须是一个类，即Object的子类 Map&lt;String,Object&gt; map1 Map&lt;Integer,Object&gt; map2]]></content>
      <categories>
        <category>学习经验</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>开发知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSM+easyUI实现数据分页]]></title>
    <url>%2F2019%2F07%2F06%2F%E6%95%B0%E6%8D%AE%E5%88%86%E9%A1%B5%2F</url>
    <content type="text"><![CDATA[使用mybatis分页插件1. jar包和依赖： jsqlparser-0.9.5.jar（sql 解析工具） 123456&lt;!--sql 解析工具依赖,配合分页使用--&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.jsqlparser&lt;/groupId&gt; &lt;artifactId&gt;jsqlparser&lt;/artifactId&gt; &lt;version&gt;0.9.5&lt;/version&gt;&lt;/dependency&gt; pagehelper-5.1.2.jar 123456&lt;!--myBatis分页插件 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;5.1.2&lt;/version&gt;&lt;/dependency&gt; 2. spring配置文件ApplicatonContext.xml的sqlSessionFactory里配置一个载入插件的属性，名为plugins，用array来配置多个插件。 增加一个插件（拦截器），用标签 用bean，class为pagehelper的jar包中的PageInterceptor类。 此类中有个名为properties的属性，使用value对其赋值 value内填写：helperDialect=mysql（设置连接的是什么数据库,如mysql、Oracle） 如: 1234567891011121314 &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;property name="plugins"&gt; &lt;array&gt; &lt;bean class="com.github.pagehelper.PageInterceptor"&gt; &lt;property name="properties"&gt; &lt;value&gt; helperDialect=mysql &lt;/value&gt; &lt;/property&gt;&lt;/bean&gt; &lt;/array&gt; &lt;/property&gt; &lt;/bean&gt; 3. Controller在你需要进行分页的 MyBatis 查询方法前调用 PageHelper.startPage 静态方法即可，该方法需要两个参数pageNum、pageSize，紧跟在这个方法后的第一个MyBatis 查询方法会被进行分页。 12345678//request: url?pageNum=1&amp;pageSize=10//支持 ServletRequest,Map,POJO 对象，需要配合 params 参数PageHelper.startPage(request);//紧跟着的第一个select方法会被分页List&lt;Country&gt; list = countryMapper.selectIf(1);//后面的不会被分页，除非再次调用PageHelper.startPageList&lt;Country&gt; list2 = countryMapper.selectIf(null); 使用： 1234567891011121314151617181920 /** 使用pagehelper+PageInfo进行分页查询 *///private Map&lt;String,Object&gt; result= new HashMap&lt;String,Object&gt;(); @RequestMapping(value = "/selectBypage") @ResponseBody//将返回值转为json数据格式 public Map&lt;String,Object&gt; selectBypage(Integer page,Integer rows,HashMap&lt;String,Object&gt; map)&#123; //使紧跟其后的mybatis查询分页 PageHelper.startPage(page,rows); List&lt;Vocaloid&gt; vocaloidsBypage=vocaloidService.selectAll(); //将查询结果封装 PageInfo&lt;Vocaloid&gt; pageInfo=new PageInfo&lt;&gt;(vocaloidsBypage); long total = pageInfo.getTotal(); List&lt;Vocaloid&gt; list = pageInfo.getList(); map=new HashMap&lt;&gt;(); map.put("rows",list); map.put("total",total); //其实直接把查询结果vocaloidsBypage放到rows就可以了 return map; &#125; 4. 什么时候会导致不安全的分页？12345678//获取第1页，10条内容，默认查询总数countPageHelper.startPage(1, 10);List&lt;Country&gt; list;if(param1 != null)&#123; list = countryMapper.selectIf(param1);&#125; else &#123; list = new ArrayList&lt;Country&gt;();&#125; 这种情况下由于 param1 存在 null 的情况，就会导致 PageHelper 生产了一个分页参数，但是没有被消费，这个参数就会一直保留在这个线程上。当这个线程再次被使用时，就可能导致不该分页的方法去消费这个分页参数，这就产生了莫名其妙的分页。 上面这个代码，应该写成下面这个样子： 12345678List&lt;Country&gt; list;if(param1 != null)&#123; //获取第1页，10条内容，默认查询总数count PageHelper.startPage(1, 10); list = countryMapper.selectIf(param1);&#125; else &#123; list = new ArrayList&lt;Country&gt;();&#125; 这种写法就能保证安全。 5. 跳转页面过界如果你分页插件使用于类似分页查看列表式的数据，如新闻列表，软件列表， 你希望用户输入的页数不在合法范围（第一页到最后一页之外）时能够正确的响应到正确的结果页面， 那么你可以配置 reasonable 为 true，这时如果 pageNum&lt;=0 会查询第一页，如果 pageNum&gt;总页数 会查询最后一页。 1234567891011121314151617181920212223242526 &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;property name="mapperLocations"&gt; &lt;array&gt; &lt;value&gt;classpath:mapper/*.xml&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;property name="typeAliasesPackage" value="com.isea533.mybatis.model"/&gt; &lt;property name="plugins"&gt; &lt;array&gt; &lt;bean class="com.github.pagehelper.PageInterceptor"&gt; &lt;!-- 这里的几个配置主要演示如何使用，如果不理解，一定要去掉下面的配置 --&gt; &lt;property name="properties"&gt; &lt;value&gt; helperDialect=mysql reasonable=true supportMethodsArguments=true params=count=countSql autoRuntimeDialect=true &lt;/value&gt; &lt;/property&gt;&lt;/bean&gt; &lt;/array&gt; &lt;/property&gt; &lt;/bean&gt; 了解更多… 使用easyUI1. 启用easyui-datagrideasyui-datagrid下设置：pagination:true 显示分页菜单： 整体代码如： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!--数据网络--&gt;&lt;table id="vstable"&gt;&lt;/table&gt;&lt;script type="text/javascript" &gt; $(function () &#123; $("#vstable").datagrid(&#123; fitcolumns:true, url:"$&#123;pageContext.request.contextPath&#125;/vocaloidController/vSelectAll.action", columns:[[ &#123; field:"null", checkbox:true &#125;, &#123; field:"id", title:"ID", width:100 &#125;, &#123; field:"name", title:"Name", width:100 &#125;, &#123; field:"sex", title:"Sex", width:100 &#125;, &#123; field:"color", title:"Color", width:100 &#125;, &#123; field:"team_id", title:"Team_ID", width:100 &#125; ]], //显示分页栏 pagination:true, //工具条 toolbar:"#tb" &#125;); &#125;);&lt;/script&gt; 2. 参数解析easyUI会向后台发送两个参数,page和rows： 传参形式为： 而后台不仅需要给easyUI传递json格式的查询结果，而且还需要传递total和rows： 3. easyUI配合controller的增删改查 添加： Controller: 123456789101112131415@RequestMapping(value = "/InsertBypage")@ResponseBodypublic Map&lt;String,Object&gt; InsertBypage(Vocaloid vocaloid,HashMap&lt;String,Object&gt; map)&#123; boolean b = vocaloidService.insertOne(vocaloid); map=new HashMap&lt;&gt;(); System.out.println(b); if (b)&#123; map.put("success",b); return map; &#125;else&#123; map.put("success",b); return map; &#125;&#125; Service: 123456789101112131415 @Override public boolean insertOne(Vocaloid vocaloid) &#123; boolean b; //将插入成功的返回值设为true，异常的返回值为false try &#123; b = vocaloidMapper.insertOne(vocaloid); &#125;catch (Exception e)&#123; b=false; e.printStackTrace(); &#125;// int e=11/0;//异常测试 System.out.println("新增一行vocaloid,返回：" + b); return b; &#125; html&amp;Js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;%--easyUI按钮，增删改查工具条，iconCls是图标，plain:true是按钮3d感？--%&gt;&lt;div id="CRUDbutton"&gt; &lt;a id="addButton" href="#" class="easyui-linkbutton" data-options="iconCls:'icon-add'"&gt;添加&lt;/a&gt; &lt;a id="updateButton" href="#" class="easyui-linkbutton" data-options="iconCls:'icon-edit',plain:true"&gt;修改&lt;/a&gt; &lt;a id="deleteButton" href="#" class="easyui-linkbutton" data-options="iconCls:'icon-remove',plain:true"&gt;删除&lt;/a&gt;&lt;/div&gt;&lt;%--编辑窗口，默认关闭状态，用js控制打开--%&gt;&lt;%--div--%&gt;&lt;div id="Edit_window" class="easyui-window" title="客户数据编辑" style="width:500px;height:300px" data-options="modal:true,closed:true"&gt; &lt;form id="insertForm" method="post"&gt; &lt;label&gt;ID&lt;/label&gt;&lt;input type="text" name="id" class="easyui-validatebox" data-options="required:true"&gt;&lt;br&gt; &lt;label&gt;Name&lt;/label&gt;&lt;input type="text" name="name" class="easyui-validatebox"&gt;&lt;br&gt; &lt;label&gt;Sex&lt;/label&gt;&lt;input type="text" name="sex"&gt;&lt;br&gt; &lt;label&gt;Color&lt;/label&gt;&lt;input type="text" name="color"&gt;&lt;br&gt; &lt;label&gt;Team_ID&lt;/label&gt;&lt;input type="text" name="team_id"&gt;&lt;br&gt; &lt;a id="insert_Button" href="#" class="easyui-linkbutton"&gt;确定&lt;/a&gt; &lt;/form&gt;&lt;/div&gt;&lt;%--增加按钮的事件--%&gt;&lt;script type="text/javascript"&gt; $(function () &#123; // 点击“添加”按钮时，打开窗口 $("#addButton").click(function () &#123; //打开窗口前清空里面的表单 $("#insertForm").form("clear"); //打开窗口 $("#Edit_window").window("open") &#125;); //点击确定按钮（上面的a标签）触发controller和事件 $("#insert_Button").click(function () &#123; $("#insertForm").form( "submit", &#123;url:"$&#123;pageContext.request.contextPath&#125;/vocaloidController/InsertBypage.action", //success:服务器执行完毕回调函数 success:function(data)&#123; //data: 服务器返回的数据，类型字符串类，此时我在InsertBypage方法返回值里放入了success变量 //把data字符串类型转换对象类型 data = eval("("+data+")"); if (data.success) &#123; //关闭窗口 $("#Edit_window").window("close"); //刷新datagrid $("#vstable").datagrid("reload"); $.messager.alert("提示"+data.success,"增加成功"); &#125;else &#123; //关闭窗口 $("#Edit_window").window("close"); //刷新datagrid $("#vstable").datagrid("reload"); $.messager.alert("提示"+data.success+"增加失败：","可能是id重复"); &#125; &#125; &#125; ); &#125;); &#125;);&lt;/script&gt;]]></content>
      <categories>
        <category>学习经验</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>开发知识</tag>
        <tag>mybatis分页插件</tag>
        <tag>数据分页</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL Error:Lost connection to MySQL server]]></title>
    <url>%2F2019%2F07%2F05%2FMySQL-Error-2013%2F</url>
    <content type="text"><![CDATA[MySQL 提示：1. Lost connection to MySQL server at ‘waiting for initial communication packet’,system error:0 错误产生经过：昨天试加速器试用，改了硬件信息，隔天上午数据库运行正常，下午重启后mysql连接时就出错了。 解决方法： 找到mysql安装目录下的my.ini文件(我mysql安装目录是在D:\SP GAME),记事本打开my.ini, 找到[mysqld],在末尾添加一行： skip-name-resolve 记得保存。 在“计算机管理-服务和应用程序-服务”找到MySQL， 重启该服务。 2. Lost connection to MySQL server at ‘reading initial communication packet’, system error: 0 重启MySQL服务]]></content>
      <categories>
        <category>开发问题</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>mysql</tag>
        <tag>error</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JQuery EasyUI入门]]></title>
    <url>%2F2019%2F07%2F03%2FEasyUI%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[EasyUI入门使用简 介easyui是一种基于jQuery、Angular.、Vue和React的用户界面插件集合，可简单快速的搭建页面布局，方便后台人员制作简易的管理界面，节省网页开发的时间和规模，现在开始学习easyUI的jquery版本的入门使用。 引入资源文件在官网下载jQuery版的easyUI后，在项目的webapp中建立一个文件夹，用于存放easyUI的资源文件，如图所示： 分别选择themes、jquery.easyui.min.js和jquery.min.js，导入到项目中，如图所示： 新建html或jsp，在&lt; head&gt;里引用项目中的资源文件，如下所示： 1234567891011&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;easyUI.html-class&lt;/title&gt; &lt;link rel="stylesheet" type="text/css" href="easyUI/themes/default/easyui.css"&gt; &lt;link rel="stylesheet" type="text/css" href="easyUI/themes/icon.css"&gt; &lt;script type="text/javascript" src="easyUI/jquery.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="easyUI/jquery.easyui.min.js"&gt;&lt;/script&gt; &lt;!-- 新增 --&gt; &lt;script type="text/javascript" src="easyUI/locale/easyui-lang-zh_CN.js"&gt;&lt;/script&gt;&lt;/head&gt; 功能和使用1、树（tree）easyui-tree：树形菜单 效果如图： 使用： easyui-tree 、 .tree() 属性： checkbox：true（可开启复选框） 可直接在标签中用class=“easyui-tree”来使用，注意&lt; span&gt;标签，data-options中配置属性，多个属性之间用逗号隔开： 12345678&lt;ul class="easyui-tree" data-options="checkbox:true"&gt; &lt;li&gt;&lt;span&gt;菜单a&lt;/span&gt; &lt;ul &gt; &lt;li&gt;&lt;span&gt;菜单1&lt;/span&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt;&lt;span&gt;菜单b&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt; 推荐使用普通html标签+js的方式来实现。这样能处理更复杂的样式。 具体写法为在标签设置一个id或class，接下来在js写$(function(){ }),大括号中使用$(&quot;#id&quot;)或是class用$(&quot;.class&quot;)来指定对象。 接着对象后.tree();即可设置树应用到对象，关于.tree()里的属性的设置，直接在（）中使用｛｝大括号将属性包括即可，多个属性用逗号隔开，与data-options相同。 如 $(&quot;#uitree&quot;).tree( { checkbox:true ，... } ); ， 整体代码如下： 1234567891011121314151617&lt;%--树形菜单 可设置checkbox属性--%&gt; &lt;ul id="uitree"&gt; &lt;li&gt;&lt;span&gt;菜单a&lt;/span&gt; &lt;ul&gt; &lt;li&gt;&lt;span&gt;菜单a-1&lt;/span&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt;&lt;span&gt;菜单b&lt;/span&gt;&lt;/li&gt; &lt;/ul&gt; &lt;script type="text/javascript"&gt; $(function () &#123; $("#uitree").tree(&#123; checkbox:true &#125;); &#125;) &lt;/script&gt; .tree()应用tree功能，tree()的属性如checkbox设为true可开启选择框，部分其他功能用法与tree一样，非必要时不再赘述。 2、拖动和放置easyui-draggable：可拖动 easyui-droppable：可放置 效果如图： 使用： easyui-draggable 、 .draggable()；easyui-droppable 、 .droppable()； 拖动和放置两个功能，可同时作用于一个对象。 拖动 handle:&#39;&#39;#xxx&#39;（指定只有拖住’#xxx‘时，才可拖动整个div） proxy proxy:&#39;clone&#39;（拖动时创建复制的副本，拖动时拖动副本，松手时本体位置改变，副本消失） proxy:function(source){}（自定义一个副本） revert:true（拖动时松手，元素将返回原来位置） disabled:true（停用拖动）更多… 放置 accept:&quot;#xx1,#xx2&quot; （指定可放置的对象） disabled:true（停用可放置） onDrop:function (e, source) { $(this).append(source);}（将对象放置区域内部） 更多… class方式使用： 1234&lt;!--可拖动的div draggable, 在data-options将属性handle进行下例的设置，就可设置只有拖动id为title的div才会生效--&gt;&lt;div class="easyui-draggable" data-options="handle:'#title'" style="width: 200px;height: 100px;background-color: #00bbee"&gt; &lt;div id="title" style="width: auto;height: 20px"&gt;div的标题title&lt;/div&gt;&lt;/div&gt; JS方式（css+html+js代码如下）： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;%--拖动和放置div的CSS--%&gt; &lt;style type="text/css"&gt; .DDbox &#123; width: 700px; height: 200px; border: 1px solid black; &#125; #Div_draggable &#123; width: 300px; height: 100px; background-color: #00ee00; margin-right: 100px; border: 1px solid black; float: left; &#125; .content &#123; height: 20px; width: 100px; background-color: #00bbee; margin: 5px; &#125; #Div_droppable &#123; width: 200px; height: 100px; border: 1px solid black; float: left; &#125; &lt;/style&gt; &lt;%--可拖动div 可设置handle属性、proxy代理属性（clone或自定义新对象(传递一个function)）,revert设置为true可在鼠标释放时复原，其他也可设置拖拽范围--%&gt; &lt;div class="DDbox"&gt; &lt;div id="Div_draggable" &gt; &lt;div id="title" style="width: auto;height: 20px"&gt;拖拽我 才可拖动整个div &lt;/div&gt; &lt;div class="content" id="drag1"&gt;内容1&lt;/div&gt; &lt;div class="content" id="drag2"&gt;内容2&lt;/div&gt; &lt;div class="content" id="drag3"&gt;内容3&lt;/div&gt; &lt;/div&gt; &lt;%--与draggable组合，可放置元素的容器--%&gt; &lt;div id="Div_droppable"&gt; &lt;div id="title2" style="width: auto;height: 20px"&gt;可放置的容器&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;%--拖动和放置的js, 可拖动和可放置 能同时作用于同一个div--%&gt; &lt;script type="text/javascript"&gt; &lt;%-- （注意大小写） 左： 拖动--%&gt; $(function () &#123; $("#Div_draggable").draggable(&#123; handle:'#title',proxy:'clone' &#125;).droppable(&#123; onDrop:function (e,source) &#123; $(this).append(source); &#125; &#125;); $(".content").draggable(&#123; proxy:'clone',revert:true &#125;) &#125;); &lt;%--右： 放置 --%&gt; $(function () &#123; $("#Div_droppable").droppable(&#123; accept:"#drag1,#drag2", onDrop:function (e, source) &#123; $(this).append(source); &#125; &#125;).draggable(&#123; proxy:'clone',handle:'#title2' &#125;); &#125;) &lt;/script&gt; 3、调节尺寸easyui-resizable：可调节尺寸大小，注意单词是resizable ，不是resize，没有e。效果如图： 鼠标放置区域的边框上即可调节长宽。 【属性】（区分大小写，像素不用带px）： minWidth：最小宽度 minHeight：最小高度 maxWidth：最大宽度 maxHeight：最大高度 更多… 使用1： 123&lt;!--可缩放的div区域 resizable,有minWidth、minHeight、maxWidth等属性，注意像素直接写数字不要带px，逗号隔开--&gt;&lt;div class="easyui-resizable" data-options="minWidth:100,minHeight:100,maxWidth:500" style="border: solid;width: 100px;height: 150px"&gt;&lt;/div&gt; 使用2： 12345678910&lt;%--可缩放调整大小的div resizable--%&gt; &lt;div id="resize" style="height: 50px;width: 50px;border: solid"&gt;&lt;/div&gt; &lt;script type="text/javascript"&gt; $(function () &#123; $("#resize").resizable(&#123; minWidth:25,minHeight:25 &#125;) &#125;) &lt;/script&gt; 博主：(╯﹏╰)给自己挖个大坑，这样写太耗时间了，后面会有个easyUI实际运用的文章。]]></content>
      <categories>
        <category>学习经验</category>
      </categories>
      <tags>
        <tag>开发知识</tag>
        <tag>javaScript</tag>
        <tag>easyUI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[宫泽贤治]]></title>
    <url>%2F2019%2F06%2F23%2F%E5%AE%AB%E6%B3%BD%E8%B4%A4%E6%B2%BB%2F</url>
    <content type="text"><![CDATA[童话作家所有人的童话宫泽贤治写的故事里，常常有会说话、会像人一样行走的动物（废话，因为是童话啊），虽说是童话，但有的故事我依然还没能看明白，比如为什么山猫会消失，黑熊为什么2年后死去？不过他的故事并不难读，有孩童能看到的结局，有大人能看懂的深意。记得作者在自序中写道： 因此，这些故事当中，也许有些会对您有益处，有的没有，关于这一点我自己也无法分辨其中的差别。其中有些部分，或许您读了会觉得一头雾水，其实我也不知道为什么会写出这些内容。 看到这段话时我不由笑起来，觉得作者坦白得可爱，让我想起了曾经高中的语文。 澄净透明的文字宫泽贤治的文字充满自然的气息，纯净又真挚，总是有着丰富的想象力，诗一样精致，绘出浪漫唯美的景象。就如同他在自序中所说： 我所写的故事，全都来自森林、原野、铁道线路、彩虹或月光。 《文少》中这样评价宫泽贤治的作品： 「贤治的作品是非常质朴的，散发着大地、风和阳光一样的香味，透明又真切，让人不禁产生一种怀念的感觉呢。就好比，在吹着爽朗的微风的田间，穿着沾着泥土的围裙，低着头作业的感觉——散发着青草的气味，有点酸，有点苦，又有点甜的感觉，在口中渐渐融开，喉咙也好像被滋润了一样。又像是用冰冷河水洗过的黄瓜味，像是嚼着生茄子般带着的新鲜和甜味，像是祭典的夜里喝下的橘子汽水——不光是贤治写下的故事，连他的行文方式，文章的节奏，甚至语言本身都有着独特的味道呢！」 银河铁道之夜 宫泽贤治写的童话有很多，作者也说过“其实我也不知道为什么会写出这些内容”。但我相信《银河铁道之夜》的每一个字都有其特别的用意。宫泽贤治在病床不断修改着《银河铁道之夜》的原稿，直到去世时也没有最终版本。 乔班尼才刚听见某处传来奇异的声音：”银河站——银河站——“ 眼前倏地一片亮光。仿佛数以亿万计的荧光鱿鱼瞬间成为化石，沉入天空； 这篇童话描述了一段在银河铁道上从北十字星站到南十字星站的旅途，一段神奇美丽的星星之旅，可却让读者在故事里感受到一种强烈的孤独。 乔班尼像子弹一样奋力起身。为了不让其他人听见，他将身子伸出窗外，接着激动地吼叫、用力的捶胸，最后失声痛苦。他的世界仿佛陷入一片黑暗。 志同道合的妹妹（宫泽登志|敏子）的病逝，是宫泽贤治创作《银河铁道之夜》的契机. 「有传闻说，乔班尼和柯贝内拉在现实中是有其原形的。内向又孤独的乔班尼就是贤治自己，而柯贝内拉的原形虽然有很多种不同的说法，但是最为大家接受的则是贤治的妹妹登志。 登志比贤治还要小两岁，在学校里也经常是第一名，是一个优等生。贤治一直都为登志感到非常自豪，登志也一直仰慕着自己的哥哥。两人的感情非常的好，就连登志去东京上学的时候，两人的信件也不曾间断过。十八岁的时候，因为法华经而深受感悟的贤治，和热心于净土真宗的父亲产生了深刻的对立。而登志却相信了那样的贤治，成了贤治以外家中唯一信仰法华经的人，一直在背后支持着贤治。对于贤治来说，登志不仅仅是他的妹妹，还是与他共有思想和世界观的唯一的存在吧。」 在贤治二十六岁的冬天，他如此喜爱着的妹妹登志，因为疾病而过世了……贤治把当时所受到的打击，在『永诀的早晨』、『松之针』、『无声恸哭』等几首诗中写了出来。那是连灵魂都流出鲜血，连声音都发不出来的绝望哀叫，让人觉得胸口也要崩溃了一样……然后，在失去了『唯一一个拥有相同信仰的同伴』之后的两年里，贤治写下了《银河铁道之夜》的初稿…… 他竭力去创作一个“能让所有人幸福”的乌托邦、一幅人类的“永恒世界”，并且自己为此“宁愿舍弃这一切的幸福”。失去亲伴的悲痛让他产生无比强烈的愿望、舍弃一切的冲动、生与死的思考，”蝎之火“、因沉船遇难的青年、主人公“乔班尼(Giovanni )”以及故事的另一个主人公“柯贝内拉(Campanella)”都能体现出作者自己的愿望。 宫泽贤治在诗歌《永诀之朝》中写道： 面对你所渴求的那两碗雪， 我衷心的祈祷着。 愿它变成上天的赐予， 为你和大家， 得到神圣的粮食 我宁愿舍弃这一切的幸福 到底大家真正的幸福是什么？这是《银河铁道之夜》中宫泽贤治对幸福的探究与心中的迷惘。乔班尼的幸福，是和最好的朋友“无论到哪里，我们都要一起去”，而柯贝内拉的幸福，仅是做好事，牺牲自己奉献他人吗？ 《文少》中这样提问： 「……你觉得柯贝内拉的愿望，是什么呢？」 乔班尼和柯贝内拉的愿望相互纠缠，或许他们是同一个人也说不定，而贤治和登志，谁是乔班尼，谁又是柯贝内拉呢，或许二者没有关联，但总能从这童话里看到他们模糊的影子。 诗人与作词家败北少年之歌(败れし少年の歌へる) 是咏叹宫泽贤治在海边看到破晓时分的景象的一首诗，改编自贤治在三陆旅行时写下的《对晓穹之嫉妒》，这首诗收录在《春与修罗》的第二集里。 如下： 闪耀在拂晓的星光 「 ひかりわななくあけぞらに 」犹如蓝宝石般散发着光芒 「 清丽サフィアのさまなして 」可与你相比的它 「 きみにたぐへるかの惑星(ほし)の 」给人即将消失于天空的悲伤 「 いま融け行くぞかなしけれ 」 覆盖在松柏上的白雪 「 雪をかぶれるびゃくしんや 」与无数的海峡被黎明点亮 「 百の海岬いま明けて 」一望无际的深蓝大海 「 あをうなばらは万叶の 」被悠远的曲调所吸引 「 古きしらべにひかれるを 」 夜晚被层层乌云覆盖 「 夜はあやしき积云の 」却从中闪耀出星星的光辉 「 なかより生れてかの星ぞ 」就如你那动人的语句 「 さながらきみのことばもて 」在我内心燃烧 「 われをこととひ燃えけるを 」 就如最美丽的宝石 「 よきロダイトのさまなして 」却在拂晓的天空中 「 ひかりわなゝくかのそらに 」慢慢消失 「 溶け行くとしてひるがへる 」正因为你是星星才更让人悲伤 「 きみが星こそかなしけれ 」 《败北少年之歌》名字有些奇怪，似乎与内容并没有什么关联。不过，读过后确实发现其中宁静的败北，可能真如文少中提及，是首失恋的诗吧。（结合贤治本人的恋爱经历，这难道是写妹妹的？嗯哼？[#破事水]） 看到《败北少年之歌》这样的标题的时，虽然会让人有一种心跳的感觉，但读过之后就会明白，其实诗里并非是对伤痛和绝望的悲叹，而是又宁静又美丽的诗喔。遥望群星渐渐消失，远方天际缓缓发白，还带着一种悲伤的感觉……也有人说这是首失恋的诗歌。 不畏风雨(雨ニモマケズ) 大学毕业后，宫泽贤治任教四年，做农业指导，后来却辞职务农，离家在郊外独居，过着普通农民生活，乐在其中。 《文少》中关于宫泽贤治务农的介绍： 宫泽贤治是1896年出生在岩手县的诗人和童话作家。而且，他还有着农业指导家的身份，不仅开发了新的肥料，还经常在农村指导农民科学的农业和种植方法，又引进了当时岩手很少看到的郁金香、花椰菜、土豆等新品种。而且他还自学了风琴和大提琴，在当地举办一些演奏会，为当地文化的兴盛而努力着。 诗歌内容： 不怕风 不怕雨 不畏寒冬酷暑 总有强健的体魄 没有欲望 不生气 一直静静地笑着 每天只吃一些糙米、酱汤以及少于的蔬菜 对于包括自己在内的任何事情都无动于衷 耳闻目睹就已足够 然后不会忘记 在山野的松树林下的树荫里的小茅草屋里 就已足够安身 假若东边有生病的孩子 我便会前去看望 西边人家的母亲因干活而劳累 我会上前帮她背着成捆的稻草 南边若要有垂死之人 我便会给他说不用害怕 假若北边居住的人发生争执 我便会耐心劝解他们 太阳高照，大旱成灾时我会因此而伤心落泪 在酷暑炎夏里遇见寒潮我会因此而心急如焚 大家都叫我傻瓜 可我却不求赞扬 也不会将苦恼挂在心头 我想成为这样的人 永诀之朝(永诀の朝) 妹妹冬日病逝，这应当是宫泽贤治一生最痛苦的事情，他在这之后的1922年，写下了《永诀之朝》。 诗歌的部分如下： 我小心翼翼地站在那上面， 保持着雪与水那纯洁的联系， 满载着透明的冰冷安静的雪水， 从这闪烁着残微光亮的脆嫩松枝上， 为我那心爱的善良美好的妹妹取下那最后的渴求。 在伴随着我们一起长大的岁月里， 早已熟悉了这陶瓷碗上的蓝色花纹。 如是今朝却也要与你永诀， （我将独自前行） 在那封闭了的病房里， 在那昏暗的屏风和帐子里， 你正面色苍白温情脉脉地燃尽着生命 这首诗歌有些长，详见百度百科：永诀の朝 巡星之歌(星めぐりの歌) *星めぐりの歌 *(ほしめぐりのうた)是宫泽贤治创作的一首童谣，由宫泽贤治作词作曲，歌曲描绘在银河遨游看到的景色，星座与星座之间构成的美丽图画，在其作品《双子之星》和《银河铁路之夜》有出现，现在也常在各种影像作品中被引用。这首歌我最早在《星之梦》中就有所接触，虽说是个Galgame，当时并不知道宫泽贤治，也没读过《银河铁道之夜》。 *歌词如下：* あかいめだまの さそり 天蝎闪烁著红眼睛（天蝎座 Scorpio） ひろげた鷲の つばさ 天鹰展翅翱翔天际（天鹰座 Aquila） あをいめだまの 小いぬ、 小犬眨著蓝色眼眸（小犬座 Canis Minor） ひかりのへびの とぐろ。 蜷曲巨蛇隐隐透出光芒（蛇夫座 Ophiuchus） オリオンは高く うたひ 当猎户在天上高声歌唱时（猎户座 Orion） つゆとしもとを おとす、 地上便降下了露水和冰霜（猎户座的最佳观测时间在冬季） アンドロメダの くもは 仙女座中的云气（仙女座 Andromedae） さかなのくちの かたち。 宛如鱼的嘴形（仙女座大星云，椭圆形螺旋星云） 大ぐまのあしを きたに 从大熊前脚向北（大熊座 Ursae Majoris） 五つのばした ところ。 延伸五倍之处 小熊のひたいの うへは 在那小熊额顶（小熊座 Ursa Minor） そらのめぐりの めあて。 正是巡星游天的枢轴（北极星 Polaris） 宫泽贤治​ 宫泽贤治生前埋头文学，可写的童话无人问津，死后却声名显赫，这不禁让人联想到同样遭遇的梵高。他生前创作了94篇童话和一千多首诗歌，可只有《渡雪原》获得过稿费，出版的童话集《要求很多的餐馆》和诗歌集《春与修罗》还是自费出版的，并且沒卖出几本，贤治自己不忍心，向父亲借钱，自掏腰包买了两百本自己的书 ​ 关于贤治死后的成功，就要归功于弟弟宫泽清六的推动，弟弟与诗人草野心平等人编写了《追悼宫泽贤治》一书，并全部由宫泽家出资，将书出版，之后宫泽贤治的作品才被文坛所重视，引起世人瞩目。 ​ “父亲啊父亲，您为何故意要在舍监面前转动那块银表的发条呢？”，宫泽贤治身为富家子弟，却十分不满自家对穷人的剥削，身为长子，却并不想顺从父亲的意愿继承家业，虽说如此，父亲依然是他生前支持他文学创作的“出资人”。 ​ 大学毕业后就开始任教指导农民科学种田,之后又辞职务农，边与大自然接触边写童话诗歌，其实贤治早在盛冈高等农林学校读大三时便到岩手县种山平原进行过地质考察。当时贤治刚和朋友们一起创办了同人志『杜鹃花』，满怀着对与未来的理想和希望，每天都过着充实的生活。在这个人生最幸福的时期里感受到的美丽大自然，深深地印刻在贤治的心底，在贤治以后的作品中，也能看到很多与种山平原相关的痕迹。也有种说法，《银河铁道之夜》的星空便出自这个地方。 ​ 贤治一生未娶，高中时曾要与一名同年龄的护士结婚，被父亲拒绝，后又对大学同学以及妹妹敏子有疑似恋爱的情结，三十岁后拒绝女方两次，三十七岁因肺病早逝。]]></content>
      <categories>
        <category>作家</category>
      </categories>
      <tags>
        <tag>银河铁道之夜</tag>
        <tag>宫泽贤治</tag>
        <tag>文学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown练习（html版）]]></title>
    <url>%2F2019%2F06%2F13%2Fmarkdown%E8%AF%AD%E6%B3%95%E7%BB%83%E4%B9%A02%2F</url>
    <content type="text"><![CDATA[markdown语法练习html {overflow-x: initial !important;}:root { --bg-color:#ffffff; --text-color:#333333; --select-text-bg-color:#B5D6FC; --select-text-font-color:auto; --monospace:"Lucida Console",Consolas,"Courier",monospace; } html { font-size: 14px; background-color: var(--bg-color); color: var(--text-color); font-family: "Helvetica Neue", Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; } body { margin: 0px; padding: 0px; height: auto; bottom: 0px; top: 0px; left: 0px; right: 0px; font-size: 1rem; line-height: 1.42857; overflow-x: hidden; background: inherit; tab-size: 4; } iframe { margin: auto; } a.url { word-break: break-all; } a:active, a:hover { outline: 0px; } .in-text-selection, ::selection { text-shadow: none; background: var(--select-text-bg-color); color: var(--select-text-font-color); } #write { margin: 0px auto; height: auto; width: inherit; word-break: normal; word-wrap: break-word; position: relative; white-space: normal; overflow-x: visible; padding-top: 40px; } #write.first-line-indent p { text-indent: 2em; } #write.first-line-indent li p, #write.first-line-indent p * { text-indent: 0px; } #write.first-line-indent li { margin-left: 2em; } .for-image #write { padding-left: 8px; padding-right: 8px; } body.typora-export { padding-left: 30px; padding-right: 30px; } .typora-export .footnote-line, .typora-export li, .typora-export p { white-space: pre-wrap; } @media screen and (max-width: 500px) { body.typora-export { padding-left: 0px; padding-right: 0px; } #write { padding-left: 20px; padding-right: 20px; } .CodeMirror-sizer { margin-left: 0px !important; } .CodeMirror-gutters { display: none !important; } } #write li > figure:first-child { margin-top: -20px; } #write ol, #write ul { position: relative; } img { max-width: 100%; vertical-align: middle; } button, input, select, textarea { color: inherit; font-style: inherit; font-variant: inherit; font-weight: inherit; font-stretch: inherit; font-size: inherit; line-height: inherit; font-family: inherit; } input[type="checkbox"], input[type="radio"] { line-height: normal; padding: 0px; } *, ::after, ::before { box-sizing: border-box; } #write h1, #write h2, #write h3, #write h4, #write h5, #write h6, #write p, #write pre { width: inherit; } #write h1, #write h2, #write h3, #write h4, #write h5, #write h6, #write p { position: relative; } h1, h2, h3, h4, h5, h6 { break-after: avoid-page; break-inside: avoid; orphans: 2; } p { orphans: 4; } h1 { font-size: 2rem; } h2 { font-size: 1.8rem; } h3 { font-size: 1.6rem; } h4 { font-size: 1.4rem; } h5 { font-size: 1.2rem; } h6 { font-size: 1rem; } .md-math-block, .md-rawblock, h1, h2, h3, h4, h5, h6, p { margin-top: 1rem; margin-bottom: 1rem; } .hidden { display: none; } .md-blockmeta { color: rgb(204, 204, 204); font-weight: 700; font-style: italic; } a { cursor: pointer; } sup.md-footnote { padding: 2px 4px; background-color: rgba(238, 238, 238, 0.7); color: rgb(85, 85, 85); border-radius: 4px; cursor: pointer; } sup.md-footnote a, sup.md-footnote a:hover { color: inherit; text-transform: inherit; text-decoration: inherit; } #write input[type="checkbox"] { cursor: pointer; width: inherit; height: inherit; } figure { overflow-x: auto; margin: 1.2em 0px; max-width: calc(100% + 16px); padding: 0px; } figure > table { margin: 0px !important; } tr { break-inside: avoid; break-after: auto; } thead { display: table-header-group; } table { border-collapse: collapse; border-spacing: 0px; width: 100%; overflow: auto; break-inside: auto; text-align: left; } table.md-table td { min-width: 32px; } .CodeMirror-gutters { border-right: 0px; background-color: inherit; } .CodeMirror-linenumber { user-select: none; } .CodeMirror { text-align: left; } .CodeMirror-placeholder { opacity: 0.3; } .CodeMirror pre { padding: 0px 4px; } .CodeMirror-lines { padding: 0px; } div.hr:focus { cursor: none; } #write pre { white-space: pre-wrap; } #write.fences-no-line-wrapping pre { white-space: pre; } #write pre.ty-contain-cm { white-space: normal; } .CodeMirror-gutters { margin-right: 4px; } .md-fences { font-size: 0.9rem; display: block; break-inside: avoid; text-align: left; overflow: visible; white-space: pre; background: inherit; position: relative !important; } .md-diagram-panel { width: 100%; margin-top: 10px; text-align: center; padding-top: 0px; padding-bottom: 8px; overflow-x: auto; } #write .md-fences.mock-cm { white-space: pre-wrap; } .md-fences.md-fences-with-lineno { padding-left: 0px; } #write.fences-no-line-wrapping .md-fences.mock-cm { white-space: pre; overflow-x: auto; } .md-fences.mock-cm.md-fences-with-lineno { padding-left: 8px; } .CodeMirror-line, twitterwidget { break-inside: avoid; } .footnotes { opacity: 0.8; font-size: 0.9rem; margin-top: 1em; margin-bottom: 1em; } .footnotes + .footnotes { margin-top: 0px; } .md-reset { margin: 0px; padding: 0px; border: 0px; outline: 0px; vertical-align: top; background: 0px 0px; text-decoration: none; text-shadow: none; float: none; position: static; width: auto; height: auto; white-space: nowrap; cursor: inherit; -webkit-tap-highlight-color: transparent; line-height: normal; font-weight: 400; text-align: left; box-sizing: content-box; direction: ltr; } li div { padding-top: 0px; } blockquote { margin: 1rem 0px; } li .mathjax-block, li p { margin: 0.5rem 0px; } li { margin: 0px; position: relative; } blockquote > :last-child { margin-bottom: 0px; } blockquote > :first-child, li > :first-child { margin-top: 0px; } .footnotes-area { color: rgb(136, 136, 136); margin-top: 0.714rem; padding-bottom: 0.143rem; white-space: normal; } #write .footnote-line { white-space: pre-wrap; } @media print { body, html { border: 1px solid transparent; height: 99%; break-after: avoid; break-before: avoid; } #write { margin-top: 0px; padding-top: 0px; border-color: transparent !important; } .typora-export * { -webkit-print-color-adjust: exact; } html.blink-to-pdf { font-size: 13px; } .typora-export #write { padding-left: 32px; padding-right: 32px; padding-bottom: 0px; break-after: avoid; } .typora-export #write::after { height: 0px; } @page { margin: 20mm 0px; } } .footnote-line { margin-top: 0.714em; font-size: 0.7em; } a img, img a { cursor: pointer; } pre.md-meta-block { font-size: 0.8rem; min-height: 0.8rem; white-space: pre-wrap; background: rgb(204, 204, 204); display: block; overflow-x: hidden; } p > .md-image:only-child:not(.md-img-error) img, p > img:only-child { display: block; margin: auto; } p > .md-image:only-child { display: inline-block; width: 100%; } #write .MathJax_Display { margin: 0.8em 0px 0px; } .md-math-block { width: 100%; } .md-math-block:not(:empty)::after { display: none; } [contenteditable="true"]:active, [contenteditable="true"]:focus { outline: 0px; box-shadow: none; } .md-task-list-item { position: relative; list-style-type: none; } .task-list-item.md-task-list-item { padding-left: 0px; } .md-task-list-item > input { position: absolute; top: 0px; left: 0px; margin-left: -1.2em; margin-top: calc(1em - 10px); border: none; } .math { font-size: 1rem; } .md-toc { min-height: 3.58rem; position: relative; font-size: 0.9rem; border-radius: 10px; } .md-toc-content { position: relative; margin-left: 0px; } .md-toc-content::after, .md-toc::after { display: none; } .md-toc-item { display: block; color: rgb(65, 131, 196); } .md-toc-item a { text-decoration: none; } .md-toc-inner:hover { text-decoration: underline; } .md-toc-inner { display: inline-block; cursor: pointer; } .md-toc-h1 .md-toc-inner { margin-left: 0px; font-weight: 700; } .md-toc-h2 .md-toc-inner { margin-left: 2em; } .md-toc-h3 .md-toc-inner { margin-left: 4em; } .md-toc-h4 .md-toc-inner { margin-left: 6em; } .md-toc-h5 .md-toc-inner { margin-left: 8em; } .md-toc-h6 .md-toc-inner { margin-left: 10em; } @media screen and (max-width: 48em) { .md-toc-h3 .md-toc-inner { margin-left: 3.5em; } .md-toc-h4 .md-toc-inner { margin-left: 5em; } .md-toc-h5 .md-toc-inner { margin-left: 6.5em; } .md-toc-h6 .md-toc-inner { margin-left: 8em; } } a.md-toc-inner { font-size: inherit; font-style: inherit; font-weight: inherit; line-height: inherit; } .footnote-line a:not(.reversefootnote) { color: inherit; } .md-attr { display: none; } .md-fn-count::after { content: "."; } code, pre, samp, tt { font-family: var(--monospace); } kbd { margin: 0px 0.1em; padding: 0.1em 0.6em; font-size: 0.8em; color: rgb(36, 39, 41); background: rgb(255, 255, 255); border: 1px solid rgb(173, 179, 185); border-radius: 3px; box-shadow: rgba(12, 13, 14, 0.2) 0px 1px 0px, rgb(255, 255, 255) 0px 0px 0px 2px inset; white-space: nowrap; vertical-align: middle; } .md-comment { color: rgb(162, 127, 3); opacity: 0.8; font-family: var(--monospace); } code { text-align: left; vertical-align: initial; } a.md-print-anchor { white-space: pre !important; border-width: initial !important; border-style: none !important; border-color: initial !important; display: inline-block !important; position: absolute !important; width: 1px !important; right: 0px !important; outline: 0px !important; background: 0px 0px !important; text-decoration: initial !important; text-shadow: initial !important; } .md-inline-math .MathJax_SVG .noError { display: none !important; } .html-for-mac .inline-math-svg .MathJax_SVG { vertical-align: 0.2px; } .md-math-block .MathJax_SVG_Display { text-align: center; margin: 0px; position: relative; text-indent: 0px; max-width: none; max-height: none; min-height: 0px; min-width: 100%; width: auto; overflow-y: hidden; display: block !important; } .MathJax_SVG_Display, .md-inline-math .MathJax_SVG_Display { width: auto; margin: inherit; display: inline-block !important; } .MathJax_SVG .MJX-monospace { font-family: var(--monospace); } .MathJax_SVG .MJX-sans-serif { font-family: sans-serif; } .MathJax_SVG { display: inline; font-style: normal; font-weight: 400; line-height: normal; zoom: 90%; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; } .MathJax_SVG * { transition: none; } .MathJax_SVG_Display svg { vertical-align: middle !important; margin-bottom: 0px !important; } .os-windows.monocolor-emoji .md-emoji { font-family: "Segoe UI Symbol", sans-serif; } .md-diagram-panel > svg { max-width: 100%; } [lang="mermaid"] svg, [lang="flow"] svg { max-width: 100%; } [lang="mermaid"] .node text { font-size: 1rem; } table tr th { border-bottom: 0px; } video { max-width: 100%; display: block; margin: 0px auto; } iframe { max-width: 100%; width: 100%; border: none; } .highlight td, .highlight tr { border: 0px; } .CodeMirror { height: auto; } .CodeMirror.cm-s-inner { background: inherit; } .CodeMirror-scroll { overflow-y: hidden; overflow-x: auto; z-index: 3; } .CodeMirror-gutter-filler, .CodeMirror-scrollbar-filler { background-color: rgb(255, 255, 255); } .CodeMirror-gutters { border-right: 1px solid rgb(221, 221, 221); background: inherit; white-space: nowrap; } .CodeMirror-linenumber { padding: 0px 3px 0px 5px; text-align: right; color: rgb(153, 153, 153); } .cm-s-inner .cm-keyword { color: rgb(119, 0, 136); } .cm-s-inner .cm-atom, .cm-s-inner.cm-atom { color: rgb(34, 17, 153); } .cm-s-inner .cm-number { color: rgb(17, 102, 68); } .cm-s-inner .cm-def { color: rgb(0, 0, 255); } .cm-s-inner .cm-variable { color: rgb(0, 0, 0); } .cm-s-inner .cm-variable-2 { color: rgb(0, 85, 170); } .cm-s-inner .cm-variable-3 { color: rgb(0, 136, 85); } .cm-s-inner .cm-string { color: rgb(170, 17, 17); } .cm-s-inner .cm-property { color: rgb(0, 0, 0); } .cm-s-inner .cm-operator { color: rgb(152, 26, 26); } .cm-s-inner .cm-comment, .cm-s-inner.cm-comment { color: rgb(170, 85, 0); } .cm-s-inner .cm-string-2 { color: rgb(255, 85, 0); } .cm-s-inner .cm-meta { color: rgb(85, 85, 85); } .cm-s-inner .cm-qualifier { color: rgb(85, 85, 85); } .cm-s-inner .cm-builtin { color: rgb(51, 0, 170); } .cm-s-inner .cm-bracket { color: rgb(153, 153, 119); } .cm-s-inner .cm-tag { color: rgb(17, 119, 0); } .cm-s-inner .cm-attribute { color: rgb(0, 0, 204); } .cm-s-inner .cm-header, .cm-s-inner.cm-header { color: rgb(0, 0, 255); } .cm-s-inner .cm-quote, .cm-s-inner.cm-quote { color: rgb(0, 153, 0); } .cm-s-inner .cm-hr, .cm-s-inner.cm-hr { color: rgb(153, 153, 153); } .cm-s-inner .cm-link, .cm-s-inner.cm-link { color: rgb(0, 0, 204); } .cm-negative { color: rgb(221, 68, 68); } .cm-positive { color: rgb(34, 153, 34); } .cm-header, .cm-strong { font-weight: 700; } .cm-del { text-decoration: line-through; } .cm-em { font-style: italic; } .cm-link { text-decoration: underline; } .cm-error { color: red; } .cm-invalidchar { color: red; } .cm-constant { color: rgb(38, 139, 210); } .cm-defined { color: rgb(181, 137, 0); } div.CodeMirror span.CodeMirror-matchingbracket { color: rgb(0, 255, 0); } div.CodeMirror span.CodeMirror-nonmatchingbracket { color: rgb(255, 34, 34); } .cm-s-inner .CodeMirror-activeline-background { background: inherit; } .CodeMirror { position: relative; overflow: hidden; } .CodeMirror-scroll { height: 100%; outline: 0px; position: relative; box-sizing: content-box; background: inherit; } .CodeMirror-sizer { position: relative; } .CodeMirror-gutter-filler, .CodeMirror-hscrollbar, .CodeMirror-scrollbar-filler, .CodeMirror-vscrollbar { position: absolute; z-index: 6; display: none; } .CodeMirror-vscrollbar { right: 0px; top: 0px; overflow: hidden; } .CodeMirror-hscrollbar { bottom: 0px; left: 0px; overflow: hidden; } .CodeMirror-scrollbar-filler { right: 0px; bottom: 0px; } .CodeMirror-gutter-filler { left: 0px; bottom: 0px; } .CodeMirror-gutters { position: absolute; left: 0px; top: 0px; padding-bottom: 30px; z-index: 3; } .CodeMirror-gutter { white-space: normal; height: 100%; box-sizing: content-box; padding-bottom: 30px; margin-bottom: -32px; display: inline-block; } .CodeMirror-gutter-wrapper { position: absolute; z-index: 4; background: 0px 0px !important; border: none !important; } .CodeMirror-gutter-background { position: absolute; top: 0px; bottom: 0px; z-index: 4; } .CodeMirror-gutter-elt { position: absolute; cursor: default; z-index: 4; } .CodeMirror-lines { cursor: text; } .CodeMirror pre { border-radius: 0px; border-width: 0px; background: 0px 0px; font-family: inherit; font-size: inherit; margin: 0px; white-space: pre; word-wrap: normal; color: inherit; z-index: 2; position: relative; overflow: visible; } .CodeMirror-wrap pre { word-wrap: break-word; white-space: pre-wrap; word-break: normal; } .CodeMirror-code pre { border-right: 30px solid transparent; width: fit-content; } .CodeMirror-wrap .CodeMirror-code pre { border-right: none; width: auto; } .CodeMirror-linebackground { position: absolute; left: 0px; right: 0px; top: 0px; bottom: 0px; z-index: 0; } .CodeMirror-linewidget { position: relative; z-index: 2; overflow: auto; } .CodeMirror-wrap .CodeMirror-scroll { overflow-x: hidden; } .CodeMirror-measure { position: absolute; width: 100%; height: 0px; overflow: hidden; visibility: hidden; } .CodeMirror-measure pre { position: static; } .CodeMirror div.CodeMirror-cursor { position: absolute; visibility: hidden; border-right: none; width: 0px; } .CodeMirror div.CodeMirror-cursor { visibility: hidden; } .CodeMirror-focused div.CodeMirror-cursor { visibility: inherit; } .cm-searching { background: rgba(255, 255, 0, 0.4); } @media print { .CodeMirror div.CodeMirror-cursor { visibility: hidden; } } :root { --side-bar-bg-color: #fafafa; --control-text-color: #777; } html { font-size: 16px; } body { font-family: "Open Sans", "Clear Sans", "Helvetica Neue", Helvetica, Arial, sans-serif; color: rgb(51, 51, 51); line-height: 1.6; } #write { max-width: 860px; margin: 0px auto; padding: 30px 30px 100px; } #write > ul:first-child, #write > ol:first-child { margin-top: 30px; } a { color: rgb(65, 131, 196); } h1, h2, h3, h4, h5, h6 { position: relative; margin-top: 1rem; margin-bottom: 1rem; font-weight: bold; line-height: 1.4; cursor: text; } h1:hover a.anchor, h2:hover a.anchor, h3:hover a.anchor, h4:hover a.anchor, h5:hover a.anchor, h6:hover a.anchor { text-decoration: none; } h1 tt, h1 code { font-size: inherit; } h2 tt, h2 code { font-size: inherit; } h3 tt, h3 code { font-size: inherit; } h4 tt, h4 code { font-size: inherit; } h5 tt, h5 code { font-size: inherit; } h6 tt, h6 code { font-size: inherit; } h1 { padding-bottom: 0.3em; font-size: 2.25em; line-height: 1.2; border-bottom: 1px solid rgb(238, 238, 238); } h2 { padding-bottom: 0.3em; font-size: 1.75em; line-height: 1.225; border-bottom: 1px solid rgb(238, 238, 238); } h3 { font-size: 1.5em; line-height: 1.43; } h4 { font-size: 1.25em; } h5 { font-size: 1em; } h6 { font-size: 1em; color: rgb(119, 119, 119); } p, blockquote, ul, ol, dl, table { margin: 0.8em 0px; } li > ol, li > ul { margin: 0px; } hr { height: 2px; padding: 0px; margin: 16px 0px; background-color: rgb(231, 231, 231); border: 0px none; overflow: hidden; box-sizing: content-box; } li p.first { display: inline-block; } ul, ol { padding-left: 30px; } ul:first-child, ol:first-child { margin-top: 0px; } ul:last-child, ol:last-child { margin-bottom: 0px; } blockquote { border-left: 4px solid rgb(223, 226, 229); padding: 0px 15px; color: rgb(119, 119, 119); } blockquote blockquote { padding-right: 0px; } table { padding: 0px; word-break: initial; } table tr { border-top: 1px solid rgb(223, 226, 229); margin: 0px; padding: 0px; } table tr:nth-child(2n), thead { background-color: rgb(248, 248, 248); } table tr th { font-weight: bold; border-width: 1px 1px 0px; border-top-style: solid; border-right-style: solid; border-left-style: solid; border-top-color: rgb(223, 226, 229); border-right-color: rgb(223, 226, 229); border-left-color: rgb(223, 226, 229); border-image: initial; border-bottom-style: initial; border-bottom-color: initial; text-align: left; margin: 0px; padding: 6px 13px; } table tr td { border: 1px solid rgb(223, 226, 229); text-align: left; margin: 0px; padding: 6px 13px; } table tr th:first-child, table tr td:first-child { margin-top: 0px; } table tr th:last-child, table tr td:last-child { margin-bottom: 0px; } .CodeMirror-lines { padding-left: 4px; } .code-tooltip { box-shadow: rgba(0, 28, 36, 0.3) 0px 1px 1px 0px; border-top: 1px solid rgb(238, 242, 242); } .md-fences, code, tt { border: 1px solid rgb(231, 234, 237); background-color: rgb(248, 248, 248); border-radius: 3px; padding: 2px 4px 0px; font-size: 0.9em; } code { background-color: rgb(243, 244, 244); padding: 0px 2px; } .md-fences { margin-bottom: 15px; margin-top: 15px; padding-top: 8px; padding-bottom: 6px; } .md-task-list-item > input { margin-left: -1.3em; } @media print { html { font-size: 13px; } table, pre { break-inside: avoid; } pre { word-wrap: break-word; } } .md-fences { background-color: rgb(248, 248, 248); } #write pre.md-meta-block { padding: 1rem; font-size: 85%; line-height: 1.45; background-color: rgb(247, 247, 247); border: 0px; border-radius: 3px; color: rgb(119, 119, 119); margin-top: 0px !important; } .mathjax-block > .code-tooltip { bottom: 0.375rem; } .md-mathjax-midline { background: rgb(250, 250, 250); } #write > h3.md-focus::before { left: -1.5625rem; top: 0.375rem; } #write > h4.md-focus::before { left: -1.5625rem; top: 0.285714rem; } #write > h5.md-focus::before { left: -1.5625rem; top: 0.285714rem; } #write > h6.md-focus::before { left: -1.5625rem; top: 0.285714rem; } .md-image > .md-meta { border-radius: 3px; padding: 2px 0px 0px 4px; font-size: 0.9em; color: inherit; } .md-tag { color: rgb(167, 167, 167); opacity: 1; } .md-toc { margin-top: 20px; padding-bottom: 20px; } .sidebar-tabs { border-bottom: none; } #typora-quick-open { border: 1px solid rgb(221, 221, 221); background-color: rgb(248, 248, 248); } #typora-quick-open-item { background-color: rgb(250, 250, 250); border-color: rgb(254, 254, 254) rgb(229, 229, 229) rgb(229, 229, 229) rgb(238, 238, 238); border-style: solid; border-width: 1px; } .on-focus-mode blockquote { border-left-color: rgba(85, 85, 85, 0.12); } header, .context-menu, .megamenu-content, footer { font-family: "Segoe UI", Arial, sans-serif; } .file-node-content:hover .file-node-icon, .file-node-content:hover .file-node-open-state { visibility: visible; } .mac-seamless-mode #typora-sidebar { background-color: var(--side-bar-bg-color); } .md-lang { color: rgb(180, 101, 77); } .html-for-mac .context-menu { --item-hover-bg-color: #E6F0FE; } #md-notification .btn { border: 0px; } .dropdown-menu .divider { border-color: rgb(229, 229, 229); } .typora-export li, .typora-export p, .typora-export, .footnote-line {white-space: normal;} 学生目录：Markdown一二三四与 五六七八九十1. 引文、注释2. 链接3. 图片4. 简单表格5.高亮、顔色等6. 列表、代码块前往我的Blog首页↩&nbsp;一二三四与 五六七八九十&nbsp;1. 引文、注释「拉威福特的《因斯茅斯上空的阴影》1尝起来，就像是在啜饮生鱼血一样呢~」（啦啦啦啦啦啦啦啦啦啦啦哇哈哈哈哈哈哈）&nbsp;&nbsp;2. 链接百度百科: 拉威福特详情&nbsp;3. 图片&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;4. 简单表格&nbsp;快捷键功能Ctrl+C复制Ctrl+X剪切Ctrl+V粘贴&nbsp;5.高亮、顔色等&nbsp;「关于作者霍华德·菲利普·拉威福特，他是1890年生的美国作家，他在世时曾经写下了许多关于太古诸神复活的故事，这些故事在他去世以后被体系化，最终形成了所谓的『克苏鲁神话体系』。自那以来，有很多作家被这种阴暗凄惨的黑暗神话所吸引，以克苏鲁为主题写下了不计其数的文章呢。在故事中登场的诸神，都是长相奇怪的海洋生物，长着触手、鱼鳍啊什么的，散发着生腥味。」&nbsp;6. 列表、代码块&nbsp;html jsjavapython等等xxxxxxxxxx41&lt;span class="post-meta-item-text"&gt;评论数：2 &lt;a href="/2019/06/13/markdown练习/#comments" itemprop="discussionUrl"&gt;3 &lt;/a&gt;4 &lt;/span&gt;&nbsp;前往我的Blog首页↩&nbsp; 1 拉威福特，全名H. P. Lovecraft，1890-1937，恐怖小说作家，《因斯茅斯上空的阴影》（The Shadow Over Innsmouth），为其代表作之一。↩]]></content>
      <categories>
        <category>学习经验</category>
      </categories>
      <tags>
        <tag>-markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Yahoo~!]]></title>
    <url>%2F2019%2F06%2F11%2FYahoo%2F</url>
    <content type="text"><![CDATA[域名&amp;..第一个公网访问的博客改造ing，是基于nodejs的一个网站，用来记一些东西吧，也方便查看。外观风格想做简约可又喜欢乱加东西，搞得不是很美观，暂时用别人的主题做基础，以后慢慢弄吧。现在域名为 Shirtiny.cn 6.13 增加标签、友链、分类、归档、404页面、搜索功能 6.17 增加头像挂件、社交链接 6.18 增加看板娘【随便拉来打工的】 7.16 调整整体色调、不由自主的加了些挂件、增加Valine评论系统 7.29 把Valine换成Gitment【越来越懒】 8.03 拉出来改了下bug、尝试调试移动端适配（放弃）、追加内建标签【想换Spring Boot做了】 8.06 增加视频播放标签 域名购买： 腾讯云 域名解析： DNSPOD 搭建Hexo：哔哩哔哩教程 域名绑定：CN博客教程 解决部署使：CName消失的问题]]></content>
      <categories>
        <category>闲谈</category>
      </categories>
      <tags>
        <tag>开局第一篇 - 测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[说 明]]></title>
    <url>%2F2019%2F06%2F11%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Hello HexoQuick Start Create a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
