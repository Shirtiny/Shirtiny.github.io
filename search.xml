<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[SolrCloud、ZooKeeper]]></title>
    <url>%2F2019%2F09%2F05%2FSolrCloud%2F</url>
    <content type="text"><![CDATA[ZooKeeper、Solr集群搭建系统环境： CentOS 7、JDK1.7、solr4、zookeeper3.4.6 zookeeper集群zookeeper半数投票，所以最少3个，与solr集群的关系如图： 集群搭建（伪）在一台机器上模拟集群： 解压zookeeper，tar -zxvf zookeeper-3.4.6.tar.gz将zookeeper-3.4.6拷贝到/usr/local/solrcloud下，复制三份分别并将目录名改为zookeeper1、zookeeper2、zookeeper3 进入zookeeper1文件夹，创建data目录。并在data目录中创建一个myid文件内容为“1”（echo 1 &gt;&gt; data/myid）。 进入conf文件夹，把zoo_sample.cfg改名为zoo.cfg 修改zoo.cfg。 修改： dataDir=/usr/local/solrcloud/zookeeper1/data clientPort=2181（zookeeper2中为2182、zookeeper3中为2183） 添加： server.1=192.168.25.154:2881:3881 server.2=192.168.25.154:2882:3882 server.3=192.168.25.154:2883:3883 12345678910111213141516171819202122232425262728293031# The number of milliseconds of each ticktickTime=2000# The number of ticks that the initial # synchronization phase can takeinitLimit=10# The number of ticks that can pass between # sending a request and getting an acknowledgementsyncLimit=5# the directory where the snapshot is stored.# do not use /tmp for storage, /tmp here is just # example sakes.dataDir=/usr/local/solrcloud/zookeeper1/data# the port at which the clients will connectclientPort=2181# the maximum number of client connections.# increase this if you need to handle more clients#maxClientCnxns=60## Be sure to read the maintenance section of the # administrator guide before turning on autopurge.## http://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_maintenance## The number of snapshots to retain in dataDir#autopurge.snapRetainCount=3# Purge task interval in hours# Set to "0" to disable auto purge feature#autopurge.purgeInterval=1server.1=192.168.25.154:2881:3881server.2=192.168.25.154:2882:3882server.3=192.168.25.154:2883:3883 对zookeeper2、3中的设置做第二步至第四步修改。 zookeeper2、3 myid内容为2、3 dataDir=/usr/local/solrcloud/zookeeper2、3/data clientPort=2182、2183 启动三个zookeeper 123/usr/local/solrcloud/zookeeper1/bin/zkServer.sh start/usr/local/solrcloud/zookeeper2/bin/zkServer.sh start/usr/local/solrcloud/zookeeper3/bin/zkServer.sh start 查看集群状态： 123/usr/local/solrcloud/zookeeper1/bin/zkServer.sh status/usr/local/solrcloud/zookeeper2/bin/zkServer.sh status/usr/local/solrcloud/zookeeper3/bin/zkServer.sh status 开启zookeeper用到的端口，或者直接关闭防火墙。 1service iptables stop Solr集群集群图示如，这个solr集群中有3台服务器，每个服务器的solr有两个core。 数据索引集合分成2片，由3台服务器各出一个core来组成1个分片，即1个分片=3个core，这三个core数据一致。共6个core两个分片，一个索引集合。在1个数据分片中，有1个core被zookeeper选为主服务节点，其他两个core作为从服务节点。 集群搭建（伪）在一台机器上模拟集群： 先在一台机器上模拟出3个solr实例，和单机版solr搭建一致，以前说过，此处省略。 solrCloud部署依赖zookeeper，需要先启动每一台zookeeper服务器。 由于zookeeper统一管理solr的配置文件（主要是schema.xml、solrconfig.xml）， solrCloud各各节点使用zookeeper管理的配置文件。 将上边部署的solr单机的conf拷贝到/home/solr下。 执行下边的这条命令将/home/solr/conf下的配置文件上传到zookeeper。此命令在solr-4.10.3/example/scripts/cloud-scripts/目录下： 1./zkcli.sh -zkhost 192.168.25.154:2181,192.168.25.154:2182,192.168.25.154:2183 -cmd upconfig -confdir /usr/local/solrcloud/solrhome1/collection1/conf -confname myconf 登陆zookeeper服务器查询配置文件： 12cd /usr/local/zookeeper/bin/./zkCli.sh 修改每个solrhome的solr.xml文件。将host改成虚拟机ip地址，port改成对应的tomcat的端口号。 修改每一台solr的tomcat 的 bin目录下catalina.sh文件中加入DzkHost指定zookeeper服务器地址： 12JAVA_OPTS="-DzkHost=192.168.25.154:2181,192.168.25.154:2182,192.168.25.154:2183"#（可以使用vim的查找功能查找到JAVA_OPTS的定义的位置，然后添加） 启动每一台solr的tomcat服务，访问任意一台solr，左侧菜单会出现Cloud选项： 可在Cloud选项查看集群状态。 分片 如果集群中有四个solr节点创建新集群collection2，将集群分为两片，每片两个副本。 1http://yourIpAndProt/solr/admin/collections?action=CREATE&amp;name=collection2&amp;numShards=2&amp;replicationFactor=2 删除 1http://yourIpAndPort/solr/admin/collections?action=DELETE&amp;name=collection1 执行后原来的collection1删除 更多命令请百度。]]></content>
      <categories>
        <category>学习经验</category>
      </categories>
      <tags>
        <tag>Solr</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单链表、双向链表、单向环形链表]]></title>
    <url>%2F2019%2F09%2F05%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E5%8D%95%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[数据结构与算法链表LinkedList 链表是有序列表，但其在内存中并非有序存储，如单链表： 以节点的方式，链式存储。按实际需求，也有无头节点的链表。 1. 单链表SingleLinkedList单链表逻辑结构： 每个节点都包含两个域 data域，用来存储数据对象 next域，指向下一个节点 head头节点，不存放具体数据，只表示单链表的头，不能移动 尾节点，即链表最后的一个节点，next域为null 分析 首先会创建一个头结点，data域为空，next域为空得出结论，当head头节点的next域为空时，单链表为空向链表中加入一个节点：找到尾节点使尾节点的next域指向此节点尾节点的next域始终为空所以，除了head节点以外，当节点next域为空时，此节点为尾节点 联想 考虑节点排序时，向链表加入一个节点：找到编号大于新加入节点的节点，即满足linkedNode.id&gt;newNode.id的节点执行插入，将此节点放在新节点的next域，然后把新节点放入上一节点的next域，即newNode.next=linkedNode;linkedNode.pre.next=newNode;//而实际上linkedNode.pre是不存在的，因为单链表的节点只有next域，不能用当前节点表示上一个节点//设linkedNode的上一个节点为preNode==linkedNode.pre//则可以把linkedNode表示为pretNode.next，所以上面2个语句为：newNode.next=preNode.next;preNode.next=newNode;删除一个节点找到编号等于指定编号的节点，即满足linkedNode.id==deleteId的节点执行删除，用此节点的后一节点，顶替此节点的位置，即linkedNode.pre.next=linkedNode.next;//同理，设linkedNode的上一个节点为preNode==linkedNode.pre，则有：preNode.next=preNode.next.next;//此时在链表外的linkedNode成了不被引用的对象，会被JVM垃圾回收机制自动回收修改节点信息根据id找到对应节点，修改data域信息即可。统计单链表内有效节点的个数size让temp从第一个有效节点head.next开始遍历，计数即可。查找到单链表中倒数第n个节点需要先获得链表有效节点的个数size第(size-n+1)个节点，便是倒数第n个节点反转单链表，即：假如有节点为1234的链表，将它反转为4321创建一个新的头结点newHead，用来作为新链表的头遍历原链表时，将当前链表的节点放入newHead与newHead后一个节点之间遍历原链表时，需要保存当前节点的下一个节点，以便返回到原链表最后遍历完成后，将新节点的第一个有效节点，放入原head节点的next域逆序打印单链表遍历时，把单链表中节点压入栈中，然后再从栈中取出的节点并打印即可。合并两个有序的单链表，使之仍然有序（示例中为由小到大）初始化temp1为链表1的第一个有效节点。而temp2为链表2的头结点将链表1放入链表2中，使temp2不断后移。在找到temp1的插入位置后，temp1才后移。若直到temp2后移到末尾都没有找到temp1能插入的位置，则把temp1置于temp2末尾，结束循环。取出链表中所有节点的集合遍历取出，使用List集合注意，取出时要把每个节点的next域置为空，注意临时保存断掉的链表，以及循环退出条件按顺序批量添加节点foreach遍历上面方法取出的节点集合，然后调用排序添加节点的方法即可。使一个无序链表转换为有序列表（示例中为由小到大）与上面的方法结合，就可以实现2个无序列表合并到1个有序列表 单链表java实现Node节点类 123456789101112131415161718192021222324252627282930313233package LinkedList;public class Node &#123; //data int id; String name; Node next;//next Node pre;//pre，单链表不用 //构造器 public Node() &#123; &#125; public Node(int id, String name) &#123; this.id = id; this.name = name; &#125; public Node(int id, String name, Node next) &#123; this.id = id; this.name = name; this.next = next; &#125; @Override//重写toString方法，注意，无需打印next和pre public String toString() &#123; return "Node&#123;" + "id=" + id + ", name='" + name + '\'' + '&#125;'; &#125; //setter&amp;getter，我在单向链表中直接对属性操作，在双向链表中使用set方法，目的是产生对比，让读者体会方法封装的可读性和便利性。&#125; 单链表类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296package LinkedList;public class SingleLinkedList &#123; private Node headNode=new Node();//头节点 private Node temp;//设一个过渡节点，初始为头节点 //获取头节点 public Node getHeadNode()&#123; return this.headNode; &#125; //判断链表是否为空 public boolean isNonNode()&#123; return headNode.next == null; &#125; //添加Node(不考虑排序) public void addNode(Node node)&#123; temp=headNode;//初始化temp //找到尾节点 while (true)&#123; //判断过渡节点的next域是否为空 if (temp.next==null)&#123; temp.next=node; break;//找到next域为空的节点，便退出循环 &#125;else &#123; //否则temp后移一个节点 temp=temp.next; &#125; &#125; &#125; //添加Node，考虑排序 public void addNodeByOrder(Node node)&#123; temp=headNode;//初始化temp while(true)&#123; if (temp.next==null)&#123;//此时链表为空或已到链表末尾 //直接添加节点 temp.next=node; break; &#125;else if (temp.next.id&gt;node.id)&#123;//此时temp与temp.next之间的位置，便是node应该插入的位置 node.next=temp.next;//将temp.next，变成node的后一个节点 temp.next=node;//将node，作为temp的后一个节点 break; &#125;else if (temp.next.id==node.id)&#123; System.out.println("该编号的节点已经存在"); break; &#125; temp=temp.next;//以上都不满足，后移temp &#125; //删除节点 public void deleteNode(int id)&#123; temp=headNode;//初始化temp while (true)&#123; if (temp.next==null)&#123; System.out.println("链表中没找到要删除的节点"); break; &#125;else if (temp.next.id==id)&#123; temp.next=temp.next.next;//用要删除节点的后一个节点，替换要删除的节点 //不被引用的对象，会被JVM垃圾回收机制自动回收 System.out.println("删除"+id+"号节点"); break; &#125; temp=temp.next;//此次循环未找到符合条件的节点，后移 &#125; &#125; //修改节点 public void updateNode(Node newNode)&#123; temp=headNode; while (true)&#123; if (temp.next==null)&#123; System.out.println("链表中没找到要修改的节点"); break; &#125;else if (temp.next.id==newNode.id)&#123; temp.next.name=newNode.name; break; &#125; temp=temp.next; &#125; &#125; //打印链表 public void show()&#123; //当链表为空时，直接提示链表为空 if (isNonNode())&#123; System.out.println("当前单链表为空"); &#125;else &#123; temp=headNode;//初始化temp while (true)&#123; temp=temp.next;//temp后移 if (temp==null)&#123;//到尾节点的next时结束 break; &#125; System.out.println(temp);//输出此时temp的值 &#125; &#125; &#125; //获取链表有效节点个数 public int getSize()&#123; temp=headNode.next;//初始化temp，注意，这次初始temp的值为头节点的下一个节点，即第一个有效节点 int size=0; while (true)&#123; if (temp==null)&#123; break; &#125; size++; temp=temp.next; &#125; return size; &#125; //查找到倒数第n个节点，方案① public Node getLastIndexOf(int n)&#123; int size=getSize(); if (isNonNode()||n&lt;=0||n&gt;size)&#123; System.out.println("没有找到该编号的节点"); return null; &#125; temp=headNode; int i=0; while (true)&#123; i++; temp=temp.next; if (i==(size-n+1))&#123;//第一次循环时，i与temp为0和head，第二次时i与temp为1和第一个有效节点，所以i可以作为有效节点的坐标 return temp; &#125; &#125; &#125; //或使用for循环 /* temp=headNode.next;//这里把temp设为了第一个有效节点，i= size - index时结束循环。当然，也可以同上面while一样设为head，i= size - index+1时结束循环。 for(int i =0; i&lt; size - index; i++) &#123; cur = cur.next; &#125; return cur; */ //反转单向链表 public void reverseLinkedList()&#123; if (headNode.next==null||headNode.next.next==null)&#123; System.out.println("当前链表为空，或只有一个节点，不需要反转"); return; &#125; temp=headNode.next;//初始化temp为第一个有效节点 Node nextNode;//存储当前节点的下一个节点 Node newHead =new Node();//新的头结点 while (true)&#123; if (temp==null)&#123;//循环到temp为空 break; &#125; nextNode=temp.next;//把当前节点的下一个节点存起来 temp.next=newHead.next;//把新head的后一位节点，交给当前节点的next域 newHead.next=temp;//把当前节点，交给新head的next域 temp=nextNode;//让temp回到原链表上，后移一位 &#125; headNode.next=newHead.next;//把新合成的链表的第一个有效节点，交给原来的head的next域 &#125; //逆序打印单向链表 public void reversePrintList()&#123; temp=headNode.next; if (isNonNode())&#123; System.out.println("链表为空"); &#125;else &#123; Stack&lt;Node&gt; nodeStack=new Stack&lt;&gt;();//创建栈对象 while (true)&#123; if (temp==null)&#123; break; &#125; nodeStack.push(temp);//把节点压入栈 temp=temp.next;//节点后移 &#125; while (nodeStack.size()&gt;0)&#123; System.out.println(nodeStack.pop());//从栈中取出节点并打印 &#125; &#125; &#125; //合并两个有序的单链表，使之仍然有序 public SingleLinkedList compound2LinkedList(SingleLinkedList list1,SingleLinkedList list2)&#123; Node temp1= list1.temp=list1.headNode.next;//第一个有效节点 Node temp2 =list2.temp=list2.headNode;//头结点 //把链1放入链2中 Node head2= list2.headNode;//2链的head，没用到 Node next1;//1链的临时存储节点 while (true)&#123; if (temp1==null&amp;&amp;temp2.next==null)&#123; break; &#125; if (temp1!=null)&#123; next1=temp1.next;//临时保存1链当前节点的下一个节点 if (temp2.next==null)&#123;//temp2.next走到头，也没发现大于temp1的数 System.out.println("此后的链2一直小于链1的某个数，由于是有序列表，所以此后链2一直小于链1，直接将把链1放在链2的后面即可"); temp2.next=temp1;//把当前temp1的值，挂在temp2的尾部 break; &#125; if (temp2.next.id&gt;=temp1.id)&#123; temp1.next=temp2.next; temp2.next=temp1; temp1=next1;//直到temp2符合条件，temp1才后移 &#125; &#125; temp2=temp2.next;//temp2始终后移，注意，此时的temp2这条链应该为部分list1与全部list2的混合 &#125; return list2; &#125; //取节点集合 public List&lt;Node&gt; getNodes(SingleLinkedList list)&#123; Node temp=list.temp=list.headNode.next;//初始化temp为该链表的第一个有效节点 List&lt;Node&gt; nodeList=new ArrayList&lt;&gt;();//新建一个node集合 Node next=new Node();//初始一个next对象用于存储temp.next while (true)&#123; if (next==null)&#123;//当next为空时，退出循环 break; &#125; next=temp.next;//将temp的下一个节点临时保存，即保存temp节点以后的链表 temp.next=null;//将temp的next域设为null nodeList.add(temp);//将temp加入节点集合 temp=next;//将temp重新回到链表上 &#125; return nodeList; &#125; //按顺序批量添加节点 public void addNodesByOrder(List&lt;Node&gt; nodes)&#123; temp=headNode;//初始化temp for (Node node :nodes) &#123; addNodeByOrder(node);//调用排序添加单个node的方法 &#125; &#125; //将一个无序链表转为有序链表 public SingleLinkedList formatLinkedList(SingleLinkedList list1)&#123; List&lt;Node&gt; nodes = getNodes(list1); SingleLinkedList list2=new SingleLinkedList(); list2.addNodesByOrder(nodes); return list2; &#125; //测试 public static void main(String[] args) &#123; //生成无序列表1 SingleLinkedList singleLinkedList1=new SingleLinkedList(); singleLinkedList1.addNode(new Node(1,"1号节点")); singleLinkedList1.addNode(new Node(9,"9号节点")); singleLinkedList1.addNode(new Node(2,"2号节点")); singleLinkedList1.addNode(new Node(4,"4号节点")); System.out.println("**********无序链表1"); singleLinkedList1.show(); //序列化无序链表1 SingleLinkedList linkedList1 = singleLinkedList1.formatLinkedList(singleLinkedList1); System.out.println("**********转换成有序链表1"); linkedList1.show(); //生成无序列表2 SingleLinkedList singleLinkedList2=new SingleLinkedList(); singleLinkedList2.addNode(new Node(2,"2号节点")); singleLinkedList2.addNode(new Node(9,"9号节点")); singleLinkedList2.addNode(new Node(6,"6号节点")); singleLinkedList2.addNode(new Node(1,"1号节点")); System.out.println("**********无序链表2"); singleLinkedList2.show(); //序列化无序链表2 SingleLinkedList linkedList2 = singleLinkedList2.formatLinkedList(singleLinkedList2); System.out.println("**********转换成有序链表2"); linkedList2.show(); //合并两个有序列表，用哪个对象都行 SingleLinkedList list = linkedList1.compound2LinkedList(linkedList1, linkedList2); System.out.println("**************两个有序列表合并后的链表"); list.show(); &#125;&#125; 输出结果： 12345678910111213141516171819202122232425262728293031**********无序链表1Node&#123;id=1, name='1号节点'&#125;Node&#123;id=9, name='9号节点'&#125;Node&#123;id=2, name='2号节点'&#125;Node&#123;id=4, name='4号节点'&#125;**********转换成有序链表1Node&#123;id=1, name='1号节点'&#125;Node&#123;id=2, name='2号节点'&#125;Node&#123;id=4, name='4号节点'&#125;Node&#123;id=9, name='9号节点'&#125;**********无序链表2Node&#123;id=2, name='2号节点'&#125;Node&#123;id=9, name='9号节点'&#125;Node&#123;id=6, name='6号节点'&#125;Node&#123;id=1, name='1号节点'&#125;**********转换成有序链表2Node&#123;id=1, name='1号节点'&#125;Node&#123;id=2, name='2号节点'&#125;Node&#123;id=6, name='6号节点'&#125;Node&#123;id=9, name='9号节点'&#125;**************两个有序列表合并后的链表Node&#123;id=1, name='1号节点'&#125;Node&#123;id=1, name='1号节点'&#125;Node&#123;id=2, name='2号节点'&#125;Node&#123;id=2, name='2号节点'&#125;Node&#123;id=4, name='4号节点'&#125;Node&#123;id=6, name='6号节点'&#125;Node&#123;id=9, name='9号节点'&#125;Node&#123;id=9, name='9号节点'&#125;Process finished with exit code 0 2. 双向链表DoublyLinkedList双向链表逻辑结构： 参照单向链表，双向链表在单向链表的基础上，在每个节点多了一个pre域，指向上一个节点。 双向链表可以自由的向前或向后遍历增删时需要把next域和pre域都修改按顺序增加时，即插入操作：修改pre和next时，注意执行顺序先让node的pre和next分别连到temp和temp.next然后将temp.next的pre连到node最后才将temp的next连到node，否则会找不到原先的temp.next由于过渡节点temp可以指向上一个节点，方便了操作，所以删除时temp可以初始为第一个有效节点：此时temp为要删除的节点，temp.pre和temp.next的中间是temp。将temp.next的pre连到temp.pre，把temp.pre的next连到temp.next。还要注意，当要删除的节点为尾节点时，temp.next.set()会造成空指针异常我们之前已经详细的分析了单向链表，其余请对照单向链表思考，修改代码。 双向链表java实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310package LinkedList;import java.util.ArrayList;import java.util.List;import java.util.Stack;public class DoublyLinkedListTest &#123;//双向链表的测试类 public static void main(String[] args) &#123; DoublyLinkedList linkedList=new DoublyLinkedList(); linkedList.addNodeByOrder(new Node(1,"1hao")); linkedList.addNodeByOrder(new Node(3,"3hao")); linkedList.addNodeByOrder(new Node(2,"2hao")); linkedList.addNodeByOrder(new Node(4,"4hao"));// linkedList.show(); List&lt;Node&gt; nodes = getNodes(linkedList); DoublyLinkedList list=new DoublyLinkedList(); list.addNodesByOrder(nodes); list.show(); &#125; //反转单向链表 public static void reverseLinkedList(DoublyLinkedList list)&#123; Node headNode = list.getHeadNode(); Node temp; if (headNode.next==null||headNode.next.next==null)&#123; System.out.println("当前链表为空，或只有一个节点，不需要反转"); return; &#125; temp=headNode.next;//初始化temp为第一个有效节点 Node nextNode;//存储当前节点的下一个节点 Node newHead =new Node();//新的头结点 while (true)&#123; if (temp==null)&#123;//循环到temp为空 break; &#125; nextNode=temp.next;//把当前节点的下一个节点存起来 temp.next=newHead.next;//把新head的后一位节点，交给当前节点的next域 newHead.next=temp;//把当前节点，交给新head的next域 temp=nextNode;//让temp回到原链表上，后移一位 &#125; headNode.next=newHead.next;//把新合成的链表的第一个有效节点，交给原来的head的next域 &#125; //逆序打印单向链表 public static void reversePrintList(DoublyLinkedList list)&#123; Node headNode = list.getHeadNode(); Node temp=headNode.next; if (list.isNonNode())&#123; System.out.println("链表为空"); &#125;else &#123; Stack&lt;Node&gt; nodeStack=new Stack&lt;&gt;();//创建栈对象 while (true)&#123; if (temp==null)&#123; break; &#125; nodeStack.push(temp);//把节点压入栈 temp=temp.next;//节点后移 &#125; while (nodeStack.size()&gt;0)&#123; System.out.println(nodeStack.pop());//从栈中取出节点并打印 &#125; &#125; &#125; //合并两个有序的单链表，使之仍然有序 public static DoublyLinkedList compound2LinkedList(DoublyLinkedList list1,DoublyLinkedList list2)&#123; Node temp1= list1.temp=list1.headNode.next;//第一个有效节点 Node temp2 =list2.temp=list2.headNode;//头结点 //把链1放入链2中 Node head2= list2.headNode;//2链的head，没用到 Node next1;//1链的临时存储节点 while (true)&#123; if (temp1==null&amp;&amp;temp2.next==null)&#123; break; &#125; if (temp1!=null)&#123; next1=temp1.next;//临时保存1链当前节点的下一个节点 if (temp2.next==null)&#123;//temp2.next走到头，也没发现大于temp1的数 System.out.println("此后的链2一直小于链1的某个数，由于是有序列表，所以此后链2一直小于链1，直接将把链1放在链2的后面即可"); temp2.next=temp1;//把当前temp1的值，挂在temp2的尾部 break; &#125; if (temp2.next.id&gt;=temp1.id)&#123; temp1.next=temp2.next; temp2.next=temp1; temp1=next1;//直到temp2符合条件，temp1才后移 &#125; &#125; temp2=temp2.next;//temp2始终后移，注意，此时的temp2这条链应该为部分list1与全部list2的混合 &#125; return list2; &#125; //取节点集合 public static List&lt;Node&gt; getNodes(DoublyLinkedList list)&#123; Node temp=list.temp=list.headNode.next;//初始化temp为该链表的第一个有效节点 List&lt;Node&gt; nodeList=new ArrayList&lt;&gt;();//新建一个node集合 Node next=new Node();//初始一个next对象用于存储temp.next while (true)&#123; if (next==null)&#123;//当next为空时，退出循环 break; &#125; next=temp.next;//将temp的下一个节点临时保存，即保存temp节点以后的链表 temp.next=null;//将temp的next域设为null temp.pre=null; nodeList.add(temp);//将temp加入节点集合 temp=next;//将temp重新回到链表上 &#125; return nodeList; &#125; //将一个无序链表转为有序链表 public static DoublyLinkedList formatLinkedList(DoublyLinkedList list1)&#123; List&lt;Node&gt; nodes = getNodes(list1); DoublyLinkedList list2=new DoublyLinkedList(); list2.addNodesByOrder(nodes); return list2; &#125;&#125;//******************************************** //双向链表类 class DoublyLinkedList &#123; Node headNode=new Node();//头节点 Node temp;//设一个过渡节点，初始为第一个有效节点 //获取头节点 public Node getHeadNode()&#123; return headNode; &#125; public boolean isNonNode()&#123; return headNode.next == null; &#125; //添加Node(不考虑排序) public void addNode(Node node)&#123; temp=headNode;//初始化temp //找到尾节点 while (true)&#123; //判断过渡节点的next域是否为空 if (temp.next==null)&#123; //将node加入链表 temp.setNext(node); node.setPre(temp); break;//找到next域为空的节点，便退出循环 &#125;else &#123; //否则temp后移一个节点 temp=temp.getNext(); &#125; &#125; &#125; //添加Node，考虑排序 public void addNodeByOrder(Node node)&#123; temp=headNode;//初始化temp while(true)&#123; if (temp.next==null)&#123;//此时链表为空或已到链表末尾 //直接添加节点 temp.setNext(node); node.setPre(temp); break; &#125;else if (temp.next.id&gt;node.id) &#123;//此时temp与temp.next之间的位置，便是node应该插入的位置 node.setPre(temp);//先让node的pre连到temp node.setNext(temp.next);//node的next连到temp.next temp.next.setPre(node);//然后先把temp.next的pre连到node temp.setNext(node);//最后把temp的next连到node break; &#125; temp=temp.next;//以上都不满足，后移temp &#125; &#125; //按顺序批量添加节点 public void addNodesByOrder(List&lt;Node&gt; nodes)&#123; temp=headNode;//初始化temp for (Node node :nodes) &#123; addNodeByOrder(node);//调用排序添加单个node的方法 &#125; &#125; //删除节点 public void deleteNode(int id)&#123; temp=headNode.getNext();//初始化temp为第一个有效节点 while (true)&#123; if (temp==null)&#123; System.out.println("链表中没找到要删除的节点"); break; &#125;else if (temp.id==id)&#123; if (temp.next==null)&#123; temp.pre.setNext(null);//如果节点在最尾部 System.out.println("删除"+temp.id+"号节点，该节点是尾节点"); break; &#125; temp.next.setPre(temp.pre);//把temp.next的pre连到temp.pre，中间是temp temp.pre.setNext(temp.next);//把temp.pre的next连到temp.next，中间是temp //此时，没有任何节点的next或pre指向temp，不被引用的对象，会被JVM垃圾回收机制自动回收 System.out.println("删除"+temp.id+"号节点"); break; &#125; temp=temp.next;//此次循环未找到符合条件的节点，后移 &#125; &#125; //修改节点 public void updateNode(Node newNode)&#123; temp=headNode; while (true)&#123; if (temp.next==null)&#123; System.out.println("链表中没找到要修改的节点"); break; &#125;else if (temp.next.id==newNode.id)&#123; temp.next.name=newNode.name; break; &#125; temp=temp.next; &#125; &#125; //打印链表 public void show()&#123; //当链表为空时，直接提示链表为空 if (isNonNode())&#123; System.out.println("当前单链表为空"); &#125;else &#123; temp=headNode;//初始化temp while (true)&#123; temp=temp.next;//temp后移 if (temp==null)&#123;//到尾节点的next时结束 break; &#125; System.out.println(temp);//输出此时temp的值 &#125; &#125; &#125; //获取链表有效节点个数 public int getSize()&#123; temp=headNode.next;//初始化temp，注意，这次初始temp的值为头节点的下一个节点，即第一个有效节点 int size=0; while (true)&#123; if (temp==null)&#123; break; &#125; size++; temp=temp.next; &#125; return size; &#125; //查找到倒数第n个节点 public Node getLastIndexOf(int n)&#123; int size=getSize(); if (isNonNode()||n&lt;=0||n&gt;size)&#123; System.out.println("没有找到该编号的节点"); return null; &#125; temp=headNode; int i=0; while (true)&#123; i++; temp=temp.next; if (i==(size-n+1))&#123;//第一次循环时，i与temp为0和head，第二次时i与temp为1和第一个有效节点，所以i可以作为有效节点的坐标 return temp; &#125; &#125; &#125; //或使用for循环 /* temp=headNode.next;//这里把temp设为了第一个有效节点，i= size - index时结束循环。当然，也可以同上面while一样设为head，i= size - index+1时结束循环。 for(int i =0; i&lt; size - index; i++) &#123; cur = cur.next; &#125; return cur; */ &#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx反向代理、负载均衡]]></title>
    <url>%2F2019%2F09%2F04%2Fnginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E3%80%81%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%2F</url>
    <content type="text"><![CDATA[Nginx反向代理、负载均衡、高可用反向代理什么是反向代理 客户端向代理服务器发送请求，代理服务器根据这个请求去选择实际能提供相关服务的http服务器，然后把资源通过代理服务器交给客户端。此时，客户端只能知道代理服务器的地址，无法知道实际提供服务的http服务器地址。 与之对应的，是前向代理。前向代理中，客户端通过一个代理客户端来发送请求，此时服务器只知道代理客户端的地址，不知道真实客户端的地址，如VPN。 要注意的是，文中的代理服务器与代理客户端的说法是为了方便理解，实际上两者都是服务器，只是代理的对象不同，有点像学生代表、或明星的经纪人？ Nginx如何做反向代理 只需要在nginx的conf配置文件中，增加server代码块，修改对应的server_name、location、upstream。 也可以用这种方法做虚拟主机，这样可以两个域名指向同一台nginx服务器，用户访问不同的域名显示不同的网页内容，因为多个域名可以对应一个ip地址，最好是根据域名区分，ip或端口也行。 先看基于域名的虚拟主机配置 123456789101112131415161718192021#虚拟主机1server &#123; listen 80; server_name s1.shirtiny.cn; location / &#123; root html-s1; index index.html index.htm; &#125; &#125;#虚拟主机2 server &#123; listen 80; server_name s2.shirtiny.cn; location / &#123; root html-s2; index index.html index.htm; &#125; &#125; 反向代理配置 除了upstream外，还要注意location的变化，proxy_pass。 1234567891011121314151617181920212223242526272829#http服务器upstream tomcat_server1 &#123; server 192.168.101.5:8080; &#125;upstream tomcat_server2 &#123; server 192.168.101.6:8080; &#125;#配置虚拟主机1 server &#123; listen 80; server_name aaa.test.com; location / &#123; #域名aaa.test.com的请求全部转发到tomcat_server1即tomcat1服务上 proxy_pass http://tomcat_server1; #欢迎页面，按照从左到右的顺序查找页面 index index.jsp index.html index.htm; &#125; &#125;#配置虚拟主机2 server &#123; listen 80; server_name bbb.test.com; location / &#123; #域名bbb.test.com的请求全部转发到tomcat_server2即tomcat2服务上 proxy_pass http://tomcat_server2; index index.jsp index.html index.htm; &#125; &#125; 详细参考 负载均衡Load Balance，同种服务有多个http服务器时，nginx根据http服务器被分配的权重，把请求轮换分配给某个http服务器。 只需要在upstream对服务器进行权重分配，weight默认为1。 123456789101112131415161718192021222324252627282930upstream tomcat_server_pool&#123; server 192.168.101.5:8080 weight=3; server 192.168.101.6:8080 weight=1; &#125;#详细说明#定义负载均衡设备的 Ip及设备状态 upstream myServer &#123; server 127.0.0.1:9090 down; server 127.0.0.1:8080 weight=2; server 127.0.0.1:6060; server 127.0.0.1:7070 backup; &#125;#upstream 每个设备的状态:#down 表示单前的server暂时不参与负载 #weight 默认为1.weight越大，负载的权重就越大。 #max_fails ：允许请求失败的次数默认为1.当超过最大次数时，返回proxy_next_upstream 模块定义的错误 #fail_timeout:max_fails 次失败后，暂停的时间。 #backup： 其它所有的非backup机器down或者忙的时候，请求backup机器。所以这台机器压力会最轻。#在需要使用负载的Server节点下添加#proxy_pass http://myServer; server &#123; listen 80; server_name aaa.test.com; location / &#123; proxy_pass http://myServer; index index.jsp index.html index.htm; &#125; &#125; 高可用准备两台Nginx服务器，一主一备。都装keepalived做健康检查，两个keepalived会保持通讯，主服务器拿到虚拟ip（vip）运行中，当主Nginx服务器上的keepalived失去响应时，备用服务器上的keepalived会启动备用的Nginx，拿到主Nginx的虚拟ip（vip），代替主服务器工作。 keepalived的安装安装环境1234567su - rootyum -y install kernel-devel*yum -y install openssl-*yum -y install popt-develyum -y install lrzszyum -y install openssh-clientsyum -y install libnl libnl-devel popt 安装keepalived将keepalived-1.2.15.tar.gz上传到服务器/usr/local/下。 123456789cd /usr/localtar -zxvf keepalived-1.2.15.tar.gzcd keepalived-1.2.15#执行配置命令./configure --prefix=/usr/local/keepalived#编译make#安装make install 至此安装完成。 123456789101112#拷贝执行文件cp /usr/local/keepalived/sbin/keepalived /usr/sbin/#将init.d文件拷贝到etc下,加入开机启动项cp /usr/local/keepalived/etc/rc.d/init.d/keepalived /etc/init.d/keepalived#将keepalived文件拷贝到etc下，加入网卡配置cp /usr/local/keepalived/etc/sysconfig/keepalived /etc/sysconfig/ #创建keepalived文件夹mkdir -p /etc/keepalived#将keepalived配置文件拷贝到etc下cp /usr/local/keepalived/etc/keepalived/keepalived.conf /etc/keepalived/keepalived.conf#添加可执行权限chmod +x /etc/init.d/keepalived 加入开机启动12chkconfig --add keepalived #添加时必须保证/etc/init.d/keepalived存在chkconfig keepalived on 添加完可查询系统服务是否存在：chkconfig --list 启动keepalived123启动：service keepalived start停止：service keepalived stop重启：service keepalived restart 配置日志文件12345678#将keepalived日志输出到local0：vi /etc/sysconfig/keepalivedKEEPALIVED_OPTIONS="-D -d -S 0"#在/etc/rsyslog.conf里添加:local0.* /var/log/keepalived.log#重新启动keepalived和rsyslog服务：service rsyslog restart service keepalived restart 打开防火墙的通讯地址12iptables -A INPUT -d 224.0.0.18 -j ACCEPT/etc/rc.d/init.d/iptables save 主Nginx修改主nginx下/etc/keepalived/keepalived.conf文件 123456789101112131415161718192021222324252627! Configuration File for keepalived#全局配置global_defs &#123; notification_email &#123; #指定keepalived在发生切换时需要发送email到的对象，一行一个 XXX@XXX.com &#125; notification_email_from XXX@XXX.com #指定发件人 #smtp_server XXX.smtp.com #指定smtp服务器地址 #smtp_connect_timeout 30 #指定smtp连接超时时间 router_id LVS_DEVEL #运行keepalived机器的一个标识&#125;vrrp_instance VI_1 &#123; state MASTER #标示状态为MASTER 备份机为BACKUP interface eth0 #设置实例绑定的网卡 virtual_router_id 51 #同一实例下virtual_router_id必须相同 priority 100 #MASTER权重要高于BACKUP 比如BACKUP为99 advert_int 1 #MASTER与BACKUP负载均衡器之间同步检查的时间间隔，单位是秒 authentication &#123; #设置认证 auth_type PASS #主从服务器验证方式 auth_pass 8888 &#125; virtual_ipaddress &#123; #设置vip 192.168.101.100 #可以多个虚拟IP，换行即可 &#125;&#125; 备Nginx修改备nginx下/etc/keepalived/keepalived.conf文件 配置备nginx时需要注意：需要修改state为BACKUP , priority比MASTER低，virtual_router_id和master的值一致 123456789101112131415161718192021222324252627! Configuration File for keepalived#全局配置global_defs &#123; notification_email &#123; #指定keepalived在发生切换时需要发送email到的对象，一行一个 XXX@XXX.com &#125; notification_email_from XXX@XXX.com #指定发件人 #smtp_server XXX.smtp.com #指定smtp服务器地址 #smtp_connect_timeout 30 #指定smtp连接超时时间 router_id LVS_DEVEL #运行keepalived机器的一个标识&#125;vrrp_instance VI_1 &#123; state BACKUP #标示状态为MASTER 备份机为BACKUP interface eth0 #设置实例绑定的网卡 virtual_router_id 51 #同一实例下virtual_router_id必须相同 priority 99 #MASTER权重要高于BACKUP 比如BACKUP为99 advert_int 1 #MASTER与BACKUP负载均衡器之间同步检查的时间间隔，单位是秒 authentication &#123; #设置认证 auth_type PASS #主从服务器验证方式 auth_pass 8888 &#125; virtual_ipaddress &#123; #设置vip 192.168.101.100 #可以多个虚拟IP，换行即可 &#125;&#125; tips： 因为备份服务器的启动，是依据主服务器上的keepalived的响应状况判断的，所以当主服务器的keepalived意外停止，或者当nginx进程停止时，keepalived没有按计划停止，就无法启动备份服务器。 nginx进程检测脚本为了解决nginx进程和keepalived不同时存在的问题，需要在主服务器上编写Nginx进程检测脚本check_nginx.sh，判断nginx进程是否存在，如果nginx不存在就将keepalived进程杀掉。 123456#!/bin/bash# 如果进程中没有nginx则将keepalived进程kill掉A=`ps -C nginx --no-header |wc -l` ## 查看是否有 nginx进程 把值赋给变量A if [ $A -eq 0 ];then ## 如果没有进程值得为 零 service keepalived stop ## 则结束 keepalived 进程fi 脚本运行测试 将check_nginx.sh拷贝至/etc/keepalived下， 将nginx停止，将keepalived启动，执行脚本：sh /etc/keepalived/check_nginx.sh，若keepalived进程被顺利杀死，即成功。 修改主nginx的keepalived.conf，添加脚本定义检测： 1234567891011121314151617181920212223242526272829303132333435363738#全局配置global_defs &#123; notification_email &#123; #指定keepalived在发生切换时需要发送email到的对象，一行一个 XXX@XXX.com &#125; notification_email_from miaoruntu@itcast.cn #指定发件人 #smtp_server XXX.smtp.com #指定smtp服务器地址 #smtp_connect_timeout 30 #指定smtp连接超时时间 router_id LVS_DEVEL #运行keepalived机器的一个标识&#125; ##监控脚本vrrp_script check_nginx &#123; script "/etc/keepalived/check_nginx.sh" ##监控脚本 interval 2 ##时间间隔，2秒 weight 2 ##权重&#125;vrrp_instance VI_1 &#123; state MASTER #标示状态为MASTER 备份机为BACKUP interface eth0 #设置实例绑定的网卡 virtual_router_id 51 #同一实例下virtual_router_id必须相同 priority 100 #MASTER权重要高于BACKUP 比如BACKUP为99 advert_int 1 #MASTER与BACKUP负载均衡器之间同步检查的时间间隔，单位是秒 authentication &#123; #设置认证 auth_type PASS #主从服务器验证方式 auth_pass 8888 &#125; #监控脚本 track_script &#123; check_nginx #监控脚本 &#125; virtual_ipaddress &#123; #设置vip 192.168.101.100 #可以多个虚拟IP，换行即可 &#125;&#125;#修改后重启keepalived#观察keepalived日志：#tail -f /var/log/keepalived.log]]></content>
      <categories>
        <category>学习经验</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[今日硬盘阵亡]]></title>
    <url>%2F2019%2F09%2F03%2F%E7%A1%AC%E7%9B%98%E9%98%B5%E4%BA%A1%2F</url>
    <content type="text"><![CDATA[今日1T机械硬盘君阵亡察觉硬盘运行声响不正常，还好当时觉得不妙，便把博客备份传到群文件了。传完不久，机械硬盘阵亡，电脑死机，内存内的程序还在运行。下午在固态硬盘上装了个盗版win10系统，临时使用。 从零开始的环境搭建由于数据全部丢失，硬盘维修状况尚不可知，在临时系统里，准备必要的学习环境 安装必要驱动 卸除所有不需要的软件 firefox浏览器安装开发者版本，因为账号似乎与普通版区分，需要用来账号同步，账号依然是我qq邮箱同步完成后，收藏与记录的表单就有了，主题皮肤还在，只是布局要自己改谷歌以后有需要时再装 因为博客有备份，先恢复博客安装nodejs、git、hexo安装nodejs时遇到2503错误，是windows权限问题，需要使用msiexec命令cd 到软件所在目录msiexec /package 你的.msi软件大概是这样，记得不是很清楚，详情去百度。安装hexo时遇到问题可查看hexo迁移使用hexo命令需要把D:\hexoBlog\ShirtinyBlog\node_modules\.bin配置到path全局环境变量 安装Typora用来写md文章。 输入法依然按照我的习惯来在系统设置里，语言选项，增加英语（美国），这样将设win+空格，将纯英文环境与中英文环境分开分开中文输入法依然用手心输入法，将微软拼音从设置中删除。 QQ装上，方便在手机与电脑间传点小东西 百度云用的下载器，超级会员太坑，用speedPan或pandownload来下载百度云资源 Xshell、Xftp，在博客找。VMwear虚拟机暂不装，硬盘空间不够，只能先租服务器了。 解压软件，Bandizip，百度到官网下载。 视频播放器Potplayer IntelliJ IDEA 【8qhm】或寻找新的破解版此版本安装方式管理员身份运行idea安装包，选系统位数，然后完成安装修改host，在末尾加：0.0.0.0 account.jetbrains.com0.0.0.0 www.jetbrains.com在激活界面，选Activation code，然后复制注册码即可在其安装目录的lib文件夹下，把resources_cn.jar复制过来，可以汉化（虽然不用汉化）代码样式用 Visual Studio 2013 百度jdk1.8去Oracle下jdk，需要Oracle账号 doc文档暂用WPS VSCode，因为要经常看乱七八糟后缀名的文件 Maven，官网下个，然后解压，环境变量是MAVEN_HOME、解压的文件夹目录，path是%MAVEN_HOME%\bin，环境变量好像都一个配法。 先这么简单弄个能正常学习的环境把，唉难受。]]></content>
      <categories>
        <category>系统维护</category>
      </categories>
      <tags>
        <tag>硬盘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单点登录系统]]></title>
    <url>%2F2019%2F09%2F03%2F%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[单点登录系统搭建单点登录Single Sign On，简称SSO，即单点登录。在单点登录系统中，用户只需登录一次，便可访问所有相互信任的系统。 因为多个系统之间相互独立，可又需要共享用户信息，此时就要Session共享。 Session共享 在小规模项目中，或许可以考虑配置tomcat的session共享、配置tomcat集群，不停的向集群中广播session信息，用这种方式做session同步会消耗很多的性能，也不能解决分布式项目的session共享。 我们可以选择把用户信息、其他系统之间需要共享的信息，放入Redis缓存中，将对应Key写入Cookie，这样访问速度快，也可以设过期时间，不会有多节点的session复制问题。 Cookie共享1、Domain：必须是相同的。 例如有多个域名： www.xx.com sso.xx.com sea.xx.com 需要设置domain为:.xx.com，即将Cookie的域设置为顶域。 2、设置path：/ Cookies工具类 如果是localhost不要设置domain。直接设置path就可以了。如果cookie中的value中有特殊符号，比如@，取出来的cookie值是用双引号括起来的，用.replace(/“/g, “”)，取掉双引号 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225import java.io.UnsupportedEncodingException;import java.net.URLDecoder;import java.net.URLEncoder;import javax.servlet.http.Cookie;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * * Cookie 工具类 * */public final class CookieUtils &#123; /** * 得到Cookie的值, 不编码 * * @param request * @param cookieName * @return */ public static String getCookieValue(HttpServletRequest request, String cookieName) &#123; return getCookieValue(request, cookieName, false); &#125; /** * 得到Cookie的值, * * @param request * @param cookieName * @return */ public static String getCookieValue(HttpServletRequest request, String cookieName, boolean isDecoder) &#123; Cookie[] cookieList = request.getCookies(); if (cookieList == null || cookieName == null) &#123; return null; &#125; String retValue = null; try &#123; for (int i = 0; i &lt; cookieList.length; i++) &#123; if (cookieList[i].getName().equals(cookieName)) &#123; if (isDecoder) &#123; retValue = URLDecoder.decode(cookieList[i].getValue(), "UTF-8"); &#125; else &#123; retValue = cookieList[i].getValue(); &#125; break; &#125; &#125; &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; return retValue; &#125; /** * 得到Cookie的值, * * @param request * @param cookieName * @return */ public static String getCookieValue(HttpServletRequest request, String cookieName, String encodeString) &#123; Cookie[] cookieList = request.getCookies(); if (cookieList == null || cookieName == null) &#123; return null; &#125; String retValue = null; try &#123; for (int i = 0; i &lt; cookieList.length; i++) &#123; if (cookieList[i].getName().equals(cookieName)) &#123; retValue = URLDecoder.decode(cookieList[i].getValue(), encodeString); break; &#125; &#125; &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; return retValue; &#125; /** * 设置Cookie的值 不设置生效时间默认浏览器关闭即失效,也不编码 */ public static void setCookie(HttpServletRequest request, HttpServletResponse response, String cookieName, String cookieValue) &#123; setCookie(request, response, cookieName, cookieValue, -1); &#125; /** * 设置Cookie的值 在指定时间内生效,但不编码 */ public static void setCookie(HttpServletRequest request, HttpServletResponse response, String cookieName, String cookieValue, int cookieMaxage) &#123; setCookie(request, response, cookieName, cookieValue, cookieMaxage, false); &#125; /** * 设置Cookie的值 不设置生效时间,但编码 */ public static void setCookie(HttpServletRequest request, HttpServletResponse response, String cookieName, String cookieValue, boolean isEncode) &#123; setCookie(request, response, cookieName, cookieValue, -1, isEncode); &#125; /** * 设置Cookie的值 在指定时间内生效, 编码参数 */ public static void setCookie(HttpServletRequest request, HttpServletResponse response, String cookieName, String cookieValue, int cookieMaxage, boolean isEncode) &#123; doSetCookie(request, response, cookieName, cookieValue, cookieMaxage, isEncode); &#125; /** * 设置Cookie的值 在指定时间内生效, 编码参数(指定编码) */ public static void setCookie(HttpServletRequest request, HttpServletResponse response, String cookieName, String cookieValue, int cookieMaxage, String encodeString) &#123; doSetCookie(request, response, cookieName, cookieValue, cookieMaxage, encodeString); &#125; /** * 删除Cookie带cookie域名 */ public static void deleteCookie(HttpServletRequest request, HttpServletResponse response, String cookieName) &#123; doSetCookie(request, response, cookieName, "", -1, false); &#125; /** * 设置Cookie的值，并使其在指定时间内生效 * * @param cookieMaxage cookie生效的最大秒数 */ private static final void doSetCookie(HttpServletRequest request, HttpServletResponse response, String cookieName, String cookieValue, int cookieMaxage, boolean isEncode) &#123; try &#123; if (cookieValue == null) &#123; cookieValue = ""; &#125; else if (isEncode) &#123; cookieValue = URLEncoder.encode(cookieValue, "utf-8"); &#125; Cookie cookie = new Cookie(cookieName, cookieValue); if (cookieMaxage &gt; 0) cookie.setMaxAge(cookieMaxage); if (null != request) &#123;// 设置域名的cookie String domainName = getDomainName(request); System.out.println(domainName); if (!"localhost".equals(domainName)) &#123; cookie.setDomain(domainName); &#125; &#125; cookie.setPath("/"); response.addCookie(cookie); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; /** * 设置Cookie的值，并使其在指定时间内生效 * * @param cookieMaxage cookie生效的最大秒数 */ private static final void doSetCookie(HttpServletRequest request, HttpServletResponse response, String cookieName, String cookieValue, int cookieMaxage, String encodeString) &#123; try &#123; if (cookieValue == null) &#123; cookieValue = ""; &#125; else &#123; cookieValue = URLEncoder.encode(cookieValue, encodeString); &#125; Cookie cookie = new Cookie(cookieName, cookieValue); if (cookieMaxage &gt; 0) cookie.setMaxAge(cookieMaxage); if (null != request) &#123;// 设置域名的cookie String domainName = getDomainName(request); System.out.println(domainName); if (!"localhost".equals(domainName)) &#123; cookie.setDomain(domainName); &#125; &#125; cookie.setPath("/"); response.addCookie(cookie); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; /** * 得到cookie的域名 */ private static final String getDomainName(HttpServletRequest request) &#123; String domainName = null; String serverName = request.getRequestURL().toString(); if (serverName == null || serverName.equals("")) &#123; domainName = ""; &#125; else &#123; serverName = serverName.toLowerCase(); serverName = serverName.substring(7); final int end = serverName.indexOf("/"); serverName = serverName.substring(0, end); final String[] domains = serverName.split("\\."); int len = domains.length; if (len &gt; 3) &#123; // www.xxx.com.cn domainName = "." + domains[len - 3] + "." + domains[len - 2] + "." + domains[len - 1]; &#125; else if (len &lt;= 3 &amp;&amp; len &gt; 1) &#123; // xxx.com or xxx.cn domainName = "." + domains[len - 2] + "." + domains[len - 1]; &#125; else &#123; domainName = serverName; &#125; &#125; if (domainName != null &amp;&amp; domainName.indexOf(":") &gt; 0) &#123; String[] ary = domainName.split("\\:"); domainName = ary[0]; &#125; return domainName; &#125;&#125; tips： Cookie的MaxAge属性及其使用 js取cookie，参考 也可以在后端取cookie 1234567891011121314151617181920212223242526272829&lt;script type="text/javascript" src="/js/jquery-1.6.4.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="/js/jquery.cookie.js"&gt;&lt;/script&gt;var TT = ToTo = &#123; checkLogin : function()&#123; var _ticket = $.cookie("TT_TOKEN"); if(!_ticket)&#123; return ; &#125; $.ajax(&#123; url : "http://localhost:8082/rest/token/" + _ticket, dataType : "jsonp", type : "GET", success : function(data)&#123; if(data.status == 200)&#123; var username = data.data.username; var html = username + "，欢迎！&lt;a href=\"http://localhost:8082/rest/logout.html\" class=\"link-logout\"&gt;[退出]&lt;/a&gt;"; $("#loginbar").html(html); &#125; &#125; &#125;); &#125;&#125;$(function()&#123; // 查看是否已经登录，如果已经登录查询登录信息 TT.checkLogin();&#125;); 主要service 12345678910111213141516171819202122@Override public boolean selectOne(TbUser user, HttpServletRequest request,HttpServletResponse response) &#123; TbUserExample example=new TbUserExample(); TbUserExample.Criteria criteria = example.createCriteria(); criteria.andUsernameEqualTo(user.getUsername()); List&lt;TbUser&gt; tbUsers = userMapper.selectByExample(example); if (tbUsers==null||tbUsers.size()==0)&#123; return false; &#125; TbUser tbUser = tbUsers.get(0); String json = JsonUtils.objectToJson(tbUser); String uuid = UUID.randomUUID().toString();//随机uuid //存入redis String token=UserSessionKey+uuid; jedisDao.set(token,json); jedisDao.expire(token,360);//设置过期时间，单位秒 //写入cookie，cookie名为userSessionKey,直接写cookie值，相同cookie名会覆盖 CookieUtils.setCookie(request,response,cookieName,uuid);//没设过期时间，关闭浏览器会清空 System.out.println("redis session key:"+uuid+"，值为"+jedisDao.get(token)); return true; &#125; 拦截URL强制登录拦截器拦截器实现了HandlerInterceptor接口： preHandle：在Handler执行之前处理 postHandle：handler执行之后，返回ModelAndView之前 afterCompletion：返回ModelAndView之后 注意拦截器应该在门户系统中使用，才能拦截门户请求，而且需要先被springMVC拦截。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class OrderInterceptor implements HandlerInterceptor &#123; @Autowired private UserService userService; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; //取用户token String token = CookieUtils.getCookieValue(request, "TT_TOKEN"); //判断是否为空 if (StringUtils.isBlank(token)) &#123; //如果为空就是未登录状态 //跳转到登录页面 response.sendRedirect(userService.getLoginUrl() + "?redirect=" + getBaseURL(request)); return false; &#125; else &#123; //如果能取到token说明用户可能已经登录 //从sso中取用户信息，判断用户是否登录 TbUser user = userService.getUserByToken(token); //判断用户是否过期 if (user == null) &#123; //跳转到登录页面 response.sendRedirect(userService.getLoginUrl() + "?redirect=" + getBaseURL(request)); return false; &#125; else &#123; //用户已经登录，把用户信息放到request中 request.setAttribute("user", user); &#125; &#125; //放行 return true; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; // TODO Auto-generated method stub &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; // TODO Auto-generated method stub &#125; private String getBaseURL(HttpServletRequest request) &#123; String url = request.getScheme() + "://" + request.getServerName() + ":" + request.getServerPort() + request.getContextPath() + request.getRequestURI(); return url; &#125;&#125; 或 123456789101112131415161718192021222324252627282930313233343536373839404142public class LoginInterceptor implements HandlerInterceptor &#123; @Autowired private UserServiceImpl userService; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; //在Handler执行之前处理 //判断用户是否登录 //从cookie中取token String token = CookieUtils.getCookieValue(request, "TT_TOKEN"); //根据token换取用户信息，调用sso系统的接口。 TbUser user = userService.getUserByToken(token); //取不到用户信息 if (null == user) &#123; //跳转到登录页面，把用户请求的url作为参数传递给登录页面。 response.sendRedirect(userService.SSO_BASE_URL + userService.SSO_PAGE_LOGIN + "?redirect=" + request.getRequestURL()); //返回false return false; &#125; //取到用户信息，放行 //返回值决定handler是否执行。true：执行，false：不执行。 return true; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; // handler执行之后，返回ModelAndView之前 &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; // 返回ModelAndView之后。 //响应用户之后。 &#125;&#125; URL回调 拦截器拦截用户请求时，将用户请求的URL通过一个参数传递给显示登录页面的Controller，设参数名为：redirect。然后再让Controller把redirect传递给jsp页面。当登录成功后，js的逻辑中判断是否有回调的rul，如果有就跳转到此url，如果没有就跳转到商城首页。 回调Controller 12345678@ResquestMapping("/login")public String showLogin(String redirect, Model model)&#123; //判断是否有需要回调的URL if(!StringUtils.isBlank(redirect))&#123; model.addAttribute("redirect",redirect); &#125; return "login";&#125; 登录页面js 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;script type="text/javascript"&gt; var redirectUrl = "$&#123;redirect&#125;"; var LOGIN = &#123; checkInput:function() &#123; if ($("#loginname").val() == "") &#123; alert("用户名不能为空"); $("#loginname").focus(); return false; &#125; if ($("#nloginpwd").val() == "") &#123; alert("密码不能为空"); $("#nloginpwd").focus(); return false; &#125; return true; &#125;, doLogin:function() &#123; $.post("/user/login", $("#formlogin").serialize(),function(data)&#123; if (data.status == 200) &#123; alert("登录成功！"); if (redirectUrl == "") &#123; location.href = "http://localhost:8082"; &#125; else &#123; location.href = redirectUrl; &#125; &#125; else &#123; alert("登录失败，原因是：" + data.msg); $("#loginname").select(); &#125; &#125;); &#125;, login:function() &#123; if (this.checkInput()) &#123; this.doLogin(); &#125; &#125; &#125;; $(function()&#123; $("#loginsubmit").click(function()&#123; LOGIN.login(); &#125;); &#125;);&lt;/script&gt;]]></content>
      <categories>
        <category>学习经验</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>cookies</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Solr-Error]]></title>
    <url>%2F2019%2F09%2F03%2FSolr-Error-solrj-beans-BindingException%2F</url>
    <content type="text"><![CDATA[控制台： Exception in thread “main” org.apache.solr.client.solrj.beans.BindingException: Could not instantiate object of class com.SH.Rest.Pojo.Solr_pojo 异常产生经过： 在使用SolrJ时，调用SolrClient对象的addBean()方法以及QueryResponse对象的getBeans()方法时，抛出异常。 1234solrClient.addBean(pojo);//以及QueryResponse queryResponse = solrClient.query(query);List&lt;Solr_pojo&gt; solr_pojos = queryResponse.getBeans(Solr_pojo.class); 异常全文： Exception in thread “main” org.apache.solr.client.solrj.beans.BindingException: Could not instantiate object of class com.SH.Rest.Pojo.Solr_pojo at org.apache.solr.client.solrj.beans.DocumentObjectBinder.getBean(DocumentObjectBinder.java:71) at org.apache.solr.client.solrj.beans.DocumentObjectBinder.getBeans(DocumentObjectBinder.java:50) at org.apache.solr.client.solrj.response.QueryResponse.getBeans(QueryResponse.java:646) at com.SH.Rest.Service.serviceImpl.SearchServiceImpl.query(SearchServiceImpl.java:32) at com.SH.Rest.Service.serviceImpl.SearchServiceImpl.main(SearchServiceImpl.java:41)Caused by: java.lang.InstantiationException: com.SH.Rest.Pojo.Solr_pojo at java.lang.Class.newInstance(Class.java:427) at org.apache.solr.client.solrj.beans.DocumentObjectBinder.getBean(DocumentObjectBinder.java:65) … 4 moreCaused by: java.lang.NoSuchMethodException: com.SH.Rest.Pojo.Solr_pojo.() at java.lang.Class.getConstructor0(Class.java:3082) at java.lang.Class.newInstance(Class.java:412) … 5 moreDisconnected from the target VM, address: ‘127.0.0.1:1331’, transport: ‘socket’Process finished with exit code 1 解决方法： 无法实例化对象，可能是因为属性类型不匹配，要仔细检查对象类与solr域的类型是否对应，是否做好转换，另外还需检查有无空构造器，以及setter&amp;getter参数类型是否有误。 样例 下面给出我当时改后的pojo类与solr域的示例。 Solr_pojo类 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.SH.Rest.Pojo;import org.apache.solr.client.solrj.beans.Field;import java.util.Date;public class Solr_pojo &#123; @Field("id") private String id; @Field("solr_title") private String title; @Field("solr_sell_point") private String sellPoint; @Field("solr_price") private Long price; @Field("solr_num") private Integer num; @Field("solr_barcode") private String barcode; @Field("solr_image") private String image; @Field("solr_cid") private Long cid; @Field("solr_status") private int status; @Field("solr_created") private Date created; @Field("solr_updated") private Date updated; //... //setter&amp;getter&amp;各种构造器重载，别忘了空构造&#125; managed-schema，solr域配置 12345678910111213141516171819&lt;!-- &lt;field name="solr_id" type="plong" stored="true" required="true" indexed="false" /&gt; --&gt; &lt;field name="solr_title" type="text_ik" stored="true" indexed="true" required="true"/&gt; &lt;field name="solr_sell_point" type="text_ik" stored="true" indexed="true" required="true"/&gt; &lt;field name="solr_price" type="plong" stored="true" indexed="true" required="true"/&gt; &lt;field name="solr_num" type="pint" stored="true" indexed="true" required="true"/&gt; &lt;field name="solr_barcode" type="string" stored="true" indexed="false" required="false"/&gt; &lt;field name="solr_image" type="string" stored="true" indexed="false" required="false"/&gt; &lt;field name="solr_cid" type="plong" stored="true" indexed="false" required="true"/&gt; &lt;field name="solr_status" type="pint" stored="true" indexed="true" required="true"/&gt; &lt;field name="solr_created" type="pdate" stored="true" indexed="false" required="true"/&gt; &lt;field name="solr_updated" type="pdate" stored="true" indexed="false" required="true"/&gt; &lt;!-- 复制域只是用来搜索便利，提高搜索的性能，要有多值、分词、可被索引、但不存储、无类型 --&gt; &lt;field name="tao_keywords" type="text_ik" indexed="true" stored="false" multiValued="true" /&gt; &lt;copyField source="solr_title" dest="tao_keywords" /&gt; &lt;copyField source="solr_sell_point" dest="tao_keywords" /&gt; &lt;copyField source="solr_price" dest="tao_keywords" /&gt; &lt;copyField source="solr_num" dest="tao_keywords" /&gt; &lt;copyField source="solr_status" dest="tao_keywords" /&gt;]]></content>
      <categories>
        <category>开发问题</category>
      </categories>
      <tags>
        <tag>solrJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SolrJ]]></title>
    <url>%2F2019%2F09%2F03%2FSolrJ%2F</url>
    <content type="text"><![CDATA[SolrJSolrJ是Solr的java客户端实现，通过java代码连接solr服务器，并使用。 依赖12345&lt;dependency&gt; &lt;groupId&gt;org.apache.solr&lt;/groupId&gt; &lt;artifactId&gt;solr-solrj&lt;/artifactId&gt; &lt;version&gt;8.2.0&lt;/version&gt;&lt;/dependency&gt; 对象绑定@field注解，注解中的值为，该字段对应的solr域的名称 12345678910111213141516public class Solr_pojo &#123; @Field("id") private String id; @Field("solr_title") private String title; @Field("solr_sell_point") private String sellPoint; @Field("solr_price") private Long price; ... //setter&amp;getter 单机模式URL和HttpSolrClient注意上下两个URL的区别 1234//直接指定solr的URL和core1，只能查询或更新core1内容String URL="http://my-solr-server:8983/solr/core1";SolrClient client = new HttpSolrClient(URL);QueryResponse resp = client.query(new SolrQuery("*:*")); 1234//指定solr的URL，查询或更新时要指定coreString URL="http://my-solr-server:8983/solr";SolrClient client = new HttpSolrClient(URL);QueryResponse resp = client.query("core1", new SolrQuery("*:*")); 新增和更新方式①：add(SolrInputDocument) 123456789SolrInputDocument fields = new SolrInputDocument(); fields.addField("id","224895477"); fields.addField("solr_title","shirtiny"); ...solrClient.add(fields);solrClient.commit();solrClient.close(); 方式②：addBean 12345678910Solr_pojo pojo=new Solr_pojo();//Solr_pojo是一个自定义的，与solr索引域对应的pojo类pojo.setId("224895477");pojo.setTitle("shirtiny");//...UpdateResponse response = solrClient.addBean(pojo);//把对象传入，solr会根据id进行覆盖 solrClient.commit();solrClient.close(); 其中UpdateResponse返回的是状态码和执行耗时。 删除ById: 单个：deleteById(&quot;id&quot;); 123UpdateResponse response = solrClient.deleteById("2248954774");solrClient.commit();solrClient.close(); 批量：deleteById(List); 直接创建一个id的List集合 123456789List&lt;String&gt; ids=new ArrayList&lt;&gt;(); ids.add("224895477"); ids.add("2248954771"); ids.add("2248954772"); ids.add("2248954773");UpdateResponse response = solrClient.deleteById(ids);solrClient.commit();solrClient.close(); 或 把按照一定格式，包含多个id的字符串，用split分成数组，然后再用Arrays.asList()方法把数组转成List集合 1234567String ids="224895477,2248954771,2248954772,2248954773,4564564564";String[] idSplit = ids.split(",");List&lt;String&gt; idList = Arrays.asList(idSplit);UpdateResponse response = solrClient.deleteById(ids);solrClient.commit();solrClient.close(); ByQuery:deleteByQuery(&quot;x:x&quot;);删除所有查询到的数据。 123UpdateResponse response = solrClient.deleteByQuery("solr_title:手机");solrClient.commit();solrClient.close(); 查询基本查询1234567891011SolrQuery query=new SolrQuery("*:*");QueryResponse response = solrClient.query(query);solrClient.close();//或SolrQuery query=new SolrQuery();query.set("q","solr_title:手机 AND solr_sell_point:清仓 OR solr_title:老年人"); QueryResponse response = solrClient.query(query);//tips://df设置默认搜索域，设置默认域后q值不用加字段名query.set("df","myKeyWords");query.set("q","手机"); 结果筛选 set方式 1query.set("fq","solr_price:[* TO 9999]","solr_title:联通"); setFilterQueries方式 1query.setFilterQueries("solr_price:[* TO 9999]","solr_title:联通"); addFilterQuery方式 12query.addFilterQuery("solr_price:[* TO 9999]");query.addFilterQuery("solr_title:联通"); 结果排序 addSort，SolrQuery.ORDER.asc顺序，SolrQuery.ORDER.desc倒序 123query.addSort("solr_price", SolrQuery.ORDER.asc);//价格顺序query.addSort("solr_title", SolrQuery.ORDER.desc);//标题倒序query.addSort("score", SolrQuery.ORDER.desc);//匹配得分倒序 结果分页 setStart、setRows 1234int pageNum=5;int rows=60;query.setStart((pageNum-1)*rows);//start=（当前页数-1）*rowsquery.setRows(rows);//每页条数 结果回显 set 1query.set("fl","*,score");//*表示显示全部信息，score表示增加匹配得分的显示 setFields 1query.setFields("solr_title","score"); 关键字高亮1234567891011121314//开启高亮功能query.setHighlight(true);//添加需要高亮的字段（域）query.addHighlightField("solr_title");query.addHighlightField("solr_price");//高亮前缀query.setHighlightSimplePre("&lt;em&gt;");//高亮后缀query.setHighlightSimplePost("&lt;/em&gt;");//查询QueryResponse response = solrClient.query(query);//拿到高亮集合Map&lt;String, Map&lt;String, List&lt;String&gt;&gt;&gt; highlighting = response.getHighlighting(); 响应集合 可直接将结果转为对象集合 12QueryResponse queryResponse = solrClient.query(query);List&lt;Solr_pojo&gt; solr_pojos = queryResponse.getBeans(Solr_pojo.class); 响应头 header包括查询的值、查询的条件、耗时、状态码、响应类型等信息。 1NamedList&lt;Object&gt; header = queryResponse.getHeader(); Results结果集、结果属性 查询结果 1234567891011121314151617//获取查询的结果集SolrDocumentList results = response.getResults();//查询到的结果集 results.getNumFound();//共查询到多少条数据 results.getMaxScore();//关键字的最大匹配得分 results.getStart();//偏移量，即分页的start，正常分页的话是(当前页码-1)*rows//遍历得到单个结果对象List&lt;Solr_pojo&gt; solrPojos=new ArrayList&lt;&gt;(); for (SolrDocument result:results)&#123; String id = (String) result.getFieldValue("id"); // String title = (String) result.get("solr_title"); String title = (String)result.getFieldValue("solr_title"); System.out.println(id+"\t"+title); Solr_pojo solrPojo=new Solr_pojo(id,title); solrPojos.add(solrPojo); &#125; System.out.println(solrPojos); 高亮域替换查询结果 123456789101112131415List&lt;Solr_pojo&gt; solrPojos=new ArrayList&lt;&gt;(); //拿到高亮区域 Map&lt;String, Map&lt;String, List&lt;String&gt;&gt;&gt; highlighting = response.getHighlighting(); for (SolrDocument result:results)&#123; String id =(String) result.get("id");//从result拿到id Map&lt;String, List&lt;String&gt;&gt; listMap = highlighting.get(id);//因为高亮区域与结果中的id是相同的，所以可以通过上述id取到高亮区域的&lt;高亮域名，value数组&gt;的集合 List&lt;String&gt; solr_titles = listMap.get("solr_title");//通过高亮域名，拿到高亮值value的数组 String title = solr_titles.get(0);//list里只有1个值，index的0号位置，便是高亮的值了 System.out.println(id+"\t"+title); Solr_pojo solrPojo=new Solr_pojo(id,title); solrPojos.add(solrPojo); &#125; System.out.println(solrPojos); 集群模式使用的SolrClient，由HttpSolrClient，变为CloudSolrClient，然后要记得设置默认索引集合，其他与单机模式一样。 123CloudSolrClient client=new CloudSolrClient("192.168.249.131:2181,192.168.249.131:2182,192.168.249.131:2183");client.setDefaultCollection("collection1");]]></content>
      <categories>
        <category>学习经验</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>solr</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[说 明]]></title>
    <url>%2F2019%2F09%2F03%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Hello HexoQuick Start Create a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[Redis分布式锁]]></title>
    <url>%2F2019%2F08%2F23%2FRedis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%2F</url>
    <content type="text"><![CDATA[收藏：Redis实现分布式锁1.前提准备1.1.学习目标 知道什么是分布式锁 知道分布式锁的几种实现方式知道Redis分布式锁原理 学会Lua脚本的编写学学如何执行Lua脚本掌握Redission的使用 1.2.知识准备必须的前置知识包括： Redis的基本命令** Spring的Java配置方式 JDK中的线程同步方式，例如synchronize关键字，Lock 等** 下列知识如果也会，听课会更轻松： SpringBoot基本使用 SpringDataRedis的基本使用 zookeeper的使用 2.什么是分布式锁在讨论分布式锁前，我们先假设一个业务场景： 2.1.业务场景我们假设一个这样的业务场景： 在电商中，用户购买商品需要扣减商品库存，一般有两种扣减库存方式： 下单减库存 优点：用户体验好，下单成功，库存直接扣除，用户支付不会出现库存不足情况 缺点：用户一直不付款，这个商品的库存就会被占用，其他人就无法购买了。支付减库存 优点：不会导致库存被恶意锁定，对商家有利 缺点：用户体验不好，用户支付时可能商品库存不足了，会导致用户交易失败 那么，我们一般为了用户体验，会采用下单减库存。但是为了解决下单减库存的缺陷，会创建一个定时 任务，定时去清理超时未支付的订单。 在这个定时任务中，需要完成的业务步骤主要包括： 查询超时未支付订单，获取订单中商品信息 修改这些未支付订单的状态，为已关闭 恢复订单中商品扣减的库存 如图： {width=”6.115095144356955in” height=”3.26in”} 但是，如果我们给订单服务搭建一个100台服务节点的集群，那么就会在同一时刻有100个定时任务触发 并执行，设想一下这样的场景： 订单服务A执行了步骤1，但还没有执行步骤B 订单服务B执行了步骤1，于是查询到了与订单服务A查询到的一样的数据订单服务A执行步骤2和3，此时订单中对应商品的库存已经恢复了 订单服务B也执行了步骤2和步骤3，此时订单中对应商品的库存再次被增加 库存被错误的恢复了多次， 。 就像这样： {width=”6.17472987751531in” height=”3.239374453193351in”} 因为任务的并发执行，出现了线程安全问题，商品库存被错误的增加了多次，你能想到解决办法吗？ 2.2.为什么需要分布式锁对于线程安全问题，我们都很熟悉了，传统的解决方案就是对线程操作资源的代码加锁。如图： {width=”6.13799978127734in” height=”3.96in”} 理想状态下，加了锁以后，在当前订单服务执行时，其它订单服务需要等待当前订单服务完成业务后才 能执行，这样就避免了线程安全问题的发生。 但是，这样真的能解决问题吗？ 答案时否定的，为什么呢。 2.2.1.线程锁我们通常使用的synchronized或者Lock都是线程锁，对同一个JVM进程内的多个线程有效。因为锁的本质 是内存中存放一个标记，记录获取锁的线程时谁，这个标记对每个线程都可见。 获取锁：就是判断标记中是否已经有线程存在，如果有，则获取锁失败，如果没有，在标记中记录 当前线程 释放锁：就是删除标记中保存的线程，并唤醒等待队列中的其它线程 因此，锁生效的前提是： 互斥：锁的标记只有一个线程可以获取共享：标记对所有线程可见 然而我们启动的多个订单服务，就是多个JVM，内存中的锁显然是不共享的，每个JVM进程都有自己的 锁，自然无法保证线程的互斥了，如图： {width=”6.1806266404199475in” height=”3.9875in”} 要解决这个问题，就必须保证各个订单服务能够共享内存中的锁标记，此时，分布式锁就闪亮登场了！ 2.2.2.分布式锁线程锁时一个多线程可见的内存标记，保证同一个任务，同一时刻只能被多线程中的某一个执行。但是 这样的锁在分布式系统中，多进程环境下， 就达不到预期的效果了。 {width=”6.1075295275590555in” height=”4.5625in”} 分布式锁实现有多种方式，其原理都基本类似，只要满足下列要求即可： 多进程可见：多进程可见，否则就无法实现分布式效果 互斥（）：同一时刻，只能有一个进程获得锁，执行任务后释放锁可重入（可选）：同一个任务再次获取改锁不会被死锁 阻塞锁（可选）：获取失败时，具备重试机制，尝试再次获取锁性能好（可选）：效率高，应对高并发场景 高可用：避免锁服务宕机或处理好宕机的补救措施 常见的分布式锁实现方案包括： 等 3.Redis实现分布式锁按照上面的分析，实现分布是锁要满足五点：多进程可见，互斥，可重入，阻塞，高性能，高可用等。 我们来看看Redis如何满足这些需求。 3.1.版本1-基本实现第一次尝试，我们先关注其中必须满足的2个条件： 多进程可见 互斥，锁可释放 多进程可见 首先Redis本身就是基于JVM之外的，因此满足多进程可见的要求。 互斥 互斥就是说只能有一个进程获取锁标记，这个我们可以基于Redis的setnx指令来实现。setnx是set when not exits的意思。当多次执行setnx命令时，只有第一次执行的才会成功并返回1，其它情况返回0： {width=”6.15452646544182in” height=”1.9121872265966755in”} 多个进程来对同一个key执行setnx操作，肯定只有一个能执行成功，其它一定会失败，满足了互斥的需 求。 释放锁 释放锁其实只需要把锁的key删除即可，使用del xxx指令。不过，仔细思考，如果在我们执行del之前， 服务突然宕机，那么锁岂不是永远无法删除了？！ 为了避免因服务宕机引起锁无法释放问题，我们可以在获取锁的时候，给锁加一个有效时间，当时间超 出时，就会自动释放锁，这样就不会死锁了。 但时setnx指令没有设置时间的功能，我们要借助于set指令，然后结合set的 NX和PX参数来完成。 {width=”6.120077646544182in” height=”1.3715616797900263in”} 其中可以指定这样几个参数： EX：过期时长，单位是秒PX：过期时长，单位是毫秒NX：等同于setnx {width=”6.157244094488189in” height=”2.1743744531933507in”} 因此，获取和释放锁的基本流程如图： {width=”6.160136701662292in” height=”4.308957786526684in”} 步骤如下： 1、通过set命令设置锁 2、判断返回结果是否是OK Nil，获取失败，结束或重试（自旋锁） OK，获取锁成功 执行业务 释放锁，DEL 删除key即可 3、异常情况，服务宕机。超时时间EX结束，会自动释放锁 3.2.版本2-互斥性刚才的初级版本中，会有一定的安全问题。 大家思考一下，释放锁就是用DEL语句把锁对应的key给删除，有没有这么一种可能性： 3个进程：A和B和C，在执行任务，并争抢锁，此时A获取了锁，并设置自动过期时间为10s A开始执行业务，因为某种原因，业务阻塞，耗时超过了10秒，此时锁自动释放了 B恰好此时开始尝试获取锁，因为锁已经自动释放，成功获取锁 A此时业务执行完毕，执行释放锁逻辑（删除key），于是B的锁被释放了，而B其实还在执行业务 此时进程C尝试获取锁，也成功了，因为A把B的锁删除了。 问题出现了：B和C同时获取了锁，违反了互斥性！ 如何解决这个问题呢？我们应该在删除锁之前，判断这个锁是否是自己设置的锁，如果不是（例如自己 的锁已经超时释放），那么就不要删除了。 那么问题来了：如何得知当前获取锁的是不是自己呢？ 我们可以在set 锁时，存入当前线程的唯一标识！删除锁前，判断下里面的值是不是与自己标识释放一致，如果不一致，说明不是自己的锁，就不要删除了。 流程如图： {width=”6.123056649168854in” height=”4.335in”} 3.3.版本3-重入性接下来我们来看看分布式锁的第三个特性，重入性。 如果我们在获取锁以后，执行代码的过程中，再次尝试获取锁，执行setnx肯定会失败，因为锁已经存在 了。这样有可能导致死锁，这样的锁就是不可重入的。 如何解决呢？ 当然是想办法改造成可重入锁。 3.3.1.重入锁什么叫做可重入锁呢？ 可重入锁可以避免因同一线程中多次获取锁而导致死锁发生。 那么，如何实现可重入锁呢？ 获取锁：首先尝试获取锁，如果获取失败，判断这个锁是否是自己的，如果是则允许再次获取， 而且必须记录重复获取锁的次数。 释放锁：释放锁不能直接删除了，因为锁是可重入的，如果锁进入了多次，在最内层直接删除锁， 导致外部的业务在没有锁的情况下执行，会有安全问题。因此必须获取锁时累计重入的次数，释 放时则减去重入次数，如果减到0，则可以删除锁. 因此，存储在锁中的信息就必须包含：key、线程标识、重入次数。不能再使用简单的key-value结构， 这里推荐使用hash结构： key：lock hashKey：线程信息hashValue：重入次数，默认1 3.4.2.流程图需要用到的一些Redis命令包括： EXISTS key：判断一个Key是否存在 HEXISTS key field：判断一个hash的field是否存在HSET key field value ：给一个hash的field设置一个值 HINCRBY key field increment：给一个hash的field值增加指定数值EXPIRE key seconds：给一个key设置过期时间 DEL key：删除指定key 具体流程如图： {width=”6.1191557305336834in” height=”6.7425in”} 下面我们假设锁的key为” 获取锁的步骤： 1、判断lock是否存在 “，hashKey是当前线程的id：” “，锁自动释放时间假设为20 存在，说明有人获取锁了，下面判断是不是自己的锁判断当前线程id作为hashKey是否存在： 不存在，说明锁已经有了，且不是自己获取的，锁获取失败，end 存在，说明是自己获取的锁，重入次数+1： 2、不存在，说明可以获取锁， 3、设置锁自动释放时间， 释放锁的步骤： 1、判断当前线程id作为hashKey是否存在： 不存在，说明锁已经失效，不用管了 ，去到步骤3 存在，说明锁还在，重入次数减1： 2、判断重入次数是否为0： 为0，说明锁全部释放，删除key： ，获取新的重入次数 大于0，说明锁还在使用，重置有效时间： 3.4.Lua脚本上面探讨的Redis锁实现方案都忽略了一个非常重要的问题：原子性问题。无论是获取锁，还是释放锁 的过程，都是有多行Redis指令来完成的，如果不能保证这些Redis命令执行的原子性，则整个过程都是 不安全的。 而Redis中支持以Lua脚本来运行多行命令，并且保证整个脚本运行的原子性。 接下来，我们分几块来学习Lua脚本的使用： Redis中如何执行Lua脚本 Lua脚本的基本语法 编写上述分布式锁对应的Lua脚本 3.4.1.Redis中如何执行Lua脚本与操作Lua相关的命令如下： 其中我们会用到的几个： {width=”4.520832239720035in” height=”0.8958333333333334in”} 直接执行一段脚本，参数包括： script：脚本内容，或者脚本地址 numkeys：脚本中用到的key的数量，接下来的numkeys个参数会作为key参数，剩下的作为arg参数 key：作为key的参数，会被存入脚本环境中的KEYS数组，角标从1开始 arg：其它参数，会被存入脚本环境中的ARGV数组，角标从1开始 示例： ，其中： ：就是脚本的内容，直接返回字符串，没有别的命令 ：就是说没有用key参数，直接返回 效果： {width=”4.416666666666667in” height=”0.90625in”} {width=”5.458332239720035in” height=”0.875in”} 将一段脚本编译并缓存起来，生成一个SHA1值并返回，作为脚本字典的key，方便下次使用。 参数script就是脚本内容或地址。 以之前案例中的的脚本为例： {width=”4.510416666666667in” height=”0.9583333333333334in”} 此处返回的 就是脚本缓存后得到的sha1值。 在脚本字典中，每一个这样的sha1值，对应一段解析好的脚本： {width=”5.958333333333333in” height=”2.0729166666666665in”}{width=”4.666666666666667in” height=”0.8854166666666666in”} 与EVAL类似，执行一段脚本，区别是通过脚本的sha1值，去脚本缓存中查找，然后执行，参数： sha1：就是脚本对应的sha1值 我们用刚刚缓存的脚本为例： {width=”5.802083333333333in” height=”0.9583333333333334in”} 3.4.2.Lua脚本的基本语法Lua的详细语法大家可以参考网站上的一些教学，例如： [Lua菜鸟教程]{.underline}，任何语言都是从基本的如：变量、数据类型、循环、逻辑判断、运算、数组等入手。相信熟悉java的你应该可以快速上手Lua。 我们的分布式锁脚本中，主要用到的是对Redis指令的调用，还有些变量声明等。因此我们从这几块入手，看一些简单命令即可： 变量声明 声明一个局部变量，用local关键字即可： 这样的逻辑判断，再加上一 打印结果 条件控制 循环语句： 注意，使用break可以跳出循环。 大家能否利用上述语法编写一个猜数字的小游戏？ 提示： 可以用来读取一个用户输入的数字 代码示例： {width=”4.885415573053368in” height=”2.9791666666666665in”} Lua调用Redis指令 当我们再Redis中允许Lua脚本时，有一个内置变量redis，并且具备两个函数： redis.call(&quot;命令名称&quot;, 参数1， 参数2 ...) : 执行指定的redis命令，执行遇到错误会直接返回错误 redis.pcall(&quot;命令名称&quot;, 参数1， 参数2 ...) : 执行指定的redis命令，执行遇到错误会错误以Lua表的形式返回 例如： 这行Lua脚本的含义就是执行Redis命令： 不过，我们编写脚本时并不希望把set后面的key和value写死，而是可以由调用脚本的人来指定，把key 和value作为参数传入脚本中执行。 还记得redis中的EVAL命令吗？ EVAL执行脚本时可以接受参数，key和arg，并且会用两个内置变量（数组格式）来接受用户传入的key和 arg参数： KEYS：用来存放key参数 ARGV：用来存放除Key以外的参数 我们在脚本中，可以从数组中根据角标（Lua中数组角标时从1开始）取出用户传入的参数，像这样： 而后，我们在执行脚本时可以动态指定key及需要存放的value值： {width=”6.136999125109361in” height=”1.6149989063867016in”} 3.4.3.编写分布式锁的Lua脚本接下来，我们就可以将上面的分布式锁思路用Lua脚本来实现了。 1）普通互斥锁先看版本2的实现： 获取锁：直接使用客户端的set nx ex 命令即可，无需脚本 释放锁：因为要判断锁中的标识是否时自己的，因此需要脚本，如下： 参数的含义说明： KEYS[1]： 就 是 锁 的 key， 比 如 &quot;lock&quot; ARGV[1]：就是线程的唯一标识，可以时随机字符串 2）可重入锁：首先是获取锁： 然后是释放锁： 3.5.Redis客户端调用Lua脚本编写完成，还需要通过客户端来调用lua脚本，封装一个获取锁和释放锁的工具。 首先我们创建一个工程： {width=”6.12042104111986in” height=”4.25in”} 填写信息： {width=”6.12041447944007in” height=”4.25in”} 选择依赖： {width=”6.117843394575678in” height=”3.625in”} 在配置文件中引入Redis的地址信息： 3.5.1.锁接口首先定义一个锁接口，定义锁中的方法： 3.5.2.实现类我们通过Spring提供的RedisTemplate来操作lua脚本， 脚本： 中提供了一个方法，用来执行Lua {width=”6.12090113735783in” height=”1.5795833333333333in”} 包含3个参数： RedisScript&lt;T&gt; script ：封装了Lua脚本的对象 List&lt;K&gt; keys ：脚本中的key的值 Object ... args ：脚本中的参数的值 因此，要执行Lua脚本，我们需要先把脚本封装到象： 通过RedisScript中的静态方法： 对象中，有两种方式来构建 对 {width=”6.161678696412948in” height=”2.835in”} 这个方法接受两个参数： 返回值类型 需要把脚本内容写到代码中，作为参数传递，不够优雅。 自己创建DefaultRedisScript 另一种方式，就是自己去创建 的实现类 的对象： {width=”6.1378707349081365in” height=”1.0420833333333333in”} 可以把脚本文件写到classpath下的某个位置，然后通过加载这个文件来获取脚本内容，并设置给 实例。 此处我们选择方式二，方便后期对脚本文件的维护。首先在classpath中编写两个Lua脚本文件： {width=”0.1667432195975503in” height=”0.1667432195975503in”}1556162696842 然后编写一个新的RedisLock实现：ReentrantRedisLock，利用静态代码块来加载脚本并初始化： {width=”3.46875in” height=”2.6145833333333335in”} 其中，加载脚本文件的代码如下： 然后实现RedisLock接口，实现其中的抽象方法，完整代码如下： /** * 存入的线程信息的前缀，防止与其它JVM中线程信息冲突 */ private final String ID_PREFIX = UUID.randomUUID().toString(); public ReentrantRedisLock(StringRedisTemplate redisTemplate, String key) { this.redisTemplate = redisTemplate; this.key = key; } private static final DefaultRedisScript&lt;Long&gt; LOCK_SCRIPT; private static final DefaultRedisScript&lt;Object&gt; UNLOCK_SCRIPT; static { // 加载释放锁的脚本 LOCK_SCRIPT = new DefaultRedisScript&lt;&gt;(); LOCK_SCRIPT.setScriptSource(new ResourceScriptSource(new ClassPathResource(&quot;lock.lua&quot;))); LOCK_SCRIPT.setResultType(Long.class); // 加载释放锁的脚本 UNLOCK_SCRIPT = new DefaultRedisScript&lt;&gt;(); UNLOCK_SCRIPT.setScriptSource(new ResourceScriptSource(new ClassPathResource(&quot;unlock.lua&quot;))); } // 锁释放时间 private String releaseTime; @Override public boolean tryLock(long releaseTime) { // 记录释放时间 this.releaseTime = String.valueOf(releaseTime); // 执行脚本 Long result = redisTemplate.execute( LOCK_SCRIPT, Collections.singletonList(key), ID_PREFIX + Thread.currentThread().getId(), this.releaseTime); // 判断结果 return result != null &amp;&amp; result.intValue() == 1; } @Override public void unlock() { // 执行脚本 redisTemplate.execute( UNLOCK_SCRIPT, Collections.singletonList(key), ID_PREFIX + Thread.currentThread().getId(), this.releaseTime); } } 3.5.3.获取锁的工厂定义一个工厂，用来生成锁对象： 3.5.4.测试我们定义一个定时任务，模拟清理订单的任务： 接下来，我们给任务加锁： 将启动项复制2份（或多分），测试锁是否能生效： {width=”2.3854155730533684in” height=”1.59375in”} 修改第二个启动项的端口，避免冲突 {width=”6.144573490813649in” height=”2.096874453193351in”} {width=”6.098069772528434in” height=”1.1906244531933508in”}同时启动2个启动项，查看日志： 第一个服务： 第二个服务： {width=”6.074061679790026in” height=”1.1549989063867017in”} 可以看到： 在13:39:50秒时，8081服务获取锁失败，而8082服务获取锁成功在13:40:00秒时，8082服务获取锁失败，而8081服务获取锁成功 3.6.Redis锁的其它特性在一开始介绍分布式锁时，我们聊到分布式锁要满足的一些特性： 多进程可见：多进程可见，否则就无法实现分布式效果 互斥：同一时刻，只能有一个进程获得锁，执行任务后释放锁可重入（可选）：同一个任务再次获取改锁不会被死锁 阻塞锁（可选）：获取失败时，具备重试机制，尝试再次获取锁性能好（可选）：效率高，应对高并发场景 高可用：避免锁服务宕机或处理好宕机的补救措施 目前在Redis中我们已经实现了： 多进程可见 互斥 可重入 剩下的几个特性也并非不能满足，例如： 1）阻塞我们现在的代码中获取锁失败就立即结束，可以修改代码为失败后不断重试，直到某个指定的超时时间 后才结束。 // 订阅频道，等待锁被释放通知 countdownlauch while(true){ // 获取锁，如果超过一定时间，break; } pubsub 发布订阅， 2）性能好Redis一向以出色的读写并发能力著称，因此这一点没有问题 3）高可用单点的redis无法保证高可用，因此一般我们都会给redis搭建主从集群。但是，主从集群无法保证分布式 锁的高可用特性。 在Redis官网上，也对这种单点故障做了说明： 因此，Redis的作者又给出了一种新的算法来解决整个高可用问题，即Redlock算法，摘抄了算法的介绍 如下： 不过，这种方式并不能完全保证锁的安全性，因为我们给锁设置了自动释放时间，因此某些极端特例 下，依然会导致锁的失败，例如下面的情况： {width=”6.139452099737532in” height=”2.376561679790026in”} 如果Client 1 在持有锁的时候，发生了一次很长时间的FGC 超过了锁的过期时间。锁就被释放了。这个时候Client 2 又获得了一把锁，提交数据。 这个时候Client 1 从FGC 中苏醒过来了，又一次提交数据。冲突发生了 还有一种情况也是因为锁的超时释放问题，例如： Client 1 从A、B、D、E五个节点中，获取了A、B、C三个节点获取到锁，我们认为他持有了锁这个时候，由于B 的系统时间比别的系统走得快，B就会先于其他两个节点优先释放锁。 Clinet 2 可以从B、D、E三个节点获取到锁。在整个分布式系统就造成两个Client 同时持有锁了。 不过，这种因为时钟偏移造成的问题，我们可以通过延续超时时间、调整系统时间减少时间偏移等方式 来解决。Redis作者也对超时问题给出了自己的意见： 简单来说就是在获取锁成功后，监视锁的失效时间，如果即将到期，可以再次去申请续约，延长锁的有 效期。 我们可以采用看门狗（watch dog)解决锁超时问题，/开启一个任务，这个任务在 获取锁之后10秒后，重新向redis发起请求，重置有效期，重新执行expire 3.7.Redission如果按照Redlock算法来实现分布式锁，加上各种安全控制，代码会比较复杂。而开源的Redission框架 就帮我们实现了各种基于Redis的分布式锁，包括Redlock锁。 {width=”5.679721128608924in” height=”0.8232983377077865in”}Redisson是一个在Redis的基础上实现的Java驻内存数据网格（In-Memory Data Grid）。它不仅提供了一系列的分布式的Java常用对象，还提供了许多分布式服务。其中包括( BitSet , Set , Multimap , SortedSet , Map , List , Queue , BlockingQueue , Deque , BlockingDeque , Semaphore , Lock , AtomicLong , CountDownLatch , Publish / Subscribe , Bloom filter , Remote service , Spring cache , Executor service , Live Object service , Scheduler service ) Redisson提供了使用Redis的最简单和最便捷的方法。Redisson的宗旨是促进使用者对Redis的关注分离（Separation of Concern），从而让使用者能够将精力更集中地放在处理业务逻辑上。 [官网地址]{.underline}： [https://redisson.or]{.underline}g/ [GitHub地址]{.underline}： [https://]{.underline}gi[thub.com/redisson/redisson]{.underline} 看看Redission能实现的功能： {width=”5.541665573053368in” height=”2.7916666666666665in”} 3.7.1.快速入门1）依赖使用起来非常方便，首先引入依赖： 2）配置然后通过Java配置的方式，设置Redis的地址，构建RedissionClient客户端： 3）常用API介绍：RedissClient中定义了常见的锁： {width=”5.541666666666667in” height=”2.0208333333333335in”} 获取锁对象后，可以通过 方法获取锁： {width=”6.109687226596676in” height=”1.28625in”} 有3个重载的方法，可以控制锁是否需要重试来获取： 三个参数：获取锁，设置锁等待时间 、释放时间 ，时间单位 。 如果获取锁失败后，会在 然获取失败，则认为获取锁失败； 减去获取锁用时的剩余时间段内继续尝试获取锁，如果依 获取锁后，如果超过 leaseTime 未释放，为避免死锁会自动释放。 两个参数：获取锁，设置锁等待时间 time 、时间单位 。释放时间 按照默认的30s 空参：获取锁， 默认0s，即获取锁失败不重试， 默认30s 任务执行完毕，使用 方法释放锁： {width=”3.302082239720035in” height=”1.03125in”} 4）完整案例使用Redission来代替我们之前自定义锁的测试案例： {width=”6.154997812773403in” height=”4.420311679790026in”} 代码如下： 3.7.2.Redisson实现细节首先看空参获取lock的方法： 这里的核心有两部分： 一个是获取锁的方法：tryLockInnerAsync 一个是自动续期（看门狗）的方法：scheduleExpirationRenewal 1）获取锁首先看tryLockInnerAsync，这个方法是获取锁的方法： 这里的核心就是这段Lua脚本，看看与我们写的是不是基本类似呢，区别是最后返回了这个key的剩余有 效期。 2）锁的自动续期锁如果在执行任务时自动过期，就会引起各种问题， 因此我们需要在锁过期前自动申请续期，这个被称为watch dog，看门狗。 刷新时间的代码： 刷新过期时间的代码： 3）带阻塞的获取锁阻塞获取锁，会在获取失败以后重试，不过会设置失败超时时间。 waitTime：获取锁重试的最大超时时间，默认为0 leaseTime：释放锁的最大时间，默认时30秒unit：时间单位 代码如下： }); } acquireFailed(threadId); return false; } // 如果获取到订阅消息，说明锁已经释放，可以重试 try { time -= System.currentTimeMillis() - current; if (time &lt;= 0) { acquireFailed(threadId); return false; } // 循环重试获取锁 while (true) { long currentTime = System.currentTimeMillis(); ttl = tryAcquire(leaseTime, unit, threadId); // lock acquired if (ttl == null) { return true; } time -= System.currentTimeMillis() - currentTime; if (time &lt;= 0) { acquireFailed(threadId); return false; } // waiting for message currentTime = System.currentTimeMillis(); if (ttl &gt;= 0 &amp;&amp; ttl &lt; time) { getEntry(threadId).getLatch().tryAcquire(ttl, TimeUnit.MILLISECONDS); } else { getEntry(threadId).getLatch().tryAcquire(time, TimeUnit.MILLISECONDS); } time -= System.currentTimeMillis() - currentTime; if (time &lt;= 0) { acquireFailed(threadId); return false; } } } finally { unsubscribe(subscribeFuture, threadId); } } 获取锁失败，会通过Redis的pubsub功能订阅一个频道，如果释放锁会通知自己，然后再重试获取锁。 4）释放锁释放锁代码基本一致： 下面跟到unlockAsync方法： 然后关键是释放锁的代码： 代码基本一致，就是再最后释放成功后，通过 知锁已经释放，那些再等待的其它线程，就可以获取锁了。 发布了一条消息，通 3.8.总结总结来看，Redis实现分布式锁，具备下列优缺点： 优点：实现简单，性能好，并发能力强，如果对并发能力有要求，推荐使用 缺点：可靠性有争议，极端情况会出现锁失效问题，如果对安全要求较高，不建议使用 zookeeper实现分布式锁Zookeeper是一种提供配置管理、分布式协同以及命名的中心化服务。 zk的模型是这样的：zk包含一系列的节点，叫做znode，就好像文件系统一样每个znode表示一个目录， 然后znode有一些特性： 有序节点：假如当前有一个父节点为 ，我们可以在这个父节点下面创建子节点； zookeeper提供了一个可选的有序特性，例如我们可以创建子节点”/lock/node-“并且指明有序，那 么zookeeper在生成子节点时会根据当前的子节点数量自动添加整数序号 也就是说，如果是第一个创建的子节点，那么生成的子节点为 ，下一个节 点则为 ，依次类推。 临时节点：客户端可以建立一个临时节点，在会话结束或者会话超时后，zookeeper会自动删除该 节点。 事件监听：在读取数据时，我们可以同时对节点设置事件监听，当节点数据或结构变化时， zookeeper会通知客户端。当前zookeeper有如下四种事件： 节点创建节点删除 节点数据修改子节点变更 基于以上的一些zk的特性，我们很容易得出使用zk实现分布式锁的落地方案： 使用zk的临时节点和有序节点，每个线程获取锁就是在zk创建一个临时有序的节点，比如在/lock/ 目录下。 创建节点成功后，获取/lock目录下的所有临时节点，再判断当前线程创建的节点是否是所有的节 点的序号最小的节点 如果当前线程创建的节点是所有节点序号最小的节点，则认为获取锁成功。 如果当前线程创建的节点不是所有节点序号最小的节点，则对节点序号的前一个节点添加一个事 件监听。 比如当前线程获取到的节点序号为 ,则对 ,然后所有的节点列表为 这个节点添加一个事件监听器。 如果锁释放了，会唤醒下一个序号的节点，然后重新执行第3步，判断是否自己的节点序号是最小。 比如 释放了， 监听到时间，此时节点集合为 ,则 为最 小序号节点，获取到锁。 Curator是一个zookeeper的开源客户端，也提供了分布式锁的实现。 来看看锁的一些特性Zookeeper是否满足： 互斥：因为只有一个最小节点，满足互斥特性 锁释放：使用Zookeeper可以有效的解决锁无法释放的问题，因为在创建锁的时候，客户端会在ZK 中创建一个临时节点，一旦客户端获取到锁之后突然挂掉（Session连接断开），那么这个临时节 点就会自动删除掉。其他客户端就可以再次获得锁。 阻塞锁：使用Zookeeper可以实现阻塞的锁，客户端可以通过在ZK中创建顺序节点，并且在节点上 绑定监听器，一旦节点有变化，Zookeeper会通知客户端，客户端可以检查自己创建的节点是不是 当前所有节点中序号最小的，如果是，那么自己就获取到锁，便可以执行业务逻辑了。 可重入：使用Zookeeper也可以有效的解决不可重入的问题，客户端在创建节点的时候，把当前客 户端的主机信息和线程信息直接写入到节点中，下次想要获取锁的时候和当前最小的节点中的数据 比对一下就可以了。如果和自己的信息一样，那么自己直接获取到锁，如果不一样就再创建一个临 时的顺序节点，参与排队。 高可用：使用Zookeeper可以有效的解决单点问题，ZK是集群部署的，只要集群中有半数以上的机 器存活，就可以对外提供服务。 高性能：Zookeeper集群是满足强一致性的，因此就会牺牲一定的性能，与Redis相比略显不足 总结： 优点：使用非常简单，不用操心释放问题、阻塞获取问题缺点：性能比Redis稍差一些 总结分布式锁释放方式多种多样，每种方式都有自己的优缺点，我们应该根据业务的具体需求，先择合适的 实现。 Redis实现：实现比较简单，性能最高，但是可靠性难以维护 Zookeeper实现：实现最简单，可靠性最高，性能比redis略低]]></content>
      <categories>
        <category>收藏</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>分布式锁</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[solr-tomcat集成]]></title>
    <url>%2F2019%2F08%2F23%2Fsolr-tomcat%2F</url>
    <content type="text"><![CDATA[将solr从Jetty转到Tomcat、ik分词、数据库索引 复制一份tomcat，然后再solr根目录的同级目录新建一个文件夹用于存放集成后的solr，自定义名字solr_home 修改apache-tomcat-8.5.37\conf\server.xml，修改tomcat涉及的端口号，这里可以都加1 123&lt;Server port="8006" shutdown="SHUTDOWN"&gt;&lt;Connector connectionTimeout="20000" port="8081" protocol="HTTP/1.1" redirectPort="8443"/&gt; &lt;Connector port="8010" protocol="AJP/1.3" redirectPort="8443"/&gt; 若已经配置了tomcat的环境变量，需要编辑bin/startup.bat，将if not “%CATALINA_HOME%” == “” goto gotHome注释掉( 前面加rem是注释)： 1REM if not "%CATALINA_HOME%" == "" goto gotHome 参考： 默认启动其他tomcat的问题 Rem注释 在solr_home文件夹下，新建logs文件夹，然后修改Tomcat\bin下的catalina.bat，增加solr.log.dir系统变量，指定solr日志记录存放地址。 在set “JAVA_OPTS=%JAVA_OPTS% %JSSE_OPTS%”这句下，新增： 1set "JAVA_OPTS=%JAVA_OPTS% -Dsolr.log.dir=D:\SolrRepo\solr_home\logs" solr.log.dir的值为刚刚新建的logs文件夹的绝对路径。 把solr-8.0.0目录下的server/solr-webapp/webapps放置到tomcat/webapp的目录下，重命名为solr。 将solr-8.0.0\server\lib\ext下的所有jar包拷贝到tomcat里的webapps\solr\WEB-INF\lib 将solr-8.0.0\server\lib下 除jetty以外的jar拷贝到tomcat里的webapps\solr\WEB-INF\lib 将solr-8.0.0\dist下 jar包也拷贝到tomcat里的webapps\solr\WEB-INF\lib 放数据库连接驱动的jar包，如mysql-connector-java.jar到webapps\solr\WEB-INF\lib，顺便往solr-8.2.0\dist文件夹下也放一份数据库连接驱动的jar包。 在tomcat里的webapps\solr\WEB-INF下创建classes文件夹，将solr/server/resources下的配置文件拷贝到新建的classes文件夹里 把solr-8.0.0 里面的solr文件夹下全部的内容放入solr_home文件夹内（相当于复制一份solr文件夹，然后改名为solr_home ） 把solr-8.0.0下contrib和dist文件夹也拷贝至solr_home目录下 在solr_home目录下新建new_core文件夹；并拷贝solr-8.0.0\example\example-DIH\solr\db目录下所有文件至SolrHome\new_core下。 修改solr-home\new_core\conf\solrconfig.xml文件下的对应内容为：(改一下相对路径，加个mysql的连接驱动) 1234567891011121314&lt;lib dir="$&#123;solr.install.dir:../&#125;/contrib/extraction/lib" regex=".*\.jar" /&gt; &lt;lib dir="$&#123;solr.install.dir:../&#125;/dist/" regex="solr-cell-\d.*\.jar" /&gt; &lt;lib dir="$&#123;solr.install.dir:../&#125;/contrib/clustering/lib/" regex=".*\.jar" /&gt; &lt;lib dir="$&#123;solr.install.dir:../&#125;/dist/" regex="solr-clustering-\d.*\.jar" /&gt; &lt;lib dir="$&#123;solr.install.dir:../&#125;/contrib/langid/lib/" regex=".*\.jar" /&gt; &lt;lib dir="$&#123;solr.install.dir:../&#125;/dist/" regex="solr-langid-\d.*\.jar" /&gt; &lt;lib dir="$&#123;solr.install.dir:../&#125;/contrib/velocity/lib" regex=".*\.jar" /&gt; &lt;lib dir="$&#123;solr.install.dir:../&#125;/dist/" regex="solr-velocity-\d.*\.jar" /&gt; &lt;lib dir="$&#123;solr.install.dir:../&#125;/dist/" regex="ojdbc\d.*\.jar" /&gt; &lt;lib dir="$&#123;solr.install.dir:../&#125;/dist/" regex="solr-dataimporthandler\d.*\.jar" /&gt; &lt;lib dir="$&#123;solr.install.dir:../&#125;/dist/" regex="mysql-connector-java-*\.jar" /&gt; 最后solr_home的文件夹内容： 配置tomcat→webApp→solr→WEB_INF下的web.xml，添加配置（指定solr数据源的位置）： 123456&lt;env-entry&gt; &lt;env-entry-name&gt;solr/home&lt;/env-entry-name&gt; &lt;!--这里填你建的solr_home文件夹的绝对路径 --&gt; &lt;env-entry-value&gt;D:\SolrRepo\solr_home&lt;/env-entry-value&gt; &lt;env-entry-type&gt;java.lang.String&lt;/env-entry-type&gt; &lt;/env-entry&gt; 然后把 &lt;1security-constraint&gt;整个注释掉,目的是防止tomcat 403问题 1234567891011121314151617 &lt;!-- &lt;security-constraint&gt; &lt;web-resource-collection&gt; &lt;web-resource-name&gt;Disable TRACE&lt;/web-resource-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;http-method&gt;TRACE&lt;/http-method&gt; &lt;/web-resource-collection&gt; &lt;auth-constraint/&gt; &lt;/security-constraint&gt; &lt;security-constraint&gt; &lt;web-resource-collection&gt; &lt;web-resource-name&gt;Enable everything but TRACE&lt;/web-resource-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;http-method-omission&gt;TRACE&lt;/http-method-omission&gt; &lt;/web-resource-collection&gt; &lt;/security-constraint&gt;--&gt; 添加ik中文分词器ik分词器jar包 将下载好的jar包放入Tomcat 8.5/webapps/solr/WEB-INF/lib目录中 打开solr_home/new_core/conf目录中的managed-schema文件，添加如下代码： 1234567891011&lt;!-- ik分词器 --&gt; &lt;fieldType name="text_ik" class="solr.TextField"&gt; &lt;analyzer type="index"&gt; &lt;tokenizer class="org.wltea.analyzer.lucene.IKTokenizerFactory" useSmart="false" conf="ik.conf"/&gt; &lt;filter class="solr.LowerCaseFilterFactory"/&gt; &lt;/analyzer&gt; &lt;analyzer type="query"&gt; &lt;tokenizer class="org.wltea.analyzer.lucene.IKTokenizerFactory" useSmart="true" conf="ik.conf"/&gt; &lt;filter class="solr.LowerCaseFilterFactory"/&gt; &lt;/analyzer&gt; &lt;/fieldType&gt; 在界面Analysis的Analyse Fieldname / FieldType:中选text_ik即可使用。 添加数据库索引 在solr_home\你的核心\conf下的managed-schema，配置域信息，用来接收数据库数据的对应字段 123456789101112131415161718192021 &lt;!--solr需要数据有个固定的主键id，而那个id是由solr配置好的，名为id的域。所以应该把数据库表的主键id绑定到solr自带的名为id的域上，所以不需要再自定一个其他名称的id &lt;field name="solr_id" type="plong" stored="true" required="true" indexed="false" /&gt; --&gt; &lt;field name="solr_title" type="text_ik" stored="true" indexed="true" required="true"/&gt; &lt;field name="solr_sell_point" type="text_ik" stored="true" indexed="true" required="true"/&gt; &lt;field name="solr_price" type="plong" stored="true" indexed="true" required="true"/&gt; &lt;field name="solr_num" type="pint" stored="true" indexed="true" required="true"/&gt; &lt;field name="solr_barcode" type="string" stored="true" indexed="false" required="false"/&gt; &lt;field name="solr_image" type="string" stored="true" indexed="false" required="false"/&gt; &lt;field name="solr_cid" type="plong" stored="true" indexed="false" required="true"/&gt;&lt;!--注意，数据库中tinyInt的数据类型，在solr默认提供的数据类型中，是找不到对应类型的。 --&gt; &lt;field name="solr_status" type="pint" stored="true" indexed="true" required="true"/&gt; &lt;field name="solr_created" type="pdate" stored="true" indexed="false" required="true"/&gt; &lt;field name="solr_updated" type="pdate" stored="true" indexed="false" required="true"/&gt; &lt;!-- 复制域只是用来搜索便利，提高搜索的性能，要有多值、分词、可被索引、但不存储、无类型 --&gt; &lt;field name="tao_keywords" type="text_ik" indexed="true" stored="false" multiValued="true" /&gt; &lt;copyField source="solr_title" dest="tao_keywords" /&gt; &lt;copyField source="solr_sell_point" dest="tao_keywords" /&gt; &lt;copyField source="solr_price" dest="tao_keywords" /&gt; &lt;copyField source="solr_num" dest="tao_keywords" /&gt; &lt;copyField source="solr_status" dest="tao_keywords" /&gt; 在solr_home\你的核心\conf下的db-data-config.xml配置数据库数据信息，&amp;符号需要使用&amp;amp;来替换，如果数据库表中有tinyInt的数据类型，需要设置tinyInt1isBit=false或true，详情： solr中tinyInt1isBit的设置 solr中tinyInt转boolean 123456789101112131415161718192021222324&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;dataConfig&gt; &lt;dataSource type="JdbcDataSource" driver="com.mysql.jdbc.Driver" url="jdbc:mysql://localhost:3306/taotao?useUnicode=true&amp;amp;characterEncoding=UTF-8&amp;amp;useSSL=false&amp;amp;tinyInt1isBit=false" user="root" password="123456" /&gt; &lt;document&gt; &lt;!--自定义的实体名，查询语句。根据返回结果，将数据库表的字段名与solr域名绑定 --&gt; &lt;entity name="taoDB" query="SELECT * from tb_item" &gt; &lt;field column="id" name="id" /&gt; &lt;field column="title" name="solr_title" /&gt; &lt;field column="sell_point" name="solr_sell_point" /&gt; &lt;field column="price" name="solr_price" /&gt; &lt;field column="num" name="solr_num" /&gt; &lt;field column="barcode" name="solr_barcode" /&gt; &lt;field column="image" name="solr_image" /&gt; &lt;field column="cid" name="solr_cid" /&gt; &lt;field column="status" name="solr_status" /&gt; &lt;field column="created" name="solr_created" /&gt; &lt;field column="updated" name="solr_updated" /&gt; &lt;/entity&gt; &lt;/document&gt;&lt;/dataConfig&gt; tips： 在xml的sql语句中，不能直接用大于号、小于号要用转义字符 解决方式： 转义字符： &amp;lt;是&lt;，小于号 &amp;gt;是&gt;，大于号 &amp;amp;是&amp;，和 &amp;apos;是’，单引号 &amp;quot;是”，双引号 或 使用&lt;![CDATA[]]&gt;标记： &lt;![CDATA[ state &lt;= 3 ]]&gt; 不过要注意，&lt;![CDATA[ ]]&gt;标记的sql语句中的&lt;where&gt; &lt;if&gt;等标签不会被解析 参考文章： https://blog.csdn.net/weixin_42613538/article/details/89516198 https://blog.csdn.net/ailian_f/article/details/89407754 https://blog.csdn.net/l1336037686/article/details/80723636]]></content>
      <categories>
        <category>学习经验</category>
      </categories>
      <tags>
        <tag>solr</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[solr]]></title>
    <url>%2F2019%2F08%2F23%2Fsolr%2F</url>
    <content type="text"><![CDATA[收藏：Solr专栏https://space.bilibili.com/437629430/article 01. 02. 03. 04. 05. 06 07 08 09]]></content>
      <categories>
        <category>收藏</category>
      </categories>
      <tags>
        <tag>solr</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[千 与 千寻的神隐]]></title>
    <url>%2F2019%2F08%2F22%2F%E5%8D%83%E4%B8%8E%E5%8D%83%E5%AF%BB%E7%9A%84%E7%A5%9E%E9%9A%90%2F</url>
    <content type="text"><![CDATA[千 と 千尋の神隠し搬运： Bilibili@风格里哦 在B站浏览该页：传送门 var ap = new APlayer({ element: document.getElementById("aplayer-TdhYPAdl"), narrow: false, autoplay: true, showlrc: false, music: { title: "One Summer's Day", author: "久石譲", url: "http://server.shirtiny.cn/music/One Summer's Day.mp3", pic: "https://file.moetu.org/images/2019/08/20/78da987214933136431ddaca0eba896b0cccbc458f84e1ec.th.png", lrc: "" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); > 直接搬原网页[#狡猾.jpg]]]></content>
      <categories>
        <category>闲谈</category>
      </categories>
      <tags>
        <tag>千与千寻</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[队列、环形队列]]></title>
    <url>%2F2019%2F08%2F19%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E9%98%9F%E5%88%97%E3%80%81%E7%8E%AF%E5%BD%A2%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[数据结构与算法单队列ArrayQueue、环形队列CircleArrayQueue 1. 单队列 队列是一个有序列表，可以使用数组或链表来实现。 先入先出，先存入队列的数据先取出，如排队。 单队列的3个属性： MaxSize表示队列最大容量 rear表示尾指针，指向队列末尾，记录该数据的下标，随着数据输入而改变。 而front表示头指针，一般让它指向队列头的前一个位置，记录队列头的前一个下标，先自增后取值。 单队列生命周期 开始时，rear与front均指向-1，这是初始状态。 每把一个数据放入队列，尾指针rear就会+1。当rear=MaxSize-1时，队列满。 每把一个数据从队列中取出，头指针front+1。当front==rear时，即头指针与尾指针指向同一处，此时队列为空。无法再取，所以，front&lt;=rear。 单队列使用完一次后，便不能再次使用。 单队列数组实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154package Queue;import java.util.Scanner;public class ArrayQueue &#123; private int MaxSize; private int front; private int rear; private int[] array; //初始化数组 ArrayQueue(int MaxSize)&#123; this.MaxSize=MaxSize; array=new int[MaxSize]; front=-1; rear=-1; &#125; //判断队列是否满 boolean isFull()&#123; return rear==MaxSize-1; &#125; //判断队列是否为空 boolean isEmpty()&#123; return rear==front; &#125; //向队列增加数据 void add(int data)&#123; if (isFull())&#123;//判断队列是否已满 System.out.println("队列已满，无法存"); &#125;else &#123; rear++;//尾指针后移 array[rear]=data;//赋值 System.out.println("尾指针+1："+rear); &#125; &#125; //从队列取数据 int get()&#123; if (isEmpty())&#123;//判断队列是否为空 throw new RuntimeException("队列为空，无法取"); &#125;else &#123; front++; System.out.println("头指针+1："+front); return array[front];//取值 &#125; &#125; //显示整个队列 void show()&#123; if (isEmpty())&#123;//判断队列是否为空 throw new RuntimeException("队列空，无数据"); &#125;else &#123; for (int data:array)&#123;//打印数组 System.out.print(data+"\t"); &#125; System.out.println(); &#125; &#125; //展示队列头数据 int showFront()&#123; if (isEmpty())&#123;//判断队列是否为空 throw new RuntimeException("队列空，无数据"); &#125;else &#123; return array[front+1];//返回头数据，指针不变 &#125; &#125; //展示队列尾数据 int showRear()&#123; if (isEmpty())&#123;//判断队列是否为空 throw new RuntimeException("队列空，无数据"); &#125;else &#123; return array[rear];//返回尾数据，指针不变 &#125; &#125; //测试队列 public static void main(String[] args) &#123; //创建一个队列对象，容量为3 ArrayQueue queue = new ArrayQueue(3); char key;//接收用户输入 Scanner scanner = new Scanner(System.in);// boolean loop = true; //输出一个菜单 while(loop) &#123; System.out.println("s(show): 显示队列"); System.out.println("e(exit): 退出程序"); System.out.println("a(add): 添加数据到队列"); System.out.println("g(get): 从队列取出数据"); System.out.println("h(head): 查看队列头的数据"); System.out.println("r(rear): 查看队列尾的数据"); key = scanner.next().charAt(0);//接收一个字符 switch (key) &#123; case 's': queue.show(); break; case 'a': System.out.println("输入一个数"); int value = scanner.nextInt(); queue.add(value); break; case 'g': //取出数据 try &#123; int res = queue.get(); System.out.printf("取出的数据是%d\n", res); &#125; catch (Exception e) &#123; // TODO: handle exception System.out.println(e.getMessage()); &#125; break; case 'h': //查看队列头的数据 try &#123; int res = queue.showFront(); System.out.printf("队列头的数据是%d\n", res); &#125; catch (Exception e) &#123; // TODO: handle exception System.out.println(e.getMessage()); &#125; break; case 'r': //查看队列头的数据 try &#123; int rear = queue.showRear(); System.out.printf("队列尾的数据是%d\n", rear); &#125; catch (Exception e) &#123; // TODO: handle exception System.out.println(e.getMessage()); &#125; break; case 'e': //退出 scanner.close(); loop = false; break; default: break; &#125; &#125; System.out.println("程序退出~~"); &#125;&#125; 2. 环形队列相比单队列，环形队列属性设定有所变动： 属性的设定 初始时front = rear = 0，而不是-1 rear指向队列尾数据的下一个空间，在尾数据后预留一个空间，即rear指向的位置不放值。（预留空间是为了区分队列空和队列满，空元素作为队尾的标志） front直接指向头数据 容量为MaxSize-1 环形队列生命周期 开始时，rear与front均指向0，这是初始状态。 每把一个数据放入队列，尾指针rear就会+1。当（rear+1)%MaxSize=front 时，队列满。因为rear指向尾数据的下一个空间，队列满时rear+1自然等于front。之所以%MaxSize取模是因为：环形队列指针的值会一直增加，%Maxsize会得到周期性的值，就像角度会加到362度、750度一样。温馨提示：%运算符：比如2%3就是，2除以3等于0余2，所以2%3就是2，而3%2=1。 每把一个数据从队列中取出，头指针front+1。当front==rear时，即头指针与尾指针指向同一处，此时队列为空。重点这里不再像单队列，在循环中，front与rear的大小关系是不定的，有时rear&gt;front，有时front&gt;rear。为什么会出现这种情形呢，rear&gt;front的情形好理解，尾与头嘛。至于front&gt;rear的情形，我们类比一下角度，假如rear在361度的位置，front在365度的位置，别忘了是环形。由此可以得出，环形队列中的元素总数为：(rear-front+MaxSize)%MaxSize，始终用尾减去头，又因为rear-front的值正负不定，所以要加上MaxSize再%MaxSize。 环形队列可循环使用。遍历时，从front开始，一直到front+size结束，size是当前元素个数，因为元素个数size会随着出队进队变化，变化量与front的移动量是一致的 环形队列数组实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172package Queue;import java.util.Scanner;public class CircleQueue &#123; private int MaxSize; private int front; private int rear; private int[] array; //初始化数组 CircleQueue(int MaxSize)&#123; this.MaxSize=MaxSize; array=new int[MaxSize]; front=0; rear=0; &#125; //判断队列是否满 boolean isFull()&#123; return (rear+1)%MaxSize==front; &#125; //判断队列是否为空 boolean isEmpty()&#123; return rear==front; &#125; //向队列增加数据 void add(int data)&#123; if (isFull())&#123;//判断队列是否已满 System.out.println("队列已满，无法存"); &#125;else &#123; array[rear%MaxSize]=data;//赋值 rear++;//尾指针后移 System.out.println("尾指针+1："+rear%MaxSize); &#125; &#125; //从队列取数据 int get()&#123; if (isEmpty())&#123;//判断队列是否为空 throw new RuntimeException("队列为空，无法取"); &#125;else &#123; int data=array[front%MaxSize]; front++; System.out.println("头指针+1："+front%MaxSize); return data;//取值 &#125; &#125; //队列中的有效元素总数 int getSize()&#123; return (rear-front+MaxSize)%MaxSize; &#125; //显示整个队列 void show()&#123; if (isEmpty())&#123;//判断队列是否为空 System.out.println("队列为空"); &#125;else &#123; for (int i=front%MaxSize;i&lt;front%MaxSize+getSize();i++)&#123;//打印数组 System.out.println(array[i]+"\t"); &#125; System.out.println(); &#125; &#125; //展示队列头数据 int showFront()&#123; if (isEmpty())&#123;//判断队列是否为空 throw new RuntimeException("队列空，无数据"); &#125;else &#123; return array[front%MaxSize];//返回头数据，指针不变 &#125; &#125; //展示队列尾数据 int showRear()&#123; if (isEmpty())&#123;//判断队列是否为空 throw new RuntimeException("队列空，无数据"); &#125;else &#123; return array[(rear-1)%MaxSize];//返回尾数据，指针不变 &#125; &#125; //测试队列 public static void main(String[] args) &#123; //创建一个队列对象，容量为5 CircleQueue queue = new CircleQueue(5); char key;//接收用户输入 Scanner scanner = new Scanner(System.in);// boolean loop = true; //输出一个菜单 while(loop) &#123; System.out.println("s(show): 显示队列"); System.out.println("e(exit): 退出程序"); System.out.println("a(add): 添加数据到队列"); System.out.println("g(get): 从队列取出数据"); System.out.println("z(getSize): 查看有效元素个数"); System.out.println("h(head): 查看队列头的数据"); System.out.println("r(rear): 查看队列尾的数据"); key = scanner.next().charAt(0);//接收一个字符 switch (key) &#123; case 's': queue.show(); break; case 'a': System.out.println("输入一个数"); int value = scanner.nextInt(); queue.add(value); break; case 'g': //取出数据 try &#123; int res = queue.get(); System.out.printf("取出的数据是%d\n", res); &#125; catch (Exception e) &#123; // TODO: handle exception System.out.println(e.getMessage()); &#125; break; case 'h': //查看队列头的数据 try &#123; int res = queue.showFront(); System.out.printf("队列头的数据是%d\n", res); &#125; catch (Exception e) &#123; // TODO: handle exception System.out.println(e.getMessage()); &#125; break; case 'r': //查看队列头的数据 try &#123; int rear = queue.showRear(); System.out.printf("队列尾的数据是%d\n", rear); &#125; catch (Exception e) &#123; // TODO: handle exception System.out.println(e.getMessage()); &#125; break; case 'z': //查看队列头的数据 try &#123; int size = queue.getSize(); System.out.printf("元素个数是%d\n", size); &#125; catch (Exception e) &#123; // TODO: handle exception System.out.println(e.getMessage()); &#125; break; case 'e': //退出 scanner.close(); loop = false; break; default: break; &#125; &#125; System.out.println("程序退出~~"); &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue基础]]></title>
    <url>%2F2019%2F08%2F19%2FVue2%2F</url>
    <content type="text"><![CDATA[Vue基础知识Vue生命周期&amp;Hook回调函数 beforeCreate、Created等是钩子回调的函数，通过这些函数，我们可以指定在Vue生命周期的某一阶段做一些事情。 回调函数示例 1234567891011121314const app =new Vue(&#123; el:'#id', data:obj, methods:&#123;...&#125;, //回调函数 beforeCreate:function()&#123;...&#125;, mounted:function()&#123;...&#125; ...&#125;) //其中，data的obj对象为。data可以是对象。 const obj=&#123; count:0, i:'haha' &#125; 指令 v-once：执行一次后，内容不再随数据的变化再改变。 v-html：对内容进行html解析渲染 v-pre：不对内容进行任何解析 v-cloak：斗篷，vuejs生效前保留v-cloak，vuejs生效后删除所有v-cloak属性，可以用css控制v-cloak来达成我们的目的，比如当vuejs延迟加载的时候，不让用户看到未被vuejs渲染的源码内容。 v-text：如v-text=”message”，把message数据作为字符串显示，会覆盖掉原本的内容 v-one:如v-on:click=”message”，监听某个事件 V-bind动态的绑定特殊意义的属性，如a标签的href，img标签的src，还有class等，动态绑定数据。 简写为：:，是语法糖。 静态实例1234567891011121314151617181920212223&lt;div id="app"&gt; &lt;h1&gt;v-bind指令&lt;/h1&gt; &lt;a v-bind:href="aURL"&gt;blog&lt;/a&gt; &lt;img v-bind:src="imgURL"&gt;&lt;br&gt; v-bind简写:&lt;img :src="imgURL"&gt;&lt;/div&gt; &lt;script&gt; //url对象 const url=&#123; aURL:"http://shirtiny.cn",imgURL:"https://file.moetu.org/images/2019/08/20/b46b2347f21fd46f60baf163a57da47c2b17554146847392.png" &#125;; const app=new Vue(&#123; el:'#app',//挂载 data:url//数据对象 &#125;) &lt;/script&gt; 如绑定class、style的实例对象： 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;style&gt; .red&#123; color: red; &#125; .line&#123; text-decoration: underline; &#125;&lt;/style&gt;&lt;div id="app"&gt; &lt;!--&lt;h1 class="class" v-bind:class="&#123;key1:value,key2:value&#125;"&gt;v-bind指令&lt;/h1&gt;--&gt; &lt;p class="class" v-bind:class="&#123;red:isRed,line:isLine&#125;"&gt;v-bind指令&lt;/p&gt;&lt;br&gt; &lt;!-- 原class与v-bind:class可以共存，它们会在被渲染时合并（2+1=3）不会覆盖 --&gt; &lt;button v-on:click="changeRed"&gt;切换颜色&lt;/button&gt; &lt;button v-on:click="changeLine"&gt;下划线&lt;/button&gt; &lt;!--或者 --&gt; &lt;p v-bind:class="getClass()"&gt;v-bind指令&lt;/p&gt;&lt;br&gt; &lt;!-- style也一样的--&gt; &lt;p :style="&#123;color:'red',fontSize:'50px'&#125;"&gt;v-bind指令&lt;/p&gt;&lt;br&gt; &lt;/div&gt; &lt;script&gt; const app=new Vue(&#123; el:'#app',//挂载 data:&#123;//class状态 isRed:true, isLine:false &#125;, methods:&#123; changeRed:function () &#123; this.isRed=!this.isRed//在true和false之间切换 &#125;, changeLine:function () &#123; this.isLine=!this.isLine &#125;, getClass:function () &#123; return &#123;red: this.isRed,line: this.isLine&#125;; &#125; &#125; &#125;) &lt;/script&gt; 对象用｛｝括起来，是key：value的形式，{key1:value,key2:value} 原class与v-bind:class可以共存，它们会在被渲染时合并（2+1=3）不会覆盖 数组： 12345678910111213141516171819202122232425&lt;div id="app"&gt; &lt;p v-bind:class="[isRed,isLine]"&gt;v-bind指令&lt;/p&gt;&lt;br&gt; &lt;!--或--&gt; &lt;p v-bind:class="getClass()"&gt;v-bind指令&lt;/p&gt;&lt;br&gt; &lt;!-- style也一样，数组里放对象，或放键值对都行--&gt; &lt;p :style="[hahaColor,hahaLine]"&gt;v-bind指令&lt;/p&gt;&lt;br&gt;&lt;/div&gt; &lt;script&gt; const app=new Vue(&#123; el:'#app',//挂载 data:&#123;//class状态 isRed:"red", isLine:"line", hahaColor:&#123;color:'red',fontSize:'50px'&#125;,//对象 hahaLine:&#123;'text-decoration':'underline'&#125;//对象 &#125;, methods:&#123; getClass:function () &#123; return [this.isRed,this.isLine]; &#125; &#125; &#125;) &lt;/script&gt;]]></content>
      <categories>
        <category>休闲</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>javaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jedis的Spring整合、Redis缓存]]></title>
    <url>%2F2019%2F08%2F18%2FSpring%E6%95%B4%E5%90%88Jedis%2F</url>
    <content type="text"><![CDATA[Spring整合Jedis使用RedisJedis是Redis的java版本客户端的实现，通过它，我们可以轻松的创建一个jedis对象来操作Redis数据库，或者将Redis做为缓存使用。 Maven依赖Official Releases 1234567&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;type&gt;jar&lt;/type&gt; &lt;scope&gt;compile&lt;/scope&gt;&lt;/dependency&gt; Snapshots 1234567&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;3.2.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 基本使用单节点 直连方式 12345678//通过连接和端口号，就可以拿到jedis对象Jedis jedis=new Jedis("192.168.1.105",6379);//通过jedis对象，使用命令来操作即可jedis.set("abc","123");String abc = jedis.get("abc");//记得释放 jedis.close(); 连接池方式 1234567891011//先拿到连接池对象 JedisPool pool=new JedisPool("192.168.1.105",6379);//再通过连接拿到实例Jedis jedis = pool.getResource(); jedis.set("gg","2");String gg = jedis.get("gg");//释放连接jedis.close();pool.close(); 多节点集群 12345678910111213141516171819202122//nodes，需要一个Set集合来存放节点（因为set内是不重复的），实现使用HashSetSet&lt;HostAndPort&gt; nodes=new HashSet&lt;HostAndPort&gt;();//单个nodeHostAndPort node1 = new HostAndPort("192.168.1.105", 7001);//放入nodes集合nodes.add(node1);//推荐写法 nodes.add(new HostAndPort("192.168.1.105",7002)); nodes.add(new HostAndPort("192.168.1.105",7003)); nodes.add(new HostAndPort("192.168.1.105",7004)); nodes.add(new HostAndPort("192.168.1.105",7005)); nodes.add(new HostAndPort("192.168.1.105",7006)); //通过node集合拿到jedisCluster对象，就可以使用命令了JedisCluster jedisCluster=new JedisCluster(nodes); jedisCluster.set("222","aaaa");String a222 = jedisCluster.get("222");//可选释放jedisCluster.close(); tips： JedisAPI测试 Set和List Spring整合开发测试时常用单节点模式，需要时切换到集群模式。 单节点 123456789101112131415161718192021222324252627282930 &lt;!-- jedis客户端单机版 --&gt; &lt;bean id="redisClient" class="redis.clients.jedis.JedisPool"&gt; &lt;constructor-arg name="host" value="192.168.25.153"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name="port" value="6379"&gt;&lt;/constructor-arg&gt; &lt;!--连接池配置，不配的话会有个默认配置，可以用 --&gt; &lt;constructor-arg name="poolConfig" ref="jedisPoolConfig"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt;&lt;!-- 连接池配置 --&gt; &lt;bean id="jedisPoolConfig" class="redis.clients.jedis.JedisPoolConfig"&gt; &lt;!-- 最大连接数 --&gt; &lt;property name="maxTotal" value="30" /&gt; &lt;!-- 最大空闲连接数 --&gt; &lt;property name="maxIdle" value="10" /&gt; &lt;!-- 每次释放连接的最大数目 --&gt; &lt;property name="numTestsPerEvictionRun" value="1024" /&gt; &lt;!-- 释放连接的扫描间隔（毫秒） --&gt; &lt;property name="timeBetweenEvictionRunsMillis" value="30000" /&gt; &lt;!-- 连接最小空闲时间 --&gt; &lt;property name="minEvictableIdleTimeMillis" value="1800000" /&gt; &lt;!-- 连接空闲多久后释放, 当空闲时间&gt;该值 且 空闲连接&gt;最大空闲连接数 时直接释放 --&gt; &lt;property name="softMinEvictableIdleTimeMillis" value="10000" /&gt; &lt;!-- 获取连接时的最大等待毫秒数,小于零:阻塞不确定的时间,默认-1 --&gt; &lt;property name="maxWaitMillis" value="1500" /&gt; &lt;!-- 在获取连接的时候检查有效性, 默认false --&gt; &lt;property name="testOnBorrow" value="true" /&gt; &lt;!-- 在空闲时检查有效性, 默认false --&gt; &lt;property name="testWhileIdle" value="true" /&gt; &lt;!-- 连接耗尽时是否阻塞, false报异常,ture阻塞直到超时, 默认true --&gt; &lt;property name="blockWhenExhausted" value="false" /&gt; &lt;/bean&gt; 集群 12345678910111213141516171819202122232425262728293031&lt;bean id="redisClient" class="redis.clients.jedis.JedisCluster"&gt; &lt;constructor-arg name="nodes"&gt; &lt;set&gt; &lt;bean class="redis.clients.jedis.HostAndPort"&gt; &lt;constructor-arg name="host" value="192.168.25.153"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name="port" value="7001"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean class="redis.clients.jedis.HostAndPort"&gt; &lt;constructor-arg name="host" value="192.168.25.153"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name="port" value="7002"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean class="redis.clients.jedis.HostAndPort"&gt; &lt;constructor-arg name="host" value="192.168.25.153"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name="port" value="7003"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean class="redis.clients.jedis.HostAndPort"&gt; &lt;constructor-arg name="host" value="192.168.25.153"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name="port" value="7004"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean class="redis.clients.jedis.HostAndPort"&gt; &lt;constructor-arg name="host" value="192.168.25.153"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name="port" value="7005"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean class="redis.clients.jedis.HostAndPort"&gt; &lt;constructor-arg name="host" value="192.168.25.153"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name="port" value="7006"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;/set&gt; &lt;/constructor-arg&gt; &lt;constructor-arg name="poolConfig" ref="jedisPoolConfig"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; 为了满足两者直接的切换，需要一个Dao层，提供同一个接口，不同的实现类。 通用接口 12345678910111213141516171819202122public interface IJedisDao &#123; String set(String key,String value); String get(String key); long hset(String hkey,String key,String value); String hget(String hkey,String key); long incr(String key); long expire(String key,int second); long ttl(String key); long del (String key); long hdel(String hkey,String key); //...&#125; 单节点模式实现类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283package com.SH.Rest.Dao.DaoImpl;import ...public class JedisDaoSingleImpl implements IJedisDao &#123; @Autowired private JedisPool jedisPool; @Override public String set(String key, String value) &#123; Jedis jedis = jedisPool.getResource(); String s = jedis.set(key, value); jedis.close(); return s; &#125; @Override public String get(String key) &#123; Jedis jedis = jedisPool.getResource(); String s = jedis.get(key); jedis.close(); return s; &#125; @Override public long hset(String hkey, String key, String value) &#123; Jedis jedis = jedisPool.getResource(); Long hset = jedis.hset(hkey, key, value); jedis.close(); return hset; &#125; @Override public String hget(String hkey, String key) &#123; Jedis jedis = jedisPool.getResource(); String s = jedis.hget(hkey, key); jedis.close(); return s; &#125; @Override public long incr(String key) &#123; Jedis jedis = jedisPool.getResource(); Long result = jedis.incr(key); jedis.close(); return result; &#125; @Override public long expire(String key, int second) &#123; Jedis jedis = jedisPool.getResource(); Long result = jedis.expire(key, second); jedis.close(); return result; &#125; @Override public long ttl(String key) &#123; Jedis jedis = jedisPool.getResource(); Long result = jedis.ttl(key); jedis.close(); return result; &#125; @Override public long del(String key) &#123; Jedis jedis = jedisPool.getResource(); Long result = jedis.del(key); jedis.close(); return result; &#125; @Override public long hdel(String hkey, String key) &#123; Jedis jedis = jedisPool.getResource(); Long result = jedis.hdel(hkey, key); jedis.close(); return result; &#125; //...&#125; 使用单点模式时的spring配置： 123456789&lt;!-- Redis客户端，单点模式，连接没配置，为默认--&gt; &lt;bean id="jedisPool" class="redis.clients.jedis.JedisPool"&gt; &lt;constructor-arg name="host" value="192.168.1.105"/&gt; &lt;constructor-arg name="port" value="6379"/&gt; &lt;/bean&gt;&lt;!--单点模式实现类--&gt; &lt;bean id="jedisDao" class="com.SH.Rest.Dao.DaoImpl.JedisDaoSingleImpl"&gt; &lt;/bean&gt; 集群模式实现类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package com.SH.Rest.Dao.DaoImpl;import ...public class JedisDaoClusterImpl implements IJedisDao &#123; //无需释放 @Autowired private JedisCluster jedisCluster; @Override public String get(String key) &#123; return jedisCluster.get(key); &#125; @Override public String set(String key, String value) &#123; return jedisCluster.set(key, value); &#125; @Override public String hget(String hkey, String key) &#123; return jedisCluster.hget(hkey, key); &#125; @Override public long hset(String hkey, String key, String value) &#123; return jedisCluster.hset(hkey, key, value); &#125; @Override public long incr(String key) &#123; return jedisCluster.incr(key); &#125; @Override public long expire(String key, int second) &#123; return jedisCluster.expire(key, second); &#125; @Override public long ttl(String key) &#123; return jedisCluster.ttl(key); &#125; @Override public long del(String key) &#123; return jedisCluster.del(key); &#125; @Override public long hdel(String hkey, String key) &#123; return jedisCluster.hdel(hkey, key); &#125; //...&#125; 使用集群模式时的spring配置： 123456789101112131415161718192021222324252627282930313233343536373839&lt;!-- Redis客户端，集群模式，连接池默认配置 --&gt;&lt;bean id="jedisCluster" class="redis.clients.jedis.JedisCluster"&gt; &lt;constructor-arg name="nodes"&gt; &lt;set&gt; &lt;bean class="redis.clients.jedis.HostAndPort"&gt; &lt;constructor-arg name="host" value="192.168.1.105"/&gt; &lt;constructor-arg name="port" value="7001"/&gt; &lt;/bean&gt; &lt;bean class="redis.clients.jedis.HostAndPort"&gt; &lt;constructor-arg name="host" value="192.168.1.105"/&gt; &lt;constructor-arg name="port" value="7002"/&gt; &lt;/bean&gt; &lt;bean class="redis.clients.jedis.HostAndPort"&gt; &lt;constructor-arg name="host" value="192.168.1.105"/&gt; &lt;constructor-arg name="port" value="7003"/&gt; &lt;/bean&gt; &lt;bean class="redis.clients.jedis.HostAndPort"&gt; &lt;constructor-arg name="host" value="192.168.1.105"/&gt; &lt;constructor-arg name="port" value="7004"/&gt; &lt;/bean&gt; &lt;bean class="redis.clients.jedis.HostAndPort"&gt; &lt;constructor-arg name="host" value="192.168.1.105"/&gt; &lt;constructor-arg name="port" value="7005"/&gt; &lt;/bean&gt; &lt;bean class="redis.clients.jedis.HostAndPort"&gt; &lt;constructor-arg name="host" value="192.168.1.105"/&gt; &lt;constructor-arg name="port" value="7006"/&gt; &lt;/bean&gt; &lt;/set&gt; &lt;/constructor-arg&gt;&lt;/bean&gt;&lt;!--集群模式实现类--&gt;&lt;bean id="jedisDao" class="com.SH.Rest.Dao.DaoImpl.JedisDaoClusterImpl"&gt;&lt;/bean&gt;&lt;!--单点模式实现类，现在是集群模式，所以注释掉这个bean--&gt; &lt;!-- &lt;bean id="jedisDao" class="com.SH.Rest.Dao.DaoImpl.JedisDaoSingleImpl"&gt; &lt;/bean&gt;--&gt; 使用示例缓存的添加不能影响正常的业务逻辑，不管缓存的情况如何，都要保证其他业务逻辑的正常运行，不可中断。 12345678910111213141516171819202122232425262728@AutoWiredprivate IJedisDao jedisDao;@Override public List&lt;Content&gt; getContentList(long id) &#123; //从缓存中取内容 try &#123; String result = jedisDao.hget(HashKEY, id + ""); if (!StringUtils.isBlank(result)) &#123;//判断缓存取出结果是否为空字符串 //把字符串转换成list List&lt;Content&gt; resultList = JsonUtils.jsonToList(result, Content.class); return resultList; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; //正常业务逻辑，根据内容分类id，数据库查询内容列表 List&lt;Content&gt; list = contentMapper.selectByid(id); //向缓存中添加内容 try &#123; //把list转换成字符串 String cacheString = JsonUtils.objectToJson(list); jedisDao.hset(HashKEY, id + "", cacheString); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; 缓存同步 当更新数据库内数据时，需要先把对应的Redis缓存删除（del删除对应key），然后再更新数据库。缓存是由服务层管理的，服务层需要提供一个删除缓存的服务，后台管理系统修改数据时，Http调用该服务即可。]]></content>
      <categories>
        <category>学习经验</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Redis</tag>
        <tag>Jedis</tag>
        <tag>SSM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis集群]]></title>
    <url>%2F2019%2F08%2F18%2FRedis%E9%9B%86%E7%BE%A4%2F</url>
    <content type="text"><![CDATA[Redis集群搭建集群描述 Redis集群至少需要奇数个主节点，因为需要投票的方式来确认某一节点的运行状况。每个主节点需要有个备份节点，提高容错。所以，假设有3个主节点，1主2从，主只写数据，从只读数据，加上备份则需要6个节点来完成集群，所以集群最少为6个。 主从关系 一般1主2从，主服务器读写，从服务器只读，内部会进行数据同步。 主机关机，从服务器依然是从，无法写数据。 从服务器重启后，需要重新建立主从关系。 哨兵 准备多台哨兵，询问主从服务器是否宕机，持续问答，心跳检查。若大多数哨兵判定主服务器无响应，便在从服务器中选出一个做主服务器，投票决定结果，若主服务器再回来，会把它设为从服务器。从服务器宕机不做什么事，不过从服务器启动时，自动设置从服务器主从关系。 主观下线：哨兵视角，看到目标服务器下线。 客观下线：实际情况，由哨兵们投票确定。 环境准备ruby环境 redis集群管理工具redis-trib.rb依赖ruby环境，首先需要安装ruby环境。 12345#使用yum之前，记得更新一下yumyum -y update#安装rubyyum install rubyyum install rubygems 安装ruby和redis的接口程序 把redis-3.0.0.gem传到服务器，然后拷贝redis-3.0.0.gem至/usr/local文件夹下。 1gem install /usr/local/redis-3.0.0.gem 集群创建因为本人没必要租6个服务器或创建6个虚拟机，这里使用6个Redis实例，同一台服务器用不同的端口表示不同的redis服务器来模拟集群。 模拟6个redis服务器，有6个redis服务器的话，只需在配置文件开启集群模式，然后运行脚本即可。 将redis安装目录bin下的文件拷贝到每个700X目录内，同时将redis源码目录src下的redis-trib.rb拷贝到redis-cluster目录下。 1234567891011#创建一个文件夹，用于存放6个redis实例mkdir /usr/local/redis-cluster##依次复制并创建6个文件夹，分别存放对应redis节点cp -r /usr/local/redis/bin /usr/local/redis-cluster/7001cp -r /usr/local/redis/bin /usr/local/redis-cluster/7002cp -r /usr/local/redis/bin /usr/local/redis-cluster/7003cp -r /usr/local/redis/bin /usr/local/redis-cluster/7004cp -r /usr/local/redis/bin /usr/local/redis-cluster/7005cp -r /usr/local/redis/bin /usr/local/redis-cluster/7006#同时将redis源码目录src下的redis-trib.rb拷贝到redis-cluster目录下。cp /usr/local/redis-5.0.5/src/redis-trib.rb /usr/local/redis-cluster 修改每个节点目录下的redis.conf配置文件 把port 改为对应的端口号、bind 设为 0.0.0.0、cluster-enabled 设为yes（#去掉）。 tips：/是搜索 1234567#修改每个节点目录下的redis.conf配置文件vi /usr/local/redis-cluster/7001/redis.confvi /usr/local/redis-cluster/7002/redis.confvi /usr/local/redis-cluster/7003/redis.confvi /usr/local/redis-cluster/7004/redis.confvi /usr/local/redis-cluster/7005/redis.confvi /usr/local/redis-cluster/7006/redis.conf 修改完成后，依次开启每个节点，然后运行集群脚本。 1234567891011121314151617#依次开启每个节点/usr/local/redis-cluster/7001/src/redis-server /usr/local/redis-cluster/7001/redis.conf/usr/local/redis-cluster/7002/src/redis-server /usr/local/redis-cluster/7002/redis.conf/usr/local/redis-cluster/7003/src/redis-server /usr/local/redis-cluster/7003/redis.conf/usr/local/redis-cluster/7004/src/redis-server /usr/local/redis-cluster/7004/redis.conf/usr/local/redis-cluster/7005/src/redis-server /usr/local/redis-cluster/7005/redis.conf/usr/local/redis-cluster/7006/src/redis-server /usr/local/redis-cluster/7006/redis.conf#查看运行状态ps -ef | grep redis#开放防火墙firewall-cmd --zone=public --add-port=7005/tcp --permanent#... 运行脚本集群 1234/usr/local/redis-cluster/redis-trib.rb create --replicas 1 192.168.1.103:7001 192.168.1.103:7002 192.168.1.103:7003 192.168.1.103:7004 192.168.1.103:7005 192.168.1.103:7006redis-cli --cluster create 192.168.1.103:7001 192.168.1.103:7002 192.168.1.103:7003 192.168.1.103:7004 192.168.1.103:7005 192.168.1.103:7006 --cluster-replicas 1 集群操作1234#其中-c表示以集群方式连接redis，-h指定ip地址，-p指定端口号./redis-cli -c -h 192.168.1.103:7001 -p 7001 # 查询集群结点信息cluster nodes 添加节点 1./redis-trib.rb add-node 192.168.1.103:7007 192.168.1.103:7001 hash槽分配 redis集群有16384个槽，集群中的每个结点分配自已槽，通过查看集群结点可以看到槽占用情况。 连接上集群 12#连接集群中任意一个可用结点都行./redis-trib.rb reshard 192.168.1.103:7001 输入要分配的槽数量 输入接收槽的结点id 通过cluster nodes查看7007结点id为15b809eadae88955e36bcdbb8144f61bbbaf38fb 输入： 115b809eadae88955e36bcdbb8144f61bbbaf38fb 输入源结点id，这里输入all 输入yes开始移动槽到目标结点id 添加从节点 添加7008从结点，将7008作为7007的从结点。 12#主节点id 添加节点的ip和端口 集群中已存在节点ip和端口./redis-trib.rb add-node --slave --master-id 执行： 12#cad9f7413ec6842c971dbcc2c48b4ca959eb5db4 是7007结点的id，可通过cluster nodes查看。./redis-trib.rb add-node --slave --master-id cad9f7413ec6842c971dbcc2c48b4ca959eb5db4 192.168.101.3:7008 192.168.101.3:7001 tips: 如果原来该结点在集群中的配置信息已经生成cluster-config-file指定的配置文件中（如果cluster-config-file没有指定则默认为nodes.conf），这时可能会报错： [ERR] Node XXXXXX is not empty. Either the node already knows other nodes (check with CLUSTER NODES) or contains some key in database 0 解决方法是删除生成的配置文件nodes.conf，删除后再执行./redis-trib.rb add-node指令。 删除节点 1./redis-trib.rb del-node 127.0.0.1:7005 4b45eb75c8b428fbd77ab979b85080146a9bc017 删除已经占有hash槽的结点会失败，报错如下： [ERR] Node 127.0.0.1:7005 is not empty! Reshard data away and try again. 需要将该结点占用的hash槽分配出去。]]></content>
      <categories>
        <category>学习经验</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue快速入门]]></title>
    <url>%2F2019%2F08%2F18%2FVue%2F</url>
    <content type="text"><![CDATA[Vue框架快速入门实例环境准备 Vue.js【最好下载到本地】 开发工具：WebStorm ## 第一个Vue实例新建html 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!--div#app tab 快捷创建--&gt;&lt;div id="app"&gt; &#123;&#123;m&#125;&#125; &lt;h1&gt;&#123;&#123;h&#125;&#125;&lt;/h1&gt;&lt;/div&gt;&lt;!--引入vue.js --&gt;&lt;script src="js/vue.js"&gt;&lt;/script&gt; &lt;!--Vue实例 --&gt;&lt;script&gt; const a1=new Vue(&#123; el: '#app', data: &#123; m: 'haha', h: 'hehe' &#125; &#125;)&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 运行结果： 总结: const 定义常量，let定义变量。（代替var） new Vue({}) 创建Vue对象 el: ‘#app’ ，把&lt;div id=”app&gt;挂载给Vue对象管理 data:{m: ‘haha’ }，data对象中，有个属性m的值为haha ，Mustache语法，取m的值 编程范式由传统的命令式到声明式，数据与视图分离。 ## 简单列表html： 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!--div#app tab 快捷创建--&gt;&lt;div id="app"&gt; &lt;h1&gt;&#123;&#123;m&#125;&#125;&lt;/h1&gt; &lt;ul v-for="shuju in items"&gt; &lt;li&gt;&#123;&#123;shuju&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;script src="js/vue.js"&gt;&lt;/script&gt;&lt;script&gt; const app=new Vue(&#123; el:'#app', data:&#123; m:"列表", items:["第一个数据","第二个数据","fuck","444"] &#125; &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 运行结果： 总结: items:[“第一个数据”,”第二个数据”,”fuck”,”444”] 定义一个数组 &lt; ul v-for=”shuju in items”&gt; 遍历数组，赋值给一个名为shuju的变量 &lt; li&gt;&lt; /li&gt;取出数据 是响应式，浏览器控制台输入： ## 计数器方式1 123456789101112131415&lt;div id="app"&gt; &lt;h1&gt;计数:&#123;&#123;count&#125;&#125;&lt;/h1&gt; &lt;button v-on:click="count++" &gt; + &lt;/button&gt; &lt;button v-on:click="count--" &gt; - &lt;/button&gt;&lt;/div&gt;&lt;script&gt; const app=new Vue(&#123; el:'#app', data:&#123; count:0 &#125; &#125;)&lt;/script&gt; 方式2 123456789101112131415161718192021222324252627&lt;div id="app"&gt; &lt;h1&gt;计数:&#123;&#123;count&#125;&#125;&lt;/h1&gt; &lt;button v-on:click="add" &gt; + &lt;/button&gt; &lt;button v-on:click="sub" &gt; - &lt;/button&gt;&lt;/div&gt;&lt;script&gt; const app=new Vue(&#123; el:'#app', data:&#123; count:0 &#125;, methods:&#123; add:function () &#123; this.count++; console.log('执行自增');//浏览器控制台打印 &#125;, sub:function () &#123; app.count--; console.log('执行自减');//浏览器控制台打印 &#125; &#125; &#125;)&lt;/script&gt; 总结： &lt; button v-on:click=”” &gt; vi-on监听事件，v-on:click=””监听点击事件 v-on:click=”i++”，直接使i自增 v-on:click=”add”，调用add方法 Vue对象的methods属性 定义方法： 12345methods:&#123; add:function () &#123; this.count++; console.log('执行自增');//浏览器控制台打印 &#125;,]]></content>
      <categories>
        <category>休闲</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>javaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HttpClient]]></title>
    <url>%2F2019%2F08%2F16%2FHttpClient%2F</url>
    <content type="text"><![CDATA[使用HttpClient模拟浏览器访问HttpClient 是Apache HttpComponents 下的子项目，是支持 HTTP 协议的客户端编程工具包。它被用来发送和接受 HTTP 消息，并不能处理http响应内容。 依赖12345 &lt;dependency&gt; &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt; &lt;artifactId&gt;httpclient&lt;/artifactId&gt; &lt;version&gt;4.5.6&lt;/version&gt;&lt;/dependency&gt; 基本使用Get1234567891011//httpClient的创建CloseableHttpClient httpClient = HttpClients.createDefault();//创建一个GET对象HttpGet get = new HttpGet("http://shirtiny.cn");//发送请求，得到一个response对象CloseableHttpResponse response = httpClient.execute(get);//取响应实体，转换成字符串打印HttpEntity entity = response.getEntity();String string = EntityUtils.toString(entity, "utf-8");//响应状态码int statusCode = response.getStatusLine().getStatusCode(); 当需要传递参数时，可以直接在url改，也可以使用URIBuilder构建url 参数 1234567891011//基础urlURIBuilder uriBuilder = new URIBuilder("https://api.kaaass.net/biliapi/video/resolve");//加入参数uriBuilder.addParameter("id","53175612");uriBuilder.addParameter("quality","80");//构建出urlURI uri = uriBuilder.build();//放入get请求对象中即可HttpGet get=new HttpGet(uri);//然后执行...httpClient.execute(get); POST与Get类似。当需要提交表格数据时： 123456789101112//创建一个post对象HttpPost post = new HttpPost("http://localhost:8082/httpclient/post.html");//创建一个Entity。模拟一个表单List&lt;NameValuePair&gt; kvList = new ArrayList&lt;&gt;();kvList.add(new BasicNameValuePair("username", "zhangsan"));kvList.add(new BasicNameValuePair("password", "123")); //包装成一个Entity对象StringEntity entity = new UrlEncodedFormEntity(kvList, "utf-8");//设置请求的内容post.setEntity(entity);//执行post请求CloseableHttpResponse response = httpClient.execute(post); 工具类一个方便其他服务调用的httpClient的工具类。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118package Http_Utils;import ...public class HttpClientUtil &#123; public static String doGet(String url, Map&lt;String, String&gt; param) &#123; // 创建Httpclient对象 CloseableHttpClient httpclient = HttpClients.createDefault(); String resultString = ""; CloseableHttpResponse response = null; try &#123; // 创建uri URIBuilder builder = new URIBuilder(url); if (param != null) &#123; for (String key : param.keySet()) &#123; builder.addParameter(key, param.get(key)); &#125; &#125; URI uri = builder.build(); // 创建http GET请求 HttpGet httpGet = new HttpGet(uri); // 执行请求 response = httpclient.execute(httpGet); // 判断返回状态是否为200 if (response.getStatusLine().getStatusCode() == 200) &#123; resultString = EntityUtils.toString(response.getEntity(), "UTF-8"); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; if (response != null) &#123; response.close(); &#125; httpclient.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; return resultString; &#125; public static String doGet(String url) &#123; return doGet(url, null); &#125; public static String doPost(String url, Map&lt;String, String&gt; param) &#123; // 创建Httpclient对象 CloseableHttpClient httpClient = HttpClients.createDefault(); CloseableHttpResponse response = null; String resultString = ""; try &#123; // 创建Http Post请求 HttpPost httpPost = new HttpPost(url); // 创建参数列表 if (param != null) &#123; List&lt;NameValuePair&gt; paramList = new ArrayList&lt;&gt;(); for (String key : param.keySet()) &#123; paramList.add(new BasicNameValuePair(key, param.get(key))); &#125; // 模拟表单 UrlEncodedFormEntity entity = new UrlEncodedFormEntity(paramList); httpPost.setEntity(entity); &#125; // 执行http请求 response = httpClient.execute(httpPost); resultString = EntityUtils.toString(response.getEntity(), "utf-8"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; response.close(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; return resultString; &#125; public static String doPost(String url) &#123; return doPost(url, null); &#125; public static String doPostJson(String url, String json) &#123; // 创建Httpclient对象 CloseableHttpClient httpClient = HttpClients.createDefault(); CloseableHttpResponse response = null; String resultString = ""; try &#123; // 创建Http Post请求 HttpPost httpPost = new HttpPost(url); // 创建请求内容 StringEntity entity = new StringEntity(json, ContentType.APPLICATION_JSON); httpPost.setEntity(entity); // 执行http请求 response = httpClient.execute(httpPost); resultString = EntityUtils.toString(response.getEntity(), "utf-8"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; response.close(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; return resultString; &#125;&#125; HttpClient详解 pdf文档]]></content>
      <categories>
        <category>学习经验</category>
      </categories>
      <tags>
        <tag>httpclient</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二维数组⇌稀疏数组⇌数据文件]]></title>
    <url>%2F2019%2F08%2F11%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84-%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84-%E6%95%B0%E6%8D%AE%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[数据结构与算法稀疏数组SparseArray 1. 什么是稀疏数组一个数组含有大量重复的值的时候，可以把它转化为稀疏数组来表示，这样会大量节省空间占用。 稀疏数组： 是个二维数组，只有3列，分别对应：行row、列col、值value 第一行表示原数组的行数、列数、有效值个数。（注意，0是第一行） 从第二行开始，每行都会对应一个有效值。 用row（第一列）表示有效值是在原数组中的第几行 用col（第二列）表示有效值是在原数组中的第几列 用value（第三列）表示有效值在原数组中的值 行数为原数组有效值个数+1 示例： 原数组 0，0，0，0，0 1，0，2，0，0 0，0，0，0，0 0，0，0，1，0 对应的稀疏数组： 4，5，3 //表示原数组有4行、5列、3个有效值 1，0，1 //表示一个有效值，位置在原数组的第2行、第1列、值为1 1，2，2 //同上，表示位置在原数组第2行、第3列、值为2 3，3，1 //表示位置在原数组第4行、第4列、值为1 2. 二维数组⇌稀疏数组java代码演示，相互转换的过程。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101package SparseArray;import java.util.Arrays;public class SparseArray &#123; public static void main(String[] args) &#123; //1. 新建一个二维数组 int[][] array1 = new int[4][5]; //2. 给数组赋一些值 array1[1][0]=1; array1[1][2]=2; array1[3][3]=1; //3. 格式化输出数组 for (int i=0;i&lt;array1.length;i++)&#123;//array1.length是行数 for (int j=0;j&lt;array1[0].length;j++)&#123;//array1[0].length是第0行的列数// System.out.print(array1[i][j]+"\t"); &#125;// System.out.println(); &#125; //4. 更好的输出方式foreach System.out.println("##############这是原数组1"); for (int[] row:array1)&#123; for (int value:row)&#123; System.out.print(value+"\t"); &#125; System.out.println(); &#125; //5. 转为稀疏数组，首先需要得到原数组中的有效值个数 System.out.println("##############"); int num=0; for (int[] row:array1)&#123; for(int value:row)&#123; if (value!=0)&#123; num++; &#125; &#125; &#125; System.out.println("原数组1有："+num+"个有效值"); //6. 创建稀疏数组，因为稀疏数组第一行是对原数组大小的描述，其他行都是对有效值的描述， //所以，稀疏数组行数是 原数组有效值个数+1。 int [][] sparseArray=new int[num+1][3]; //7. 对稀疏数组的第一行赋值，对应原数组的行数、列数、有效值个数 sparseArray[0][0]=4; sparseArray[0][1]=5; sparseArray[0][2]=3; //8. 为稀疏数组赋值，对原数组进行遍历，需要明确第几行第几列 int n=1; for (int i=0;i&lt;array1.length;i++)&#123; for (int j=0;j&lt;array1[0].length;j++)&#123; if (array1[i][j]!=0)&#123; sparseArray[n][0]=i; sparseArray[n][1]=j; sparseArray[n][2]=array1[i][j]; n++; &#125; &#125; &#125; //9. 输出稀疏数组 System.out.println("##############这是转换后的稀疏数组"); for (int[] row:sparseArray)&#123; for (int value:row)&#123; System.out.print(value+"\t"); &#125; System.out.println(); &#125; //10. 再恢复成原数组 // 创建一个原数组2，原数组2的行数，是稀疏数组的第一行第一列的值 // 原数组2的列数，是稀疏数组的第一行第二列的值 int[][] array2=new int[sparseArray[0][0]][sparseArray[0][1]]; //11. 把稀疏数组中的有效值读出，赋给原数组2， // 只需付给原数组2有效值，i从1开始，也就是第二行开始， // 稀疏数组第i行，第1列是有效值的行数，第2列是有效值的列数，第3列是有效值的值 // 因为稀疏数组固定只有3列，一个循环即可 for (int i=1;i&lt;sparseArray.length;i++)&#123; array2[sparseArray[i][0]][sparseArray[i][1]]=sparseArray[i][2]; &#125; //12. 输出回复后的原数组2 System.out.println("##############这是恢复后的原数组2"); for (int[] row:array2)&#123; for (int value:row)&#123; System.out.print(value+"\t"); &#125; System.out.println(); &#125; &#125;&#125; 输出结果： ##############这是原数组10 0 0 0 01 0 2 0 00 0 0 0 00 0 0 1 0 ##############原数组1有：3个有效值 ##############这是转换后的稀疏数组4 5 31 0 11 2 23 3 1 ##############这是恢复后的原数组20 0 0 0 01 0 2 0 00 0 0 0 00 0 0 1 0 3. 稀疏数组⇌数据文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//13. 将稀疏数组存入本地文件 File file =new File("D:\\aria2\\SparseArray.data"); Writer writer=new FileWriter(file); for (int[] row:sparseArray)&#123; for (int value:row)&#123; writer.write(value+"\t"); &#125; writer.write("\r\n"); &#125; writer.close();//14. 从本地文件读取稀疏数组 System.out.println("##############这是从文件恢复的稀疏数组2"); //1.创建源 File src = new File("D:\\aria2\\SparseArray.data"); //2.选择流 BufferedReader in = new BufferedReader(new FileReader(src)); //3.1进行数据的搬移，但是数组首要考虑的事情是数组要多大？ int row =0;//用于创建要创建的二维稀疏数组的大小确定 String line; //一行数据 //逐行读取，并将每个数组放入到数组中 while ((line = in.readLine()) != null) &#123; row++; &#125; int sparseArr2[][] = new int [row][3]; //3.2文本数据转移到稀疏数组中 int rowtmp = 0; //由于读取完毕整个文本文档，重启流 in.close(); in = new BufferedReader(new FileReader(src)); while ((line = in.readLine()) != null) &#123; String[] temp = line.split("\t"); for (int j = 0; j &lt; temp.length; j++) &#123; sparseArr2[rowtmp][j]=Integer.parseInt(temp[j]); &#125; rowtmp++; &#125; //4.关闭流 in.close(); //验证文件读取是否正确 for(int[]temp1:sparseArr2) &#123; for (int temp2 : temp1) &#123; System.out.printf("%d\t", temp2); &#125; System.out.println(); &#125; 参考文章：稀疏数组转换、稀疏数组到文件、array[0].length、\r\n的区别]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JsonP跨域请求]]></title>
    <url>%2F2019%2F08%2F11%2FJsonP%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%2F</url>
    <content type="text"><![CDATA[使用JsonP跨域获取json数据JsonP示例JsonP的主要实现举例： 123456789101112131415161718192021222324252627282930var category = &#123;OBJ: $("#_JD_ALLSORT"), URL_Serv: "http://localhost:8082/category.json"&#125;,FN_GetData: function() &#123; //使用jsonp来实现跨域请求 $.getJSONP(this.URL_Serv, category.getDataService); //直接使用ajax请求json数据 /*$.getJSON(this.URL_Serv, function(json)&#123; category.getDataService(json); &#125;);*///解析json数据&#125;,getDataService: function(a) &#123; var b = [], c = this; $.each(a.data, function(a) &#123; this.index = a, "l" == this.t &amp;&amp; (this.i = c.FN_RefactorJSON(this.i, 7)), b.push(c.renderItem(this, a)) &#125;); b.push('&lt;div class="extra"&gt;&lt;a &#123;if pageConfig.isHome&#125;clstag="homepage|keycount|home2013|0614a"&#123;/if&#125; href="http://www.jd.com/allSort.aspx"&gt;\u5168\u90e8\u5546\u54c1\u5206\u7c7b&lt;/a&gt;&lt;/div&gt;'), this.OBJ.attr("load", "1").html(b.join("")), $.bigiframe(this.OBJ), this.FN_GetBrands(); var d = this, e = this.OBJ.outerWidth(), f = this.OBJ.outerHeight(); $("#_JD_ALLSORT").dropdown(&#123;delay: 0,onmouseleave: function() &#123; $("#_JD_ALLSORT .item").removeClass("hover") &#125;&#125;, function(a) &#123; var b, c, g = document.documentElement.scrollTop + document.body.scrollTop, h = $("#nav-2013").offset().top + 39; h &gt;= g ? (c = a.hasClass("fore13") ? 3 : 3, g = c) : (b = a.offset().top, g = g &gt; b - 5 ? b - h - 10 : Math.max(3, g - h)); var i = a.find(".i-mc"); if (i.css(&#123;top: g + "px"&#125;), d.OBJ.find("iframe")) &#123; var j = i.outerWidth() + e, k = i.outerHeight() &gt; f ? i.outerHeight() : f; d.OBJ.find("iframe").css(&#123;width: j,height: k,top: g&#125;) &#125; &#125;)&#125; 其中，http://localhost:8082/category.json的内容为： 1234567891011121314151617181920category.getDataService(&#123; "data": [ &#123; "u": "/products/1.html", "n": "&lt;a href='/products/1.html'&gt;图书、音像、电子书刊&lt;/a&gt;", "i": [ &#123; "u": "/products/2.html", "n": "电子书刊", "i": [ "/products/3.html|电子书", "/products/4.html|网络原创", "/products/5.html|数字杂志", "/products/6.html|多媒体图书" ] &#125; ]&#125;]&#125; ); 其实是一段js，把json包装在参数里。 跨域请求为什么不能直接用Ajax 直接使用ajax请求另一个端口上的json数据: 1234//直接使用ajax请求另一个端口上的json数据 $.getJSON(this.URL_Serv, function(json)&#123; category.getDataService(json); &#125;); 会出现以下异常： No &#39;Access-Control-Allow-Origin&#39; 什么是跨域 当一个请求url的协议、域名、端口三者之间任意一个与当前页面url不同即为跨域。 协议http-&gt;https、端口8081-&gt;8082、域名Shirtiny.cn-&gt;Github.com，都为跨域。 跨域问题的产生 同源策略（Sameoriginpolicy）是一种约定，它是浏览器最核心也最基本的安全功能。 同源策略会阻止一个域的javascript脚本和另外一个域的内容进行交互。所谓同源（即指在同一个域）就是两个页面具有相同的协议（protocol），主机（host）和端口号（port） 跨域的解决方式 document.domain 跨文档通信 API JSONP CORS JsonP流程JSONP 只支持get请求，不支持post请求。 核心思想：用特定方式请求 JSON 数据，服务器收到请求后，将数据放在一个指定名字的回调函数的参数位置传回来。 数据库查询-&gt;构建pojo对象首先需要把数据库中的数据查询出来，数据库中有时并不是直接保存的json数据，如存储的分类目录表： 12345678910111213CREATE TABLE `tb_item_cat` ( `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '类目ID', `parent_id` bigint(20) DEFAULT NULL COMMENT '父类目ID=0时，代表的是一级的类目', `name` varchar(50) DEFAULT NULL COMMENT '类目名称', `status` int(1) DEFAULT '1' COMMENT '状态。可选值:1(正常),2(删除)', `sort_order` int(4) DEFAULT NULL COMMENT '排列序号，表示同级类目的展现次序，如数值相等则按名称次序排列。取值范围:大于零的整数', `is_parent` tinyint(1) DEFAULT '1' COMMENT '该类目是否为父类目，1为true，0为false', `created` datetime DEFAULT NULL COMMENT '创建时间', `updated` datetime DEFAULT NULL COMMENT '创建时间', PRIMARY KEY (`id`), KEY `parent_id` (`parent_id`,`status`) USING BTREE, KEY `sort_order` (`sort_order`)) ENGINE=InnoDB AUTO_INCREMENT=1183 DEFAULT CHARSET=utf8 COMMENT='商品类目'; 为了能让查询到的数据转为json格式，我们需要构建Pojo对象。 需要的Json数据格式： 我们可以看到data是根节点，它有很多[0]、[1]、[2]这样的节点。节点包含属性u、n、i，而其中i又是一个子节点，它又包含了自己的u、n、i属性，其中i最终包含了若干字符串。 pojo类的构建我们把根节点data单独拿出来，构建出JsonData类，因为一个Json里会有1个存放节点集合的data根节点。 12345678910111213141516171819202122232425262728293031package com.SH.Rest.Pojo;import java.util.List;public class JsonData &#123; List&lt;?&gt; data; public List&lt;?&gt; getData() &#123; return data; &#125; public void setData(List&lt;?&gt; data) &#123; this.data = data; &#125; public JsonData(List&lt;?&gt; data) &#123; this.data = data; &#125; public JsonData() &#123; &#125; @Override public String toString() &#123; return "JsonData&#123;" + "data=" + data + '&#125;'; &#125;&#125; 每个data的节点以及节点的子节点，都有u、n、i 这3个属性，其中i都为一个集合，所以我们构建DataNode类，用来表示子节点。使用@JsonProperty(“”)注解，用来指定对应属性，转换成json数据对应的key名称。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package com.SH.Rest.Pojo;import com.fasterxml.jackson.annotation.JsonProperty;import java.util.List;public class DataNodes &#123; @JsonProperty("u") String url; @JsonProperty("n") String name; @JsonProperty("i") List&lt;?&gt; item; public DataNodes() &#123; &#125; public DataNodes(String url, String name, List&lt;?&gt; item) &#123; this.url = url; this.name = name; this.item = item; &#125; @Override public String toString() &#123; return "DataNodes&#123;" + "url='" + url + '\'' + ", name='" + name + '\'' + ", item=" + item + '&#125;'; &#125; public String getUrl() &#123; return url; &#125; public void setUrl(String url) &#123; this.url = url; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public List&lt;?&gt; getItem() &#123; return item; &#125; public void setItem(List&lt;?&gt; item) &#123; this.item = item; &#125;&#125; Service递归构建，得到节点pojo对象集合1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.SH.Rest.Service.serviceImpl;import ...@Servicepublic class JsonPserviceImpl implements IJsonPService &#123; @Autowired private TbItemCatMapper tbItemCatMapper; @Override public List&lt;?&gt; selectJson(long parentId) &#123; //设定查询条件，先查询库中所有parentId为0的目录，即所有顶层目录 TbItemCatExample example = new TbItemCatExample(); TbItemCatExample.Criteria criteria = example.createCriteria(); criteria.andParentIdEqualTo(parentId); List&lt;TbItemCat&gt; list = tbItemCatMapper.selectByExample(example);//执行 List resultList = new ArrayList&lt;&gt;(); //向list中添加节点 for (TbItemCat tbItemCat : list) &#123; //判断是否为父节点 if (tbItemCat.getIsParent()) &#123; DataNode dataNode = new DataNode(); if (parentId == 0) &#123; dataNode.setName("&lt;a href='/products/"+tbItemCat.getId()+".html'&gt;"+tbItemCat.getName()+"&lt;/a&gt;"); &#125; else &#123; dataNode.setName(tbItemCat.getName()); &#125; dataNode.setUrl("/products/"+tbItemCat.getId()+".html"); //递归 dataNode.setItem(selectJson(tbItemCat.getId())); resultList.add(dataNode); //如果是叶子节点 &#125; else &#123; resultList.add("/products/"+tbItemCat.getId()+".html|" + tbItemCat.getName()); &#125; &#125; return resultList; &#125;&#125; Controller把节点集合封装到data根节点对象，然后转换成json字符串12345678910111213141516171819202122232425262728package com.SH.Rest.Controller;import ...@Controllerpublic class JsonPController &#123; @Autowired private IJsonPService jsonPService; @RequestMapping(value = "/AllCategory",produces = "text/plain;charset=UTF-8") /*设置输出编码，或 @RequestMapping(value="/itemcat/list", produces=MediaType.APPLICATION_JSON_VALUE + ";charset=utf-8") */ @ResponseBody public String AllCategory(String callBack)&#123; List&lt;?&gt; dataNodelist = jsonPService.selectJson(0); JsonData data=new JsonData(); data.setData(dataNodelist); String json = JsonUtils.objectToJson(data); //拼接成js语句，callBack参数为请求中传递来的函数名 json=callBack+"("+json+");"; return json; &#125;&#125; 另一种方式（需要spring版本支持）： 12345678910@RequestMapping("/AllCategory") @ResponseBody public Object AllCategory(String callBack) &#123; List&lt;?&gt; dataNodelist = jsonPService.selectJson(0); JsonData data=new JsonData(); data.setData(dataNodelist); MappingJacksonValue mappingJacksonValue = new MappingJacksonValue(data); mappingJacksonValue.setJsonpFunction(callback); return mappingJacksonValue; &#125; 此时客户端只需要发请求： 1http://本机：端口/AllCategory?callBack=自定义函数 然后会自动调用自定义的函数，并将参数值（也就是json数据）传过来，详情可以看文章开头。]]></content>
      <categories>
        <category>学习经验</category>
      </categories>
      <tags>
        <tag>JsonP</tag>
        <tag>Js跨域请求</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Json格式数据转Html表格]]></title>
    <url>%2F2019%2F08%2F09%2FJson%E6%A0%BC%E5%BC%8F%E6%95%B0%E6%8D%AE%E8%BD%ACHtml%E9%A1%B5%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[Json数据→包含html语言的字符串输入数据数据库可以把下面的Json格式的字符串数据存储起来 123456789101112131415[ &#123;"group":"主体", "params":[ &#123;"k":"品牌","v":"1"&#125;, &#123;"k":"型号","v":"2"&#125;, &#123;"k":"颜色","v":"3"&#125;, &#123;"k":"上市年份","v":"4"&#125;]&#125;, &#123;"group":"网络", "params":[&#123;"k":"4G网络制式","v":"a"&#125;, &#123;"k":"3G网络制式","v":"b"&#125;, &#123;"k":"2G网络制式","v":"c"&#125;]&#125;, &#123;"group":"存储", "params":[&#123;"k":"机身内存","v":"de"&#125;, &#123;"k":"储存卡类型","v":"ef"&#125;]&#125;] 需要把json转成ListJson到java对象的转换，工具类： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package com.SH.utils;import java.util.List;import ... /*工具类，用于把json数据转成需要的java对象 */public class JsonUtils &#123; // 定义jackson对象 private static final ObjectMapper MAPPER = new ObjectMapper(); /** * 将对象转换成json字符串。 * &lt;p&gt;Title: pojoToJson&lt;/p&gt; * &lt;p&gt;Description: &lt;/p&gt; * @param data * @return */ public static String objectToJson(Object data) &#123; try &#123; String string = MAPPER.writeValueAsString(data); return string; &#125; catch (JsonProcessingException e) &#123; e.printStackTrace(); &#125; return null; &#125; /** * 将json结果集转化为对象 * * @param jsonData json数据 * @param clazz 对象中的object类型 * @return */ public static &lt;T&gt; T jsonToPojo(String jsonData, Class&lt;T&gt; beanType) &#123; try &#123; T t = MAPPER.readValue(jsonData, beanType); return t; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null; &#125; /** * 将json数据转换成pojo对象list * &lt;p&gt;Title: jsonToList&lt;/p&gt; * &lt;p&gt;Description: &lt;/p&gt; * @param jsonData * @param beanType * @return */ public static &lt;T&gt;List&lt;T&gt; jsonToList(String jsonData, Class&lt;T&gt; beanType) &#123; JavaType javaType = MAPPER.getTypeFactory().constructParametricType(List.class, beanType); try &#123; List&lt;T&gt; list = MAPPER.readValue(jsonData, javaType); return list; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null; &#125; &#125; 详细参考拿到数据库里的Json数据后，对其进行转换，两次遍历，利用map拿到value，然后使用StringBuffer生成html格式的字符串。 123456789101112131415161718192021222324252627282930@Servicepublic class SqlJson2JavaString &#123; public String json2String(String sqlData) &#123; String jsonData = sqlData; //生成html // 把规格参数json数据转换成java对象 List&lt;Map&gt; jsonList = JsonUtils.jsonToList(jsonData, Map.class); StringBuffer sb = new StringBuffer(); sb.append("&lt;table cellpadding=\"0\" cellspacing=\"1\" width=\"100%\" border=\"0\" class=\"Ptable\"&gt;\n"); sb.append(" &lt;tbody&gt;\n"); for(Map m1:jsonList) &#123; sb.append(" &lt;tr&gt;\n"); sb.append(" &lt;th class=\"tdTitle\" colspan=\"2\"&gt;"+m1.get("group")+"&lt;/th&gt;\n"); sb.append(" &lt;/tr&gt;\n"); List&lt;Map&gt; list2 = (List&lt;Map&gt;) m1.get("params"); for(Map m2:list2) &#123; sb.append(" &lt;tr&gt;\n"); sb.append(" &lt;td class=\"tdTitle\"&gt;"+m2.get("k")+"&lt;/td&gt;\n"); sb.append(" &lt;td&gt;"+m2.get("v")+"&lt;/td&gt;\n"); sb.append(" &lt;/tr&gt;\n"); &#125; &#125; sb.append(" &lt;/tbody&gt;\n"); sb.append("&lt;/table&gt;"); return sb.toString(); &#125;&#125; 这样，数据库存储中，这种&lt;K,V&gt;对形式的表格数据，可以用json数据保存，可以单表操作。 输出结果 使用工具类，处理数据库中json格式数据 123//将接收到的jsonData，转为map集合List&lt;Map&gt; jsonList = JsonUtils.jsonToList(jsonData, Map.class);System.out.println(jsonList); 打印转换的结果： 1[&#123;group=主体, params=[&#123;k=品牌, v=1&#125;, &#123;k=型号, v=2&#125;, &#123;k=颜色, v=3&#125;, &#123;k=上市年份, v=4&#125;]&#125;, &#123;group=网络, params=[&#123;k=4G网络制式, v=a&#125;, &#123;k=3G网络制式, v=b&#125;, &#123;k=2G网络制式, v=c&#125;]&#125;, &#123;group=存储, params=[&#123;k=机身内存, v=de&#125;, &#123;k=储存卡类型, v=ef&#125;]&#125;] 使用StringBuffer和遍历取出需要的数据： 123456789101112131415161718StringBuffer sb = new StringBuffer(); sb.append("&lt;table cellpadding=\"0\" cellspacing=\"1\" width=\"100%\" border=\"0\" class=\"Ptable\"&gt;\n"); sb.append(" &lt;tbody&gt;\n"); for(Map m1:jsonList) &#123; sb.append(" &lt;tr&gt;\n"); sb.append(" &lt;th class=\"tdTitle\" colspan=\"2\"&gt;"+m1.get("group")+"&lt;/th&gt;\n"); sb.append(" &lt;/tr&gt;\n"); List&lt;Map&gt; list2 = (List&lt;Map&gt;) m1.get("params"); for(Map m2:list2) &#123; sb.append(" &lt;tr&gt;\n"); sb.append(" &lt;td class=\"tdTitle\"&gt;"+m2.get("k")+"&lt;/td&gt;\n"); sb.append(" &lt;td&gt;"+m2.get("v")+"&lt;/td&gt;\n"); sb.append(" &lt;/tr&gt;\n"); &#125; &#125; sb.append(" &lt;/tbody&gt;\n"); sb.append("&lt;/table&gt;"); return sb.toString(); 最终结果为： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;table cellpadding="0" cellspacing="1" width="100%" border="0" class="Ptable"&gt; &lt;tbody&gt; &lt;tr&gt; &lt;th class="tdTitle" colspan="2"&gt;主体&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class="tdTitle"&gt;品牌&lt;/td&gt; &lt;td&gt;1&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class="tdTitle"&gt;型号&lt;/td&gt; &lt;td&gt;2&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class="tdTitle"&gt;颜色&lt;/td&gt; &lt;td&gt;3&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class="tdTitle"&gt;上市年份&lt;/td&gt; &lt;td&gt;4&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th class="tdTitle" colspan="2"&gt;网络&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class="tdTitle"&gt;4G网络制式&lt;/td&gt; &lt;td&gt;a&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class="tdTitle"&gt;3G网络制式&lt;/td&gt; &lt;td&gt;b&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class="tdTitle"&gt;2G网络制式&lt;/td&gt; &lt;td&gt;c&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th class="tdTitle" colspan="2"&gt;存储&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class="tdTitle"&gt;机身内存&lt;/td&gt; &lt;td&gt;de&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class="tdTitle"&gt;储存卡类型&lt;/td&gt; &lt;td&gt;ef&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt;]]></content>
      <categories>
        <category>学习经验</category>
      </categories>
      <tags>
        <tag>Json</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新增视频播放插件]]></title>
    <url>%2F2019%2F08%2F06%2F%E6%96%B0%E5%A2%9E%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[更新视频、音频插件支持 有了服务器支持，现在可以用自己的媒体源了，媒体内容可以不再受公网限制。之前做html视频嵌入示例，发现部分html内容在https下无法正常使用，于是博客新增了对视频源的播放支持。 效果： (function(){var player = new DPlayer({"container":document.getElementById("dplayer0"),"autoplay":true,"theme":"#FADFA3","loop":true,"video":{"url":"http://server.shirtiny.cn/video/ys.mp4"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})() 这个插件是基于DPlayer的 ，若视频连接出错，多半是因为换了服务器ip或者暂时关闭了服务器，有的时间段会比较卡，也可能是协议的问题。 只需要安装对应插件，然后Github上有详细的文档说明，用起来也很方便。功能挺好的，只是有时候这播放器会出bug。 官方文档： 音乐播放插件：hexo-tag-aplayer 视频播放插件：hexo-tag-dplayer 安装插件： 1234#视频播放插件npm install hexo-tag-dplayer --save#音频播放插件，不过音乐是能正常播放的，暂时用不到这个npm install hexo-tag-aplayer --save 示例： 视频 12&lt;!-- 效果是上面的视频 ，沒声音是因为，这个视频源没加音频。有声音是因为文章下面有个背景音乐（显示中）--&gt;&#123;% dplayer "url=http://45.77.226.194/video/ys.mp4" "loop=yes" "theme=#FADFA3" "autoplay=true" %&#125; 其实相当于使用DPlayer： 123456789101112131415161718192021222324252627282930313233343536&#123;% raw %&#125;&lt;div id="player1" class="dplayer"&gt;&lt;/div&gt;&lt;script src="dist/DPlayer.min.js"&gt;&lt;/script&gt;&lt;!-- use your path --&gt;&lt;script&gt;var dp = new DPlayer(&#123;&#123; container: document.getElementById('dplayer'), autoplay: false, theme: '#FADFA3', loop: true, screenshot: true, hotkey: true, logo: 'logo.png', volume: 0.2, mutex: true, video: &#123; url: 'http://78.141.206.203/video/ys.mp4', pic: '', thumbnails: '', type: 'auto' &#125;, subtitle: &#123; &#125;, danmaku: &#123; &#125;, unlimited: true &#125;, contextmenu: [ &#123; &#125; ]&#125;);&lt;/script&gt;&#123;% endraw %&#125; 音频 1&#123;% aplayer "马宿" "Zelda" "http://78.141.206.203/music/masu.mp3" "autoplay" %&#125; var ap = new APlayer({ element: document.getElementById("aplayer-gsfrGVNx"), narrow: false, autoplay: true, showlrc: false, music: { title: "马宿", author: "Zelda", url: "http://server.shirtiny.cn/music/masu.mp3", pic: "", lrc: "" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 参考文章]]></content>
      <categories>
        <category>系统维护</category>
      </categories>
      <tags>
        <tag>博客维护</tag>
        <tag>播放插件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在线视频播放、直播]]></title>
    <url>%2F2019%2F08%2F06%2F%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE%E3%80%81%E7%9B%B4%E6%92%AD%2F</url>
    <content type="text"><![CDATA[Nginx：视频、直播前篇文章说了Sftp下的文件上传，访问时比如图片、json文件等是可以直接显示的。可压缩包或视频文件等，访问时只能下载，如何让视频在线播放？ 环境准备： 可用的服务器（CentOS 7系统）、Nginx、Nginx-Rtmp模块 、Ffmpeg、Jwplayer(可以从连接另存文件，不用登录) 工具：Xshell 6、Xftp 5 1. 在线视频播放其实要播放比较简单，主要问题是网速、负载等，这些是生产环境需要考虑的。 1.1. 安装Nginx服务器安装Nginx，包括远程工具，参照我之前的文章即可。 ### 1.2. 安装Nginx-Rtmp模块 在Github上下载nginx-rtmp-module-1.2.1.tar.gz 使用Xftp将下载的压缩包传到服务器的/usr/local文件夹。放哪都行，自己能找到就行。 使用tar命令解压该文件，得到nginx-rtmp-module-1.2.1文件夹，我的文件夹位置为： 1/usr/local/nginx-rtmp-module-1.2.1 此时，你需要找到之前Nginx解压后的文件夹，就是那个带版本号的文件夹。我的Nginx源码目录是： 1/usr/local/nginx-1.17.1 进入Nginx源码文件夹 1cd /usr/local/nginx-1.17.1 安装Nginx-Rtmp模块 此时，一定要进入nginx源码文件，不然找不到configure。还要注意找到之前rtmp模块解压后的文件夹位置，此时我nginx-1.17.1和nginx-rtmp-module-1.2.1都是放在/usr/local下的，所以用../就能找到。 123./configure --add-module=../nginx-rtmp-module-1.2.1 --with-http_ssl_modulemakemake install 模块安装完成。 参考：官方文档 1.3. 视频播放配置 打开/usr/local/nginx/conf目录下的nginx.conf配置文件，nginx是Nginx的安装目录 1vi /usr/local/nginx/conf/nginx.conf 键盘按i编辑，方向键移动光标，编辑完按 ” :wq “ 保存退出 编辑内容： 光标移动到文件最底部大括号外 （http｛｝代码块外），增加rtmp代码块： 12345678910111213141516rtmp&#123; server&#123; listen 2019; chunk_size 4096; #应用名随意，play播放指定目录或者 HTTP 地址的 flv 或者 mp4 文件 application video &#123; play /data/video; &#125;&#125;&#125; 此时虽然可以播放视频了，但http还找不到资源，所以还需要定义访问路径。 把光标移到http代码块里，按如下内容修改和增加代码，其实只加了个location，配置文件里#后内容是注释，忽略或删除。 123456789101112131415161718192021222324252627282930313233343536373839404142http &#123; include mime.types; default_type application/octet-stream; sendfile on; tcp_nopush on; keepalive_timeout 65; server &#123; listen 80; server_name localhost; #之前配置的根目录 location / &#123; root /data/www; index index.html index.htm; &#125; #之前配置的图片目录 location /images/ &#123; root /data; &#125; #新增的video目录，即浏览器访问http://ip地址/video时，会进入服务器的/data/video目录 location /video/ &#123; root /data; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; &#125; &#125; 保存并退出，然后重启Nginx服务。 1systemctl restart nginx.service 1.4. 测试视频播放 在服务器的/data/video目录下放入一个mll.mp4视频文件，目录/data/video要建个，根据你的配置的目录来。 浏览器访问http://ip地址/video/mll.mp4 如：http://108.160.134.51/video/mll.mp4 播放成功即可，我服务器速度贼慢，后面换个服务器试试效果。 这时，就可以把视频嵌入到html中播放了，比如： 1&lt;iframe src="http://78.141.206.203/video/ct.mp4" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" autoplay="" width="100%" height="450px"&gt; &lt;/iframe&gt; 效果： (function(){var player = new DPlayer({"container":document.getElementById("dplayer1"),"autoplay":true,"theme":"#FADFA3","video":{"url":"http://server.shirtiny.cn/video/Hold Me Now.mp4"},"danmaku":{"api":"http://dplayer.daoapp.io","token":"tokendemo"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})() 博客视频标签 服务器我换成伦敦的了，现在速度好些了，有的时间段比较卡。 Vultr测ping、服务器数据迁移备份 2. 直播这里搭建一个简单的直播体系，实际要复杂的多。 直播应该有推流端、服务器处理端、和接收端。 2.1. 服务器端配置之前配过视频播放了，这里也用Nginx-Rtmp模块，配置一下nginx就行了。 还是打开/usr/local/nginx/conf目录下的nginx.conf配置文件 1vi /usr/local/nginx/conf/nginx.conf 键盘按i编辑，方向键移动光标，编辑完按 ” :wq “ 保存退出 编辑内容： rtmp代码块 123456789101112131415161718192021222324252627282930rtmp&#123; server&#123; #端口号，要记住 listen 2019; chunk_size 4096; application video &#123; play /data/video; &#125; #新增live应用，名字可自定。live on，开启直播，一对多广播 application live &#123; live on; &#125; #hls，暂时用不到，可以不写 application hls_alic&#123; live on; hls on; hls_path /tmp/hls; &#125;&#125;&#125; http代码块 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354http &#123; include mime.types; default_type application/octet-stream; sendfile on; tcp_nopush on; keepalive_timeout 65; server &#123; listen 80; server_name localhost; location / &#123; root /data/www; index index.html index.htm; &#125; location /images/ &#123; root /data; &#125; location /video/ &#123; root /data; &#125; #新增，访问http://ip/stat时，为当前 HTTP location 设置 RTMP statistics 处理程序。RTMP statistics 是一个静态的 XML 文档。可以使用 rtmp_stat_stylesheet 指令在浏览器中作为 XHTML 页面查看这个文档。添加 XML 样式表引用到 statistics XML 使其可以在浏览器中可视。 location /stat &#123; rtmp_stat all; rtmp_stat_stylesheet stat.xsl; &#125; #新增，能直接访问stat.xsl文件，上面的一块，就是能在浏览器看到rtmp的状态信息 location /stat.xsl &#123; root /usr/local/nginx-rtmp-module-1.2.1; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; &#125; &#125; 重启Nginx服务。 1systemctl restart nginx.service 顺便让防火墙开放你配置的端口，比如这里我配置的2019端口： 1234#添加2019端口配置防火墙firewall-cmd --zone=public --add-port=2019/tcp --permanent#重新加载firewall-cmd --reload 浏览器访问http://你的服务器Ip/stat，如http://108.160.134.51/stat，若出现以下页面，则服务器配置成功。 2.2. 推流端推流可以用FFmpeg，功能强大，使用命令行进行操作，可以在服务器上使用，就是参数比较多，对新手不友好。 还可以用OBS，有windows版本，是大家常用的直播工具了。 OBS 先说下Obs，这个软件比较常见。在设置里面，左侧菜单选输出，输出模式选高级，点录像，选择输出到URL URL的格式是：rtmp://你的服务器ip:端口号/服务器配置的应用名/自定义个名字，容器格式最好选flv，因为体积会小点，其他看自己情况选。 FFmpeg FFmpeg，这个可以装在windows本机上，也可以装在服务器上，使用方式是命令行，下面说一下服务器上怎么装。windows同理，无所谓，可以用其他软件。 【FFmpeg使用示例：】ffmpeg -i /data/video/am.mkv -vcodec h264 -s 1920*1080 /data/video/am.mp4 我的服务器系统：CentOs 7，安装流程： 先安装环境支持，EPEL Release 12sudo yum install -y epel-release rpm#若出现缺少Code提示，执行：sudo rpm --import /etc/pki/rpm-gpg/RPM-GPG-KEY-EPEL-7 安装Nux-Dextop 12sudo rpm --import http://li.nux.ro/download/nux/RPM-GPG-KEY-nux.rosudo rpm -Uvh http://li.nux.ro/download/nux/dextop/el7/x86_64/nux-dextop-release-0-1.el7.nux.noarch.rpm 正式安装FFmpeg 123sudo yum install -y ffmpeg#检查是否安装成功ffmpeg -version 使用 这里使用服务器上的视频/data/video/mll.mp4，模拟推流。 推流到rtmp://localhost:2019/live/test，本地2019端口下的live应用，当然也可以推到远处的服务器，后面的test是自定义的名字。 1ffmpeg -re -i /data/video/mll.mp4 -c copy -f flv rtmp://localhost:2019/live/test 可以根据网速自定义码率： -b:v 3000k 意为视频码率3000k -b:a 320k 指音频 1ffmpeg -re -i /data/video/mllo.mp4 -c copy -b:v 3000k -b:a 320k -f flv rtmp://localhost:2019/live/test 更多使用参考：ffmpeg基础使用 推流后，我们需要一个接收端才能看到推流的效果。 2.3. 接收端（拉流端）这里我用的JWPlayer 解压JWPlayer，新建个html，与jwPlayer文件夹同级目录。 Html内容如下： 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt; &lt;html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"&gt; &lt;head&gt; &lt;meta http-equiv="content-type" content="text/html; charset=utf-8" /&gt; &lt;title&gt;live-player&lt;/title&gt; &lt;style type="text/css"&gt; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;script type='text/javascript' src='jwplayer/jwplayer.js'&gt;&lt;/script&gt; &lt;center&gt; &lt;b&gt;RTMP直播系统&lt;/b&gt; &lt;div id='mediaspace'&gt;This text will be replaced&lt;/div&gt; &lt;script type='text/javascript'&gt; // var server = window.location.hostname; // mylive 对应nginx.conf配置项application的名字 // live_stream 对应Adobe Flash Stream Media Live Encoder配置的stream名称 var live_url = 'rtmp://108.160.134.51:2019/live/test'; //链接的服务器流，与推流一致jwplayer('mediaspace').setup(&#123; 'flashplayer': 'jwplayer/jwplayer.flash.swf', 'file': live_url, 'controlbar': 'bottom', 'width': '760', 'height': '428', //autostart: true, //如果打开此标志，在打开网页时会自动播放直播流 &#125;); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 其中live_url应与推流端的推流地址一致，此html可传到服务器上Nginx管理的目录下，直接访问。也可在本地运行。 运行效果如图： 一个简单的直播系统便建好了。 参考文章： 利用RTMP实现直播系统 Nginx+RTMP 搭建视频点播服务器 译·Nginx RTMP模块指令详解 CentOS 7.5下FFmpeg安装、简单使用总结 ffmpeg基础使用 利用nginx搭建RTMP视频点播、直播/回放 ffmpeg+nginx+rtmp+web实现视频直播网站 使用nginx+nginx-rtmp-module+ffmpeg搭建流媒体服务器 Linux&amp;Windows搭建基于nginx的视频点播服务器 Nginx优化静态文件访问]]></content>
      <categories>
        <category>学习经验</category>
      </categories>
      <tags>
        <tag>视频播放</tag>
        <tag>直播</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sftp文件上传、下载]]></title>
    <url>%2F2019%2F08%2F05%2FSftp%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E3%80%81%E4%B8%8B%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[Sftp协议下文件上传、下载使用JSch进行Sftp连接问题产生 我用common-net，ftp连接时使用21端口会超时，后来发现使用Xftp工具用21端口也超时 1Connection timed out: connect 查了下百度，端口问题。 ftp服务用的是20、21端口，客户端添加ftp信息的时候输入的是21端口 ssh服务用的是22端口，应用于远程ssh管理Linux服务器； 然后我换了22端口进行尝试。 12 Could not parse response code.Server Reply: SSH-2.0-OpenSSH_7.4 异常如上，百度了下，于是开始用sftp协议尝试。 参考文章：主要参考，详细参考 问题解决 我制作了一个工具类，以供调用。 maven依赖 12345678&lt;dependency&gt; &lt;groupId&gt;com.jcraft&lt;/groupId&gt; &lt;artifactId&gt;jsch&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.jcraft&lt;/groupId&gt; &lt;artifactId&gt;jzlib&lt;/artifactId&gt; &lt;/dependency&gt; 还有一些依赖，如springMVC的依赖。 简单上传 遇到了很多的问题，像如何简化、如何创建目录、如何检查目录是否存在、认证问题等，在注释里写得很详细。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250package IO_Utils;import com.jcraft.jsch.*;import java.io.*;import java.lang.reflect.Array;import java.util.ArrayList;import java.util.Properties;import java.util.Vector;/** 我的sftp上传工具* */public class ImageSftp &#123; /**方法内属性说明 * private static ChannelSftp Sftp = null; //用户名(由外部传参) private static String ImgServerUsername = "root"; //主机ip(由外部传参) private static String ImgServerIp = "78.141.206.203"; //密码(由外部传参) private static String ImgServerPassword = "123456"; //端口号(由外部传参) private static int ImgServerPort = 22; //上传到的服务器目录(由外部传参) private static String ImgServerDirectory = "/data/images/"; //上传到服务器的文件命名为(由外部传参) private static String ImgServerFileName=""; //要上传的本地文件// private static File clientFile=null; //下载到本地的目录（由外部传参） private static String ClientDirectory = "D:\\aria2\\"; //下载到本地的文件命名为（由外部传参） private static String ClientFileName ="";*/ private Channel channel=null; private Session sshSession=null; private ChannelSftp sftp =null;/** 获取连接对象的方法* */ public ChannelSftp getConnect(String imgServerIp, int imgServerPort,String imgServerUsername,String imgServerPassword) &#123; JSch jsch = new JSch(); try &#123; //用户名、ip、端口号 sshSession = jsch.getSession(imgServerUsername,imgServerIp, imgServerPort); //配置属性 Properties config = new Properties(); config.put("StrictHostKeyChecking","no"); config.put("PreferredAuthentications","password"); sshSession.setConfig(config); //不检查主机严格密钥// sshSession.setConfig("StrictHostKeyChecking", "no"); //关闭gssapi认证，只使用密码认证，减少耗时 //config.put("userauth.gssapi-with-mic", "no");// sshSession.setConfig("PreferredAuthentications","password"); //给密码设值 sshSession.setPassword(imgServerPassword); //设置多少毫秒超时（设了会报错）// sshSession.connect(600);// sshSession.setServerAliveInterval(92000);// 请求时长 System.out.println("正在与服务器建立连接"); //开启sshSession链接// sshSession.connect(); sshSession.connect(5000); //获取sftp通道 channel = sshSession.openChannel("sftp"); channel.connect(); ChannelSftp sftp = (ChannelSftp) channel; System.out.println("已成功建立连接"); return sftp; &#125;catch (JSchException e)&#123; e.printStackTrace(); System.out.println("建立连接失败"); return null; &#125; &#125; /** * 上传方法 * @param sftp 通过getConnect()方法获得的链接对象 * @param inputStream 要上传文件的输入流 * //@param serverDirectory 某类文件存放的目录，必须指明为根目录某处，如：/data/video/，斜杠必须带 * @param finalServerDirectory 上传文件最终所在的目录，=serverDirectory/nextDirectory * @param serverFileName 为上传到服务器后的文件名 * */ public boolean upload(ChannelSftp sftp,InputStream inputStream ,String finalServerDirectory,String serverFileName) throws IOException, SftpException &#123; //连接服务器// ChannelSftp sftp = getConnect(); if (sftp!=null) &#123; //进入要存储的服务器目录// sftp.cd(serverDirectory); SftpATTRS stat=null; //判断文件夹是不是存在，这里要捕获异常，不然会卡住 try &#123; stat = sftp.stat(finalServerDirectory); System.out.println("找到了目标文件（夹）："+stat+"\n\n\n"); &#125;catch (Exception e)&#123; System.out.println("找不到目标目录"); &#125; if (stat!=null)&#123;//stat有返回值，说明文件夹存在 //进入该文件夹 sftp.cd(finalServerDirectory); System.out.println("进入文件夹"); &#125;else &#123; //创建文件夹，然后进入 sftp.mkdir(finalServerDirectory); sftp.cd(finalServerDirectory); System.out.println("自动创建"+finalServerDirectory+"文件夹，并进入"); &#125; //本地文件，存到流，不需要，因为前台会直接收到MultipartFile类型的文件，并且能获得流// File clientFile = new File(filePath);// InputStream fileInputStream = new FileInputStream(clientFile); //上传到服务器后的名字，由外部传参// serverFileName="1.avi"; System.out.println("上传ing"); //获取文件大小（字节） long size = inputStream.available(); //执行上传（断点续传方式） sftp.put(inputStream, serverFileName,new SftpMonitor(size),ChannelSftp.RESUME); System.out.println("上传完毕");//交给单独方法去断开连接// System.out.println("关闭连接"); //断开连接// sftp.disconnect();//// System.out.println("连接是否已关闭"+sftp.isClosed()); return true; &#125;else &#123; return false; &#125; &#125; /** * 关闭连接 * */ public void close() throws Exception&#123; if (sftp!=null)&#123; sftp.quit(); &#125; if (channel!=null)&#123; channel.disconnect(); System.out.println("已关闭通道"); &#125; if (sshSession!=null)&#123; sshSession.disconnect(); System.out.println("已关闭连接"); &#125; &#125; /* * 下载方法 * 未写，因为暂时用不到 * 暂定 * */// public static String download() throws JSchException, SftpException, FileNotFoundException &#123;// ChannelSftp sftp = getConnect();//// clientFileName="123.png";// File clientFile=new File(clientDirectory+clientFileName);// serverDirectory="/data/images/";// serverFileName="123.png";// sftp.get(serverDirectory+serverFileName, new FileOutputStream(clientFile));// return clientDirectory+clientFileName;//// &#125; //测试 public static void main(String[] args) throws Exception &#123; String imgServerIp="78.141.206.203"; int imgServerPort=22; String imgServerUsername="root"; String imgServerPWD="123456"; ImageSftp imageSftp=new ImageSftp(); ChannelSftp connect = imageSftp.getConnect(imgServerIp, imgServerPort, imgServerUsername, imgServerPWD);// String filePath="C:\\Users\\Shirtiny\\Downloads\\masu.jpg";//要上传的文件的路径//现在是你直接给我个输入流 //获取输入流 String filePath="D:\\MY文档\\音乐\\折戸伸治 - 潮鳴り.mp3"; File file=new File(filePath);// long fileSize = file.length();// System.out.println("文件大小"+fileSize); FileInputStream fileInputStream = new FileInputStream(file); String finalServerDirectory="/data/music";//上传到的服务器目录,调用上传方法时，若找不到该目录，则程序自动创建。代表文件最终存放的目录 String serverFileName="潮鸣.mp3";//上传到服务器的文件命名为// Vector ls = connect.ls(finalServerDirectory);// connect.put("D:\\MY文档\\音乐\\折戸伸治 - 潮鳴り.mp3","123.mp3",new SftpMonitor(),ChannelSftp.OVERWRITE); boolean flag = imageSftp.upload(connect, fileInputStream, finalServerDirectory, serverFileName); System.out.println("是否完成："+flag); //关闭连接 connect.quit(); imageSftp.close(); &#125;&#125; 下载方法未写 下载时拒绝访问的问题 实例我现在需要将一个文件（图片为例）上传到服务器，使用sftp协议，需求如下： 点击上传按钮，选择文件后即可上传 能看到上传的进度和速度 能在上传成功、异常结束时得到反馈 要求在上传后，程序自动显示该图片 图片需要按照一定分类去存储，以方便管理，减少资源消耗 图片名称不能重复，并且图片能正确显示 全程支持中文 支持断点续传 首先，进度监控、断点续传很显然我们目前的这个工具类还不能满足我们的需求，它还需要两个功能： 1.实时监控，这样我们才能知道上传的速度、进度 2.断点续传，值得高兴的是，Jsch为我们提供了这个功能。 1. 实时监控SftpProgressMonitor Jsch提供了一个SftpProgressMonitor接口，包括了初始化时执行的init()方法、每传输一个数据块就会执行一次的count()方法、以及在传输结束时执行的end()方法。 基于这个接口，我们可以写出一个简单监控类： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package IO_Utils;import com.jcraft.jsch.SftpProgressMonitor;/** * 上传进程监控 * */public class SftpMonitor implements SftpProgressMonitor &#123; private long counted;//初始字节数，已经上传的字节数 private long fileSize;//最终文件大小 private long percent;//进度百分比值 public SftpMonitor() &#123; &#125; public SftpMonitor(long fileSize) &#123; this.fileSize = fileSize; &#125; @Override public void init(int op, String src, String dest, long errfileSize) &#123; System.out.println("初始化完成"+"文件大小为："+fileSize); &#125; @Override public boolean count(long count) &#123;// System.out.println("之前已上传"+counted+"("+percent+"%)"); counted +=count;// if (percent&gt;=this.count/fileSize)&#123;// return true;// &#125; percent= counted*100/fileSize; System.out.println("进度-----已传输："+counted/1024+" kb/"+fileSize/1024+" kb"+"("+percent+"%)"); return true; &#125; @Override public void end() &#123; System.out.println("end结束"); &#125;&#125; 它的使用方式： 123long size = inputStream.available();//通过流获取文件大小 //执行上传 sftp.put(inputStream, serverFileName,new SftpMonitor(size);//在执行put方法时初始化一个监控类 很抱歉，由于时间关系，我不能像以往那样详细说明，Jsch：put方法的重载。 SftpProgressMonitor+TimerTask+Pojo 我们需要获得传输的速度，所以需要有个Timer来帮忙，对此不了解的可查看Timer的使用. 我们可以通过重写TimerTask类的run()方法，来实现我们需要的功能。我写了一个start()方法用于创建timer对象，新建计划任务，stop()方法用于终止计时。run()方法会按照我们设置的计划，每隔一段时间执行一次，用单独的线程来执行。 我把需要的信息封装到一个pojo类里，你也可以不封装。 由此便有了一个新的监控类： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156package Sftp_service;import com.jcraft.jsch.SftpProgressMonitor;import org.springframework.beans.factory.annotation.Autowired;import java.text.DecimalFormat;import java.util.Timer;import java.util.TimerTask;public class mySftpTimerMonitor extends TimerTask implements SftpProgressMonitor &#123; private long fileSize;//文件总大小 private long counted;//已传输数据，单位字节 private long counted_Before=0;//上一秒的已传输数据，单位字节 private long i_ed=0;//已计时间，单位s private Timer timer;//计时器对象 private long timeInterval=2*1000;//时间间隔，单位ms private boolean timerIsStarted;//是否已经开始计时 private DecimalFormat format = new DecimalFormat( &quot;#.##&quot;);//用于转换数据显示格式 private SftpSpeedInfo speedInfo=new SftpSpeedInfo(); public mySftpTimerMonitor() &#123; &#125; mySftpTimerMonitor(long fileSize) &#123; this.fileSize = fileSize; &#125; @Override//监视器方法重写 public boolean count(long count) &#123;//每传输一次数据块，就会执行一次count方法 if (!timerIsStarted)&#123;//只在无计时器时，开启计时器 timerStart();//开始计时 &#125; incrementCounted(count);//执行自增 return true; &#125; //Timertask run @Override//计时器方法重写 public void run() &#123;//计时器控制的方法，每多少时间执行一次，用单独的线程执行。前提是启动计时器 /* *i++; *System.out.println(counted+&quot;已用时间&quot;+this.i+&quot;s&quot;); *可以这样。不过可能是考虑到多线程的原因应该这样做： * */ //这样取值更好，其他线程需要等待这个线程取完值，才能去取值 long i1 =getI_ed();//这样就有个新问题，如何使i自增，直接在run内i++是不行的，因为getI()的值没有变 long i2 = incrementI_ed(i1);//新建个方法，用来使秒数自增一次，自憎后的值为i2 long counted_latest=getCounted();//同理拿到当前的，已传输数据量counted的值 long counted_before = getCounted_Before();//拿到上一次的已传数据量 setCounted_Before(counted_latest);//把这次的已传数据量存起来 double speed=(double)(counted_latest-counted_before)/(1024*(timeInterval/1000));//计算传输速度，单位kb/s，speed=当前已传输量-上次的已传输量/(1024*时间间隔/1000) double percent=(double)counted_latest/(double)fileSize; speedInfo.setPercent(format.format(percent*100)+&quot;%&quot;);//百分比 speedInfo.setSpeed(format.format(speed)+&quot;kb/s&quot;);//速度 speedInfo.setCounted(format.format((double)counted/1024)+&quot;kb&quot;);//已传输量 speedInfo.setTimed(i2);//用时 s System.out.println(speedInfo); &#125; private void timerStart()&#123;//自定义的计时器方法，启动计时器 if (timer!=null)&#123; timer.cancel();//终止此计时器，丢弃所有当前已安排的任务。 timer.purge();//从此计时器的任务队列中移除所有已取消的任务。 &#125;else &#123; timer=new Timer();// 这个方法是调度一个task，在delay（ms）后开始调度，每次调度完后，最少等待period（ms）后才开始调度 timer.schedule(this,1000,timeInterval); timerIsStarted=true; System.out.println(&quot;Timer is started,计时器启动完成&quot;); &#125; &#125; public void stop()&#123;//自定义的计时器方法，停止计时器 if (timer != null) &#123; timer.cancel(); timer.purge(); timer = null; timerIsStarted=false; &#125; System.out.println(&quot;stop timer,停止计时&quot;); &#125; @Override//监视器方法重写 public void init(int i, String s, String s1, long l) &#123; speedInfo.setFileSize(format.format((double)this.fileSize/1024)+&quot;kb&quot;);//文件大小 &#125; @Override//监视器方法重写 public void end() &#123;//传输结束 stop();//停止计时器，并清空数据 &#125; //使用synchronized关键字，线程排队调用，即线程同步 public synchronized long getFileSize() &#123; return fileSize; &#125; private synchronized long getCounted_Before() &#123;//取出上一秒的数据量 return counted_Before; &#125; private synchronized void setCounted_Before(long counted_latest) &#123;//把这一秒的已传输数据量记录给counted_Before，为下一秒服务 this.counted_Before = counted_latest; &#125; private synchronized long getI_ed() &#123;//上一秒i的值，已计秒数 return i_ed; &#125; private synchronized long getCounted() &#123;//此次已传数据量的值 return counted; &#125; private synchronized void incrementCounted(long count)&#123;//已传数据量自增方法 counted=counted+count; &#125; // private synchronized long incrementI_ed(long i1)&#123;//已计秒数 自增方法 i_ed=i1+(timeInterval/1000);//自增一次，自增值为间隔时间（s） return i_ed; &#125;&#125; 2.断点续传好在Jsch提供了这个功能，我们不必再费脑筋。我们只需要在执行put()时，把mode的值改为ChannelSftp.RESUME即可。 12 long size = inputStream.available();sftp.put(inputStream, serverFileName,new mySftpTimerMonitor(size),ChannelSftp.RESUME); OVERWRITE是覆盖，APPEND是扩展。 其次，文件夹分类、文件名随机直接看代码即可，这是service层： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package com.SH.Service.ServiceImpl;import ID_Utils.ID_Imghelper;import com.SH.Service.IimgService;import Sftp_service.ImageSftp;import com.jcraft.jsch.ChannelSftp;import com.jcraft.jsch.SftpException;import org.springframework.beans.factory.annotation.Value;import org.springframework.stereotype.Service;import java.io.IOException;import java.io.InputStream;import java.text.SimpleDateFormat;import java.util.Date;@Servicepublic class imgServiceImpl implements IimgService &#123; @Value("$&#123;ImgServerIp&#125;") private String ImgServerIp;//图片服务器ip @Value("$&#123;ImgServerPort&#125;") private int ImgServerPort;//端口号 @Value("$&#123;ImgServerUsername&#125;") private String ImgServerUsername;//用户名 @Value("$&#123;ImgServerPassword&#125;") private String ImgServerPassword;//密码 @Value("$&#123;ImgServerDirectory&#125;") private String ImgServerDirectory;//存储路径 @Override public boolean Imgupload(InputStream inputStream,String suffix) throws Exception &#123; boolean flag; ImageSftp imageSftp=new ImageSftp(); String fileName= ID_Imghelper.getImgID()+suffix; ChannelSftp connect = imageSftp.getConnect(ImgServerIp, ImgServerPort, ImgServerUsername, ImgServerPassword); //根据时间创建一个字符串作为文件夹的名字，方便管理 String nextDirectory = new SimpleDateFormat("yyyy-MM-dd").format(new Date()); //最终文件存放的目录名 String finalServerDirectory=ImgServerDirectory + "/" + nextDirectory; try &#123; flag= imageSftp.upload(connect,inputStream,finalServerDirectory,fileName); System.out.println("上传返回值："+flag); &#125; catch (IOException e) &#123; e.printStackTrace(); return false; &#125; catch (SftpException e) &#123; return false; &#125; imageSftp.close(); return flag; &#125;&#125; 其中用imageSftp.properties存储服务器信息，使用@Value注解获取配置文件信息。 spring配置： 12345678&lt;bean id="dbproperties" class="org.springframework.beans.factory.config.PreferencesPlaceholderConfigurer"&gt; &lt;property name="locations"&gt; &lt;array&gt; &lt;!--数据库配置文件 --&gt; &lt;value&gt;classpath:db.properties&lt;/value&gt; &lt;!--图片服务器配置文件 --&gt; &lt;value&gt;classpath:imageSftp.properties&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;/bean&gt; imageSftp.properties： 12345ImgServerIp=78.141.206.203ImgServerPort=22ImgServerUsername=rootImgServerPassword=123456ImgServerDirectory=/data/images ID_Imghelper，根据时间随机生成图片Id（文件名）的工具类： 12345678910111213141516171819202122232425262728293031package ID_Utils;import java.util.Random;public class ID_Imghelper &#123; public static String getImgID()&#123; long timeMillis = System.currentTimeMillis(); Random random = new Random(); int randomInt = random.nextInt(9999); //%X 获得数字，把它转为16进制，大写字母 //%04X 增加的04，意思是，转化后的字符串占4个字符，不够用0填充 String imgID=timeMillis+String.format("%04X",randomInt); /*其他转化： * %x - 接受一个数字并将其转化为十六进制数格式, 使用小写字母 * %d, %i - 接受一个数字并将其转化为有符号的整数格式 * %s - 接受一个字符串并按照给定的参数格式化该字符串 * %e - 接受一个数字并将其转化为科学记数法格式, 使用小写字母e */ return imgID; &#125; public static void main(String[] args) &#123; String imgID = ID_Imghelper.getImgID(); System.out.println(imgID); &#125;&#125; 最后，图片回显、结果反馈、中文支持等图片回显只需要把服务器上的文件地址拼接出来即可。 这里给个参考，Controller： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.SH.Controller;import ...@Controllerpublic class testController &#123; @Autowired private IimgService imgService; @RequestMapping(value = "/upload",produces = "text/plain;charset=UTF-8") //produces属性，设置响应格式 @ResponseBody public String upload(MultipartFile file,Map&lt;String,Object&gt; map) throws Exception &#123; InputStream inputStream = file.getInputStream(); System.out.println("文件大小"+file.getSize()); String originalFilename = file.getOriginalFilename(); //截取字符串substring(start,stop)，从下标为start值的位置（第start个字符）开始截取,省略stop会截取start以后得全部字符串 //注意stop值为要截取到字符的对应下标+1，如字符串123，下标为012，从如要截取出字符串12，比喻成区间（下标）为[0,1)，写法为substring(0,2) //lastIndexOf(".")字符串倒数第一个.的下标 String suffix = originalFilename.substring(originalFilename.lastIndexOf(".")); System.out.println(originalFilename); System.out.println(suffix); System.out.println((file.getSize()/1024.00)+"kb"); boolean flag = imgService.Imgupload(inputStream, suffix); //json转换对象 ObjectMapper MAPPER=new ObjectMapper(); if (flag)&#123; map.put("上传成功",flag); //把对象转换为json格式字符串 return MAPPER.writeValueAsString(map); &#125;else &#123; map.put("上传失败",flag); return MAPPER.writeValueAsString(map); &#125; &#125;&#125; 参考文章： https://blog.csdn.net/weixin_36910300/article/details/80532868 https://blog.csdn.net/qq_33390789/article/details/78614466 https://www.cnblogs.com/longyg/archive/2012/06/25/2556576.html https://www.cnblogs.com/ssslinppp/p/6248763.html https://blog.csdn.net/chaogewudi1/article/details/81629183 https://www.cnblogs.com/awkflf11/articles/5179156.html https://www.cnblogs.com/longyg/archive/2012/06/25/2556576.html https://blog.csdn.net/ecjtuxuan/article/details/2093757 https://blog.csdn.net/hl_java/article/details/79035237 https://blog.csdn.net/zjy15203167987/article/details/82531772 https://www.jb51.net/article/135720.htm]]></content>
      <categories>
        <category>学习经验</category>
      </categories>
      <tags>
        <tag>ftp</tag>
        <tag>上传下载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭梯子访问墙外网站]]></title>
    <url>%2F2019%2F08%2F04%2F%E6%90%AD%E6%A2%AF%E5%AD%90%E8%AE%BF%E9%97%AE%E5%A2%99%E5%A4%96%E7%BD%91%E7%AB%99%2F</url>
    <content type="text"><![CDATA[翻墙搭梯子首先你需要一个境外服务器、远程可以用Xshell 6，不熟的可以看站内linux的教程。 安卓客户端： Shadowsocks 参考文章：半醉人间、polarxiong 命令列表： 123#这里所有安装遇到选项一律输y，回车#安装python setuptoolsyum install python-setuptools 12#下载pip压缩包wget https://pypi.python.org/packages/source/p/pip/pip-1.3.1.tar.gz --no-check-certificate 123456789101112#下载完后，解压它tar -xzvf pip-1.3.1.tar.gz#进入解压出的文件夹cd pip-1.3.1#安装pythonpython setup.py install#安装shadowsockspip install shadowsocks#创建shadowsocks文件夹mkdir /etc/shadowsocks#创建并编辑shadowsocks配置文件vi /etc/shadowsocks/config.json 进入config.json文件后按I进入Insert模式，可以进行编辑。 复制粘贴以下内容，注意要填一些东西。 12345678910&#123; "server":"你的服务器的ip地址", "port_password": &#123; "8888": "123456", "8889": "123456" &#125;, "timeout":600, "method":"aes-256-cfb", "fast_open": false&#125; 这里服务器的ip地址我是设为0.0.0.0，方便快照换服务器，然后按Esc、:wq（输入冒号wq，意为保存并退出） 这里是设置服务器端的Shadowsocks，后面需要用到上面你填入的信息，对应为： 主要信息： 服务器ip：你的服务器的ip地址 配置端口：8888、8889 密码都为：123456 加密方式：aes-256-cfb 123#开启服务ssserver -c /etc/shadowsocks/config.json -d start#关闭后面改为stop 12#创建并编辑shadowsocks.service，这里是要配置开机自启动vi /etc/systemd/system/shadowsocks.service 与刚刚一样，进入了这个文件，按i可以进行编辑，把以下内容复制到里面： 123456789101112131415161718[Unit]Description=ShadowsocksAfter=network.target[Service]Type=forkingPIDFile=/run/shadowsocks/server.pidPermissionsStartOnly=trueExecStartPre=/bin/mkdir -p /run/shadowsocksExecStartPre=/bin/chown root:root /run/shadowsocksExecStart=/usr/bin/ssserver --pid-file /var/run/shadowsocks/server.pid -c /etc/shadowsocks/config.json -d startRestart=on-abortUser=rootGroup=rootUMask=0027[Install]WantedBy=multi-user.target esc，:wq 保存退出后，再输入以下命令： 1234567891011#权限chmod 755 /etc/systemd/system/shadowsocks.service#启动、启用systemctl start shadowsockssystemctl enable shadowsocks#配置防火墙开放端口firewall-cmd --zone=public --add-port=8888/tcp --permanentfirewall-cmd --zone=public --add-port=8889/tcp --permanentfirewall-cmd --reload 然后在手机上安装Shadowsocks，填入上面对应的主要信息（服务器ip、端口、密码、加密方式），就可以使用代理了，若握手成功，此时谷歌、Youtube等网站都可以访问了。 填好后，点下面的纸飞机进行连接。]]></content>
      <categories>
        <category>闲谈</category>
      </categories>
      <tags>
        <tag>vpn</tag>
        <tag>梯子</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[远程连接Linux搭建环境]]></title>
    <url>%2F2019%2F08%2F03%2F%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5Linux%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[远程连接、Linux环境搭建1. 安装工具环境准备： 各种安装包：Xshell Plus 6|Xshell 6、Xftp 5、linux版本的jdk、Linux版本的MySQL、Linux版本的Nginx 现在下载jdk需要登录Oracle：Oracle账号分享 我当时用的账号 用户名：nicabeta@email-wizard.com 密码：MQEemoh3pOsRAn2c4tjh 注册机：NetSarang_AIO_7in1_Keygen_v1.4_DFoX_URET 百度网盘（可能会失效）： Xshell Plus 6 【j5r8】 Xftp 5 【d3jq】 注册机 【6zcp】 RDM 【2m91】 Nginx-Linux 【xnno】 jdk-Linux 【bph9】 开始安装 Xshell Plus 6 或 Xshell 6 运行注册机，选择你安装的软件,点击Fix Host+Register，然后点击Generate，然后复制生成的序列号 输入上一步获得的序列号，用户名和公司名称随意，选择路径后安装即可。 Xftp同上： ​ 点下一步，安装即可。 2. 更换服务器的JDK2.1. 拿到服务器ip买的服务器会直接给你ip的，这里我用的虚拟机，桥接模式下与我本机的ip应该是一样的。 点左上角Applications，点Favorites下的 Terminal： 在弹出的命令行窗口，输入： 12ifconfig#获取ip配置信息，windows下命令是ipconfig 回车，即可看到ip信息，复制ens33里的inet后的ip地址： 2.2. 使用Xshell建立连接打开Xshell 6，新建会话，名称随意，主机是刚刚的ip地址： 点击连接，在提示框输入服务器需要的用户名密码，都正确的话会连接成功，有时候第一次连接会报错，再连一次就好了。连接成功会显示： 2.3. 卸载open JDK1.Xshell输入： 1java -version 可看到当前java版本： 2.Xshell输入： 12rpm -qa | grep jdk#抓取jdk 3.Xshell输入： 123rpm -e --nodeps #加要删除对象的完整名称（上面抓取时显示了），需要root身份，这里是：rpm -e --nodeps java-1.8.0-openjdk-1.8.0.181-7.b13.el7.x86_64rpm -e --nodeps java-1.8.0-openjdk-headless-1.8.0.181-7.b13.el7.x86_64 不报错，并且输入java -version提示找不到文件，即卸载成功： 2.4. 安装准备的JDK1.Xshell输入： 12pwd#获取当前所在的目录（文件夹）路径 此时在/root目录下。 2.Xshell输入： 123456cd /usr/local#进入指定目录，可用pwd确认当前所在的目录mkdir java#在当前目录 创建java文件夹cd java#进入java文件夹内，可用pwd确认当前所在的目录 点击帮助正下方的绿色按钮，打开Xftp，右边一般会自动定位到服务器的当前目录，左边是本机电脑，把下载好的jdk拖到右边就行了，注意目录： 3.Xshell输入 123456789101112131415ls#列出当前目录的文件名称ll#列出当前目录文件的详细信息tar -zxvf 文件名#解压tar包压缩文件，此处为：tar -zxvf jdk-8u221-linux-x64.tar.gzls#列出当前目录的文件名称cd jdk1.8.0_221#进入jdk解压后的文件夹ls#列出当前目录的文件名称 4.Xshell输入 12vim /etc/profile#编辑指定的文件，这里是配置环境变量 5.键盘按I键，进入Insert编辑，按方向键把光标移到最下方： 输入（##是注释）： 1234##jdk1.8export JAVA_HOME=/usr/local/java/jdk1.8.0_221export PATH=$JAVA_HOME/bin:$PATHexport CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar 键盘按esc，输入冒号wq（意为保存并退出），回车。 此处输入： 12:wq#保存并退出 扩展知识： 12:q!#不保存强制退出s 6.Xshell输入： 123456cat /etc/profile#将指定文件显示出来，这里是看一下刚刚的文件是否已保存source /etc/profile#使刚刚的配置文件生效java -version#验证jdk 正常的结果： 到此JDK安装配置结束。 3. 安装MySQL。以后装 4. 安装Redis非关系型数据库，Redis是一个开源的使用C语言编写(3万多行代码)，支持网络，可基于内存亦可持久化的日志型，Key-Value数据库，并提供多种语言的API。 持久化 Redis是内存数据库，数据都是存储在内存中，为了避免进程退出导致数据的永久丢失，需要定期将Redis中的数据以某种形式（数据或命令）从内存保存到硬盘。 RDB模式，默认启用，每隔一段时间，达到指定操作次数后，将数据存为文件。 AOF模式，默认不用，根据设置的条件，每秒或每次操作或由系统决定，将数据经历的指令保存为文件。 AOF重写，Redis会根据AOF的体积进行AOF重写，重写是将指令重新执行，然后把等价于最后结果的指令替换原来的一堆指令。 持久化文件损坏修复，会把文件损坏的部分切掉，会牺牲部分数据，相当于截肢，之后数据会有所偏差。 两种模式都启用时，以AOF为准。 通常，Redis将数据存储于内存中，或被配置为使用虚拟内存。通过两种方式可以实现数据持久化：使用快照（snapshot）的方式，将内存中的数据不断写入磁盘，或使用类似MySQL的binlog日志（aof但并不用于主从同步）方式，记录每次更新的日志。前者性能较高，但是可能会引起一定程度的数据丢失；后者相反。 数据类型 作为Key-value型存储系统数据库，Redis提供了键（Key）和值（value）映射关系。但是，除了常规的数值或字符串，Redis的键值还可以是以下形式之一，下面为最为常用的数据类型： 123456&gt; String 字符串&gt; Hash 哈希表&gt; List 列表&gt; Set 集合&gt; Sorted set 有序集合&gt; 4.1. 准备安装包或wget下载离线下载 或 服务器上选个存放安装包的目录，用wget下载 1234#进入存放目录cd /usr/local#wget加下载地址wget http://download.redis.io/releases/redis-5.0.5.tar.gz 4.2. 准备安装环境安装需要gcc编译，所以安装前需要看一下gcc的版本 12#查看gcc版本gcc -v 确认gcc版本是不是4.2以上，若没有gcc或版本不够，需要再安装gcc 12#安装gccyum install gcc 装好后确认一下gcc版本。 4.3. Redis安装解压下载好的Redis的压缩包 1234#解压tar -zxvf redis-5.0.5.tar.gz#进入解压出的文件夹cd redis-5.0.5 尝试安装测试（必要） 1234#若报错，去百度对应提示make MALLOC=libc#测试安装，不管有没有错误，都会回滚。出错的话，根据错误提示去百度解决make test 我这里错误是提示需要tcl支持，所以要安装tcl 1234#安装tclyum install tcl#继续make测试，直到无错误提示make test 正式安装 12cd srcmake install 无错，即成功。 4.4. 运行Redis前台运行在Redis安装目录下 12#前台运行redis./redis-server 前台运行的话，不能关闭那个界面，关闭的话就会关闭服务。 后台运行配置服务 应该使用后台运行的方式，需要进行如下配置： ①修改redis配置文件为后台模式启动 12#修改redis配置文件vi /usr/local/redis-5.0.5/redis.conf 按i进入编辑模式，将daemonize no改为daemonize yes，esc，:wq保存退出。 daemonize意思为：是否守护线程启动（是否后台模式启动） 修改ip绑定，将bind 127.0.0.1 修改为bind 0.0.0.0 （4个0），表示所有ip都可以连接。注意别改错了，是没有#号的bind 127.0.0.1。（这个时指定redis的客户端地址，安全考虑） 123#bind 127.0.0.1#-&gt;bind 0.0.0.0 设置密码（可选） esc退出编辑模式，输入/require（搜索require），把#号去掉，然后requirepass后的值就是你的密码 1requirepass password ②将redis配置文件redis.conf复制到/etc/redis目录下，并改名为6379.conf 12345678cd /etcmkdir rediscd redis#把目标文件复制到当前目录cp /usr/local/redis-5.0.5/redis.conf ./#把目标文件移动到本目录，并重命名为mv redis.conf 6379.conf#tips：把目标文件覆盖复制到当前目录并改名为（cp -f 目标目录 6379.conf） ③复制启动脚本到/etc/rc.d/init.d/，并改名为redisd 启动脚本为：/usr/local/redis-5.0.5/utils/redis_init_script 123456#把目标文件复制到指定目录下，并命名为redisdcp /usr/local/redis-5.0.5/utils/redis_init_script /etc/rc.d/init.d/redisd#或手动改名：#cd /etc/rc.d/init.d/#ls#mv redis_init_script redisd ④修改刚刚重命名的redisd文件，让它成为服务 12cd /etc/rc.d/init.d/vim redisd 按i进入编辑模式 老版本需要在脚本文件的第一行后，加入一行（包括#号）： 1#chkconfig:2345 80 90 新版不用加。 然后，修改EXEC、CLIEXEC的路径： 1234567#原内容EXEC=/usr/local/bin/redis-serverCLIEXEC=/usr/local/bin/redis-cli#修改后的内容EXEC=/usr/local/redis-5.0.5/src/redis-serverCLIEXEC=/usr/local/redis-5.0.5/src/redis-cli 最后，找到case**in什么的那一块代码，在$EXEC $CONF 后面加上 &amp;（空格+&amp;符号+空格） 启动Redis 12345#添加开机启动chkconfig redisd on#防火墙开放6379端口firewall-cmd --zone=public --add-port=6379/tcp --permanentfirewall-cmd --reload 123456789101112#运行redisservice redisd start#停止redisservice redisd stop#修改redis配置文件vi /etc/redis/6379.conf#查看运行状态ps -ef | grep redis#强行kill进程，14399是目标进程的idkill -9 14399 #移除pid文件rm -f /var/run/redis_6379.pid 4.5. Redis使用1234cd /usr/local/redis-5.0.5/src/ls#redis客户端redis-cli redis的一些命令，自行百度 123456#设置set abc 123#取值get abc#显示全部keykeys * Redis命令表 RDM 提取码：【2m91】 5. 安装Nginx5.1. 准备安装包把安装文件传到服务器。 或者使用weget方式在服务器内下载也行： 123cd /usr/localweget http://nginx.org/download/nginx-1.17.1.tar.gz#下载安装包到usr/local 解压 1234tar -zxvf nginx-1.17.1.tar.gz#解压，z表示gzip压缩格式，x表示提取文件，v表示显示解压过程，f指定文件ll#显示当前文件夹的文件 5.2. 准备安装环境安装前必须安装nginx所需的依赖库。 安装依赖，仔细执行： 12345678yum install gcc-c++yum install pcreyum install pcre-develyum install zlibyum install zlib-develyum install opensslyum install openssl-devel#遇到选项输y即可 5.3. Nginx安装1234567ll#显示当前文件夹的文件cd nginx-1.17.1ll#显示当前文件夹的文件./configure#执行configure文件，输一半名字按tab会自动补全文件名的 执行make安装 12345678910make install#注意在nginx-1.17.1目录下执行#它会将nginx安装到/usr/local/nginx目录下cd ..#返回上一目录ll#显示当前文件夹的文件cd nginxpwd#显示当前所在的目录 配置Nginx开机启动 1234cd /lib/systemd/systemvim nginx.service#创建nginx.service文件并编辑，也可以用touch命令创建。#vim不行就vi 按I，添加如下内容： 12345678910111213[Unit]Description=nginxAfter=network.target[Service]Type=forkingExecStart=/usr/local/nginx/sbin/nginxExecReload=/usr/local/nginx/sbin/nginx reloadExecStop=/usr/local/nginx/sbin/nginx quitPrivateTmp=true[Install]WantedBy=multi-user.target esc :wq 保存并退出，用cat检查下刚刚的文件。 接着输入： 12systemctl enable nginx.service#使其开机启动 安装配置，到此就完成了。 5.4. Nginx指令、运行检查12345678systemctl start nginx.service#启动systemctl stop nginx.service#停止systemctl restart nginx.service#重启 启动Nginx，浏览器输入ip，若访问不到： 1234#添加80端口配置防火墙firewall-cmd --zone=public --add-port=80/tcp --permanent#重新加载firewall-cmd --reload 再去访问即可。 12chmod a+x /usr/local/nginx#访问权限,a+x ==&gt; all user can execute 所有用户可执行 关于路径 nginx根目录是/nginx/html文件夹。我的是：/usr/local/nginx/html 比如在html文件夹下建images文件夹，里面放张图片123.png，那么图片的路径就是：http://ip地址/images/123.png 路径配置 比如在根部吗建立data文件夹，在data下建立www和images两个文件夹： 123456mkdir /datacd /datamkdir wwwcd ..mkdir imagesll 然后打开nginx的配置文件/usr/local/nginx/conf/nginx.conf 注释掉原文http｛｝代码块，或者再其基础上修改成: 123456789101112131415161718http&#123;server &#123; #root的路径实际是nginx文件夹内的相对路径,/是主机根目录 #把访问时的ip地址/，设置为本机根目录下的/data/www文件夹 # 首页设为其文件夹下的index.html或index.htm location / &#123; root /data/www; index index.html index.htm; &#125; #地址栏里"/"后的路径是直接匹配目录/data下的路径 #如访问ip地址/images时,配匹配/data/images #把访问时的ip/images路径，设置为 location /images/ &#123; root /data; &#125;&#125;&#125; 关于SSL证书 6.Tomcat&amp;Maven热部署Tomcat准备 Tomcat的安装与Windows一致，解压相应的tomcat-*.tar.gz文件即可 端口号的修改在conf/server.xml配置文件中改 增加角色和权限，修改conf/tomcat-user.xml： 123&lt;role rolename="manager-gui" /&gt;&lt;role rolename="manager-script" /&gt;&lt;user username="tomcat" password="tomcat" roles="manager-gui, manager-script"/&gt; 然后在tomcat-manager界面，deploy你的war包即可，热部署无需重启服务器。 Maven插件配置 增加Pom.xml中的tomcat7插件 123456789101112&lt;!-- 配置Tomcat插件 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;port&gt;8081&lt;/port&gt; &lt;path&gt;/&lt;/path&gt; &lt;!--对应tomcat中的ROOT文件夹--&gt; &lt;url&gt;http://yourIpAndPort/manager/text&lt;/url&gt; &lt;!--其中/manager/text是固定写法--&gt; &lt;username&gt;tomcat&lt;/username&gt; &lt;!--你的tomcat角色用户名和密码--&gt; &lt;password&gt;tomcat&lt;/password&gt; &lt;/configuration&gt; &lt;/plugin&gt; 路径为/时，由于tomcat中ROOT目录已经存在，所以使用tomcat7:redeploy命令，若path为其他值，直接deploy即可，建议先clean，-Dskiptest可以跳过测试阶段，-X输出debug信息。]]></content>
      <categories>
        <category>学习经验</category>
      </categories>
      <tags>
        <tag>开发知识</tag>
        <tag>Linux系统</tag>
        <tag>远程连接</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[虚拟机、Linux系统(CentOs)的安装]]></title>
    <url>%2F2019%2F08%2F03%2F%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%81Linux%E7%B3%BB%E7%BB%9F-CentOs-%E7%9A%84%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[虚拟机、Linux系统环境准备： 虚拟机工具：VMwear安装包【提取码：8k77】 Linux系统：CentOS7镜像 1. 安装虚拟机1.1. 安装VMwear运行VMwear安装包，过程很简单。 1.2. 创建虚拟机 VMwear安装完成后，打开它: 选择创建新的虚拟机，若选典型会自动为新手配置一些东西，这里选自定义： 兼容性问题，VMwear是高版本兼容低版本的，低版本不兼容高版本，这里选当前VMwear的版本就好，我给的资源版本号是12： 下一步，选稍后安装系统： 选择Linux系统，版本是CentOs 64位： 为虚拟机指定名称和位置，我新建了一个目录来存放，方便自己以后查找： 根据自己的实际需求来分配cpu，以后使用中CPU不够的话可以加，这里我选的11： 分配内存，要考虑到本机的空闲内存： 我计算机是8G内存，日常使用中，除开系统占用，开了几个浏览器、视频，只剩余了3G内存。 又考虑到会模拟多台服务器的运行，所以分配内存不能太大，也不能过低。 我选的1G内存，装了半天的系统，不过没关系，后面在设置里可以改的。 选择网络类型，这里选桥接： tips： 桥接：选择桥接模式的话虚拟机和宿主机在网络上就是平级的关系，相当于连接在同一交换机上。 NAT：NAT模式就是虚拟机要联网得先通过宿主机才能和外面进行通信。 仅主机：虚拟机与宿主机直接连起来 I/O控制器类型&amp;和磁盘类型选默认的即可： 由于是第一次使用虚拟机，选择创建新的虚拟磁盘： 磁盘空间分配： 我在VMwear下新建了一个VsFile文件夹，用来保存虚拟磁盘的文件： tips: 磁盘容量暂时分配50G即可后期可以随时增加，不要勾选立即分配所有磁盘，否则虚拟机会将50G直接分配给CentOS，会导致宿主机所剩硬盘容量减少。 勾选将虚拟磁盘拆分成多个文件，这样可以使虚拟机方便用储存设备拷贝复制。 自定义硬件： 移除不需要的硬件，如声卡、打印机。 然后点击完成，即可创建一个虚拟机。 2. 安装Linux系统(CentOs)2.1. 连接光盘右击刚创建的虚拟机，选择设置，选择下载好的CentOS映像，注意勾选启动时链接 2.2. 运行虚拟机虚拟机创建完成后，点开启此虚拟机即可。 2.3. 安装系统 安装向导 启动后会看到以下选项： Install CentOS 7 安装CentOS 7 Test this media &amp; install CentOS 7 测试安装文件并安装CentOS 7 Troubleshooting 修复故障 选择选项：Install CentOS 7，回车。 选择语言English、时间、时区，这个按自己需要选，不再赘述。 在Software selection里面选Server with GUI，然点左上角的done，就行了。 设置主机名与网卡信息 暂时选自动挂载分区（实际开发中需要仔细配置） 点击右下角开始安装，设置密码（用户可不设置），以后用Root登录 等待安装即可。 完毕后会让你点Reboot重启： 重启后，需要同意协议 点finish,到此Linux系统就安装完成了。 关于更多的配置，我找到一个很详细的文章，可以参照。]]></content>
      <categories>
        <category>学习经验</category>
      </categories>
      <tags>
        <tag>开发知识</tag>
        <tag>Linux系统</tag>
        <tag>虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lombok插件]]></title>
    <url>%2F2019%2F08%2F01%2FIdea%E5%A2%9E%E5%8A%A0Lombok%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[为IDE装上Lombok插件Lombok提供了一套注解，可以大量的简化java代码。 Lombok支持Eclipse或Idea，需要先下载zip文件：下载地址 IDEA主要介绍下插件在Idea的使用 下载插件后在IDEA界面，右下角Configure，选Plugins 进入插件界面后，点齿轮设置,选Install Plugin from Disk… 选刚刚下载插件的zip文件 点重启IDEA。 重启后在Setting里设置：勾选Enable annotation processing Lombok的文档 Introduction Installation Lombok Annotations @Getter and @Setter @NonNull @ToString @EqualsAndHashCode @Data @Cleanup @Synchronized @SneakyThrows Costs and Benefits What are we missing? Limitations Controversy Summary References 详情： Introduction“Boilerplate” is a term used to describe code that is repeated in many parts of an application with little alteration. One of the most frequently voiced criticisms of the Java language is the volume of this type of code that is found in most projects. This problem is frequently a result of design decisions in various libraries, but is exacerbated by limitations in the language itself. Project Lombok aims to reduce the prevalence of some of the worst offenders by replacing them with a simple set of annotations. While it is not uncommon for annotations to be used to indicate usage, to implement bindings or even to generate code used by frameworks, they are generally not used for the generation of code that is directly utilized by the application. This is partly because doing so would require that the annotations be eagerly processed at development time. Project Lombok does just that. By integrating into the IDE, Project Lombok is able to inject code that is immediately available to the developer. For example, simply adding the @Data annotation to a data class, as below, results in a number of new methods in the IDE: InstallationProject Lombok is available as a single jar file on the project site. It includes the APIs for development as an installer for IDE integration. On most systems, simply double-clicking the jar file will launch the installer. If the system is not configured to correctly launch jar files, it can also be run from the command line as follows: 1java -jar lombok.jar The installer will attempt to detect the location of a supported IDE. If it cannot correctly determine where the IDE is installed, the location can be specified manually. Simply click “Install/Update” and IDE integration is complete. At the time of this article’s writing, only Eclipse and NetBeans are supported. However, the release of the IntelliJ IDEA source code has placed IDEA support as a possibility for future releases, and limited success has already been reported with JDeveloper. The jar file will still need to be included in the classpath of any projects that will use Project Lombok annotations. Maven users can include Lombok as a dependency by adding this to the project pom.xml file: 12345678910111213&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;0.9.2&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;projectlombok.org&lt;/id&gt; &lt;url&gt;http://projectlombok.org/mavenrepo&lt;/url&gt; &lt;/repository&gt;&lt;/repositories&gt; Lombok AnnotationsIt is not uncommon for a typical Java project to devote hundreds of lines of code to the boilerplate required for defining simple data classes. These classes generally contain a number of fields, getters and setters for those fields, as well as equals and hashCode implementations. In the simplest scenarios, Project Lombok can reduce these classes to the required fields and a single @Data annotation. Of course, the simplest scenarios are not necessarily the ones that developers face on a day-to-day basis. For that reason, there are a number of annotations in Project Lombok to allow for more fine grained control over the structure and behavior of a class. @Getter and @SetterThe @Getter and @Setter annotations generate a getter and setter for a field, respectively. The getters generated correctly follow convention for boolean properties, resulting in an isFoo getter method name instead of getFoofor any boolean field foo. It should be noted that if the class to which the annotated field belongs contains a method of the same name as the getter or setter to be generated, regardless of parameter or return types, no corresponding method will be generated. Both the @Getter and @Setter annotations take an optional parameter to specify the access level for the generated method. Lombok annotated code: 12@Getter @Setter private boolean employed = true;@Setter(AccessLevel.PROTECTED) private String name; Equivalent Java source code: 1234567891011121314private boolean employed = true;private String name;public boolean isEmployed() &#123; return employed;&#125;public void setEmployed(final boolean employed) &#123; this.employed = employed;&#125;protected void setName(final String name) &#123; this.name = name;&#125; @NonNullThe @NonNull annotation is used to indicate the need for a fast-fail null check on the corresponding member. When placed on a field for which Lombok is generating a setter method, a null check will be generated that will result in a NullPointerException should a null value be provided. Additionally, if Lombok is generating a constructor for the owning class then the field will be added to the constructor signature and the null check will be included in the generated constructor code. This annotation mirrors @NotNull and @NonNull annotations found in IntelliJ IDEA and FindBugs, among others. Lombok is annotation agnostic with regards to these variations on the theme. If Lombok comes across any member annotated with any annotation of the name @NotNull or @NonNull, it will honor it by generating the appropriate corresponding code. The authors of Project Lombok further comment that, in the event that annotation of this type is added to Java, then the Lombok version will be subject to removal. Lombok annotated code from the class Family: 12@Getter @Setter @NonNullprivate List&lt;Person&gt; members; Equivalent Java source code: 1234567891011121314151617@NonNullprivate List&lt;Person&gt; members;public Family(@NonNull final List&lt;Person&gt; members) &#123; if (members == null) throw new java.lang.NullPointerException(&quot;members&quot;); this.members = members;&#125; @NonNullpublic List&lt;Person&gt; getMembers() &#123; return members;&#125;public void setMembers(@NonNull final List&lt;Person&gt; members) &#123; if (members == null) throw new java.lang.NullPointerException(&quot;members&quot;); this.members = members;&#125; @ToStringThis annotation generates an implementation of the toString method. By default, any non-static fields will be included in the output of the method in name-value pairs. If desired, the inclusion of the property names in the output can be suppressed by setting the annotation parameter includeFieldNames to false. Specific fields can be excluded from the output of the generated method by including their field names in the exclude parameter. Alternatively, the of parameter can be used to list only those fields which are desired in the output. The output of the toString method of a superclass can also be included by setting the callSuper parameter to true. Lombok annotated code: 123456@ToString(callSuper=true,exclude=&quot;someExcludedField&quot;)public class Foo extends Bar &#123; private boolean someBoolean = true; private String someStringField; private float someExcludedField;&#125; Equivalent Java source code: 123456789101112public class Foo extends Bar &#123; private boolean someBoolean = true; private String someStringField; private float someExcludedField; @java.lang.Override public java.lang.String toString() &#123; return &quot;Foo(super=&quot; + super.toString() + &quot;, someBoolean=&quot; + someBoolean + &quot;, someStringField=&quot; + someStringField + &quot;)&quot;; &#125;&#125; @EqualsAndHashCodeThis class level annotation will cause Lombok to generate both equals and hashCode methods, as the two are tied together intrinsically by the hashCode contract. By default, any field in the class that is not static or transient will be considered by both methods. Much like @ToString, the exclude parameter is provided to prevent field from being included in the generated logic. One can also use the of parameter to list only those fields should be considered. Also like @ToString, there is a callSuper parameter for this annotation. Setting it to true will cause equals to verify equality by calling the equals from the superclass before considering fields in the current class. For thehashCode method, it results in the incorporation of the results of the superclass’s hashCode in the calculation of the hash. When setting callSuper to true, be careful to make sure that the equals method in the parent class properly handles instance type checking. If the parent class checks that the class is of a specific type and not merely that the classes of the two objects are the same, this can result in undesired results. If the superclass is using a Lombok generated equals method, this is not an issue. However, other implementations may not handle this situation correctly. Also note that setting callSuper to true cannot be done when the class only extends Object, as it would result in an instance equality check that short-circuits the comparison of fields. This is due to the generated method calling the equals implementation on Object, which returns false if the two instances being compared are not the same instance. As a result, Lombok will generate a compile time error in this situation. Lombok annotated code: 12345678910111213@EqualsAndHashCode(callSuper=true,exclude=&#123;&quot;address&quot;,&quot;city&quot;,&quot;state&quot;,&quot;zip&quot;&#125;)public class Person extends SentientBeing &#123; enum Gender &#123; Male, Female &#125; @NonNull private String name; @NonNull private Gender gender; private String ssn; private String address; private String city; private String state; private String zip;&#125; Equivalent Java source code: 12345678910111213141516171819202122232425262728293031323334353637383940public class Person extends SentientBeing &#123; enum Gender &#123; /*public static final*/ Male /* = new Gender() */, /*public static final*/ Female /* = new Gender() */; &#125; @NonNull private String name; @NonNull private Gender gender; private String ssn; private String address; private String city; private String state; private String zip; @java.lang.Override public boolean equals(final java.lang.Object o) &#123; if (o == this) return true; if (o == null) return false; if (o.getClass() != this.getClass()) return false; if (!super.equals(o)) return false; final Person other = (Person)o; if (this.name == null ? other.name != null : !this.name.equals(other.name)) return false; if (this.gender == null ? other.gender != null : !this.gender.equals(other.gender)) return false; if (this.ssn == null ? other.ssn != null : !this.ssn.equals(other.ssn)) return false; return true; &#125; @java.lang.Override public int hashCode() &#123; final int PRIME = 31; int result = 1; result = result * PRIME + super.hashCode(); result = result * PRIME + (this.name == null ? 0 : this.name.hashCode()); result = result * PRIME + (this.gender == null ? 0 : this.gender.hashCode()); result = result * PRIME + (this.ssn == null ? 0 : this.ssn.hashCode()); return result; &#125;&#125; @DataThe @Data annotation is likely the most frequently used annotation in the Project Lombok toolset. It combines the functionality of @ToString, @EqualsAndHashCode, @Getter and @Setter. Essentially, using @Data on a class is the same as annotating the class with a default @ToString and @EqualsAndHashCode as well as annotating each field with both @Getter and @Setter. Annotation a class with @Data also triggers Lombok’s constructor generation. This adds a public constructor that takes any @NonNull or final fields as parameters. This provides everything needed for a Plain Old Java Object (POJO). While @Data is extremely useful, it does not provide the same granularity of control as the other Lombok annotations. In order to override the default method generation behaviors, annotate the class, field or method with one of the other Lombok annotations and specify the necessary parameter values to achieve the desired effect. @Data does provide a single parameter option that can be used to generate a static factory method. Setting the value of the staticConstructor parameter to the desired method name will cause Lombok to make the generated constructor private and expose a a static factory method of the given name. Lombok annotated code: 123456@Data(staticConstructor=&quot;of&quot;)public class Company &#123; private final Person founder; private String name; private List&lt;Person&gt; employees;&#125; Equivalent Java source code: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class Company &#123; private final Person founder; private String name; private List&lt;Person&gt; employees; private Company(final Person founder) &#123; this.founder = founder; &#125; public static Company of(final Person founder) &#123; return new Company(founder); &#125; public Person getFounder() &#123; return founder; &#125; public String getName() &#123; return name; &#125; public void setName(final String name) &#123; this.name = name; &#125; public List&lt;Person&gt; getEmployees() &#123; return employees; &#125; public void setEmployees(final List&lt;Person&gt; employees) &#123; this.employees = employees; &#125; @java.lang.Override public boolean equals(final java.lang.Object o) &#123; if (o == this) return true; if (o == null) return false; if (o.getClass() != this.getClass()) return false; final Company other = (Company)o; if (this.founder == null ? other.founder != null : !this.founder.equals(other.founder)) return false; if (this.name == null ? other.name != null : !this.name.equals(other.name)) return false; if (this.employees == null ? other.employees != null : !this.employees.equals(other.employees)) return false; return true; &#125; @java.lang.Override public int hashCode() &#123; final int PRIME = 31; int result = 1; result = result * PRIME + (this.founder == null ? 0 : this.founder.hashCode()); result = result * PRIME + (this.name == null ? 0 : this.name.hashCode()); result = result * PRIME + (this.employees == null ? 0 : this.employees.hashCode()); return result; &#125; @java.lang.Override public java.lang.String toString() &#123; return &quot;Company(founder=&quot; + founder + &quot;, name=&quot; + name + &quot;, employees=&quot; + employees + &quot;)&quot;; &#125;&#125; @CleanupThe @Cleanup annotation can be used to ensure that allocated resources are released. When a local variable is annotated with @Cleanup, any subsequent code is wrapped in a try/finally block that guarantees that the cleanup method is called at the end of the current scope. By default @Cleanup assumes that the cleanup method is named “close”, as with input and output streams. However, a different method name can be provided to the annotation’svalue parameter. Only cleanup methods which take no parameters are able to be used with this annotation. There is also a caveat to consider when using the @Cleanup annotation. In the event that an exception is thrown by the cleanup method, it will preempt any exception that was thrown in the method body. This can result in the actual cause of an issue being buried and should be considered when choosing to use Project Lombok’s resource management. Furthermore, with automatic resource management on the horizon in Java 7, this particular annotation is likely to be relatively short-lived. Lombok annotated code: 123456789public void testCleanUp() &#123; try &#123; @Cleanup ByteArrayOutputStream baos = new ByteArrayOutputStream(); baos.write(new byte[] &#123;&apos;Y&apos;,&apos;e&apos;,&apos;s&apos;&#125;); System.out.println(baos.toString()); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; Equivalent Java source code: 12345678910111213public void testCleanUp() &#123; try &#123; ByteArrayOutputStream baos = new ByteArrayOutputStream(); try &#123; baos.write(new byte[]&#123;&apos;Y&apos;, &apos;e&apos;, &apos;s&apos;&#125;); System.out.println(baos.toString()); &#125; finally &#123; baos.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; @SynchronizedUsing the synchronized keyword on a method can result in unfortunate effects, as any developer who has worked on multi-threaded software can attest. The synchronized keyword will lock on the current object (this) in the case of an instance method or on the class object for a static method. This means that there is the potential for code outside of the control of the developer to lock on the same object, resulting in a deadlock. It is generally advisable to instead lock explicitly on a separate object that is dedicated solely to that purpose and not exposed in such a way as to allow unsolicited locking. Project Lombok provides the @Synchronized annotation for that very purpose. Annotating an instance method with @Synchronized will prompt Lombok to generate a private locking field named $lock on which the method will lock prior to executing. Similarly, annotating a static method in the same way will generate a private static object named $LOCK for the static method to use in an identical fashion. A different locking object can be specified by providing a field name to the annotation’s value parameter. When a field name is provided, the developer must define the property as Lombok will not generate it. Lombok annotated code: 123456private DateFormat format = new SimpleDateFormat(&quot;MM-dd-YYYY&quot;);@Synchronizedpublic String synchronizedFormat(Date date) &#123; return format.format(date);&#125; Equivalent Java source code: 12345678private final java.lang.Object $lock = new java.lang.Object[0];private DateFormat format = new SimpleDateFormat(&quot;MM-dd-YYYY&quot;);public String synchronizedFormat(Date date) &#123; synchronized ($lock) &#123; return format.format(date); &#125;&#125; @SneakyThrows@SneakyThrows is probably the Project Lombok annotation with the most detractors, since it is a direct assault on checked exceptions. There is a lot of disagreement with regards to the use of checked exceptions, with a large number of developers holding that they are a failed experiment. These developers will love @SneakyThrows. Those developers on the other side of the checked/unchecked exception fence will most likely view this as hiding potential problems. Throwing IllegalAccessException would normally generate an “Unhandled exception” error if IllegalAccessException, or some parent class, is not listed in a throws clause: When annotated with @SneakyThrows, the error goes away. By default, @SneakyThrows will allow any checked exception to be thrown without declaring in the throws clause. This can be limited to a particular set of exceptions by providing an array of throwable classes ( Class&lt;? extends Throwable&gt;) to the value parameter of the annotation. Lombok annotated code: 1234@SneakyThrowspublic void testSneakyThrows() &#123; throw new IllegalAccessException();&#125; Equivalent Java source code: 1234567public void testSneakyThrows() &#123; try &#123; throw new IllegalAccessException(); &#125; catch (java.lang.Throwable $ex) &#123; throw lombok.Lombok.sneakyThrow($ex); &#125;&#125; A look at the above code and the signature of Lombok.sneakyThrow(Throwable) would lead most to believe that the exception is being wrapped in a RuntimeException and re-thrown, however this is not the case. ThesneakyThrow method will never return normally and will instead throw the provided throwable completely unaltered. Costs and BenefitsAs with any technology choice, there are both positive and negative effects of using Project Lombok. Incorporating Lombok’s annotations in a project can greatly reduce the number of lines of boilerplate code that are either generated in the IDE or written by hand. This results in reduced maintenance overhead, fewer bugs and more readable classes. That is not to say that there are not downsides to using Project Lombok annotations in your project. Project Lombok is largely aimed at filling gaps in the Java language. As such, there is the possibility that changes to the language will take place that preclude the use of Lombok’s annotations, such as the addition of first class property support. Additionally, when used in combination with annotation-based object-relational mapping (ORM) frameworks, the number of annotations on data classes can begin to get unwieldy. This is largely offset by the amount of code that is superseded by the Lombok annotations. However, those who shun the frequent use of annotations may choose to look the other way. What is missing?Project Lombok provides the delombok utility for replacing the Lombok annotations with equivalent source code. This can be done for an entire source directory via the command line. 1java -jar lombok.jar delombok src -d src-delomboked Alternatively, an Ant task is provided for incorporation into a build process. 1234567&lt;target name=&quot;delombok&quot;&gt; &lt;taskdef classname=&quot;lombok.delombok.ant.DelombokTask&quot; classpath=&quot;WebRoot/WEB-INF/lib/lombok.jar&quot; name=&quot;delombok&quot; /&gt; &lt;mkdir dir=&quot;src-delomboked&quot; /&gt; &lt;delombok verbose=&quot;true&quot; encoding=&quot;UTF-8&quot; to=&quot;src-delomboked&quot; from=&quot;src&quot; /&gt;&lt;/target&gt; Both delombok and the corresponding Ant task come packaged in the core lombok.jar download. Along with allowing Lombok annotations to be useful in applications built using Google Web Toolkit (GWT) or other incompatible frameworks, running delombok on the Person class makes it easy to contrast the class as written using the Lombok annotations against code that includes the equivalent boilerplate inline. 123456789101112131415161718192021222324package com.ociweb.jnb.lombok;import java.util.Date;import lombok.Data;import lombok.EqualsAndHashCode;import lombok.NonNull;@Data@EqualsAndHashCode(exclude=&#123;&quot;address&quot;,&quot;city&quot;,&quot;state&quot;,&quot;zip&quot;&#125;)public class Person &#123; enum Gender &#123; Male, Female &#125; @NonNull private String firstName; @NonNull private String lastName; @NonNull private final Gender gender; @NonNull private final Date dateOfBirth; private String ssn; private String address; private String city; private String state; private String zip;&#125; The code utilizing the Project Lombok annotations is significantly more concise than the equivalent class with the boilerplate included. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167package com.ociweb.jnb.lombok;import java.util.Date;import lombok.NonNull;public class Person &#123; enum Gender &#123; /*public static final*/ Male /* = new Gender() */, /*public static final*/ Female /* = new Gender() */; &#125; @NonNull private String firstName; @NonNull private String lastName; @NonNull private final Gender gender; @NonNull private final Date dateOfBirth; private String ssn; private String address; private String city; private String state; private String zip; public Person(@NonNull final String firstName, @NonNull final String lastName, @NonNull final Gender gender, @NonNull final Date dateOfBirth) &#123; if (firstName == null) throw new java.lang.NullPointerException(&quot;firstName&quot;); if (lastName == null) throw new java.lang.NullPointerException(&quot;lastName&quot;); if (gender == null) throw new java.lang.NullPointerException(&quot;gender&quot;); if (dateOfBirth == null) throw new java.lang.NullPointerException(&quot;dateOfBirth&quot;); this.firstName = firstName; this.lastName = lastName; this.gender = gender; this.dateOfBirth = dateOfBirth; &#125; @NonNull public String getFirstName() &#123; return firstName; &#125; public void setFirstName(@NonNull final String firstName) &#123; if (firstName == null) throw new java.lang.NullPointerException(&quot;firstName&quot;); this.firstName = firstName; &#125; @NonNull public String getLastName() &#123; return lastName; &#125; public void setLastName(@NonNull final String lastName) &#123; if (lastName == null) throw new java.lang.NullPointerException(&quot;lastName&quot;); this.lastName = lastName; &#125; @NonNull public Gender getGender() &#123; return gender; &#125; @NonNull public Date getDateOfBirth() &#123; return dateOfBirth; &#125; public String getSsn() &#123; return ssn; &#125; public void setSsn(final String ssn) &#123; this.ssn = ssn; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(final String address) &#123; this.address = address; &#125; public String getCity() &#123; return city; &#125; public void setCity(final String city) &#123; this.city = city; &#125; public String getState() &#123; return state; &#125; public void setState(final String state) &#123; this.state = state; &#125; public String getZip() &#123; return zip; &#125; public void setZip(final String zip) &#123; this.zip = zip; &#125; @java.lang.Override public java.lang.String toString() &#123; return &quot;Person(firstName=&quot; + firstName + &quot;, lastName=&quot; + lastName + &quot;, gender=&quot; + gender + &quot;, dateOfBirth=&quot; + dateOfBirth + &quot;, ssn=&quot; + ssn + &quot;, address=&quot; + address + &quot;, city=&quot; + city + &quot;, state=&quot; + state + &quot;, zip=&quot; + zip + &quot;)&quot;; &#125; @java.lang.Override public boolean equals(final java.lang.Object o) &#123; if (o == this) return true; if (o == null) return false; if (o.getClass() != this.getClass()) return false; final Person other = (Person)o; if (this.firstName == null ? other.firstName != null : !this.firstName.equals(other.firstName)) return false; if (this.lastName == null ? other.lastName != null : !this.lastName.equals(other.lastName)) return false; if (this.gender == null ? other.gender != null : !this.gender.equals(other.gender)) return false; if (this.dateOfBirth == null ? other.dateOfBirth != null : !this.dateOfBirth.equals(other.dateOfBirth)) return false; if (this.ssn == null ? other.ssn != null : !this.ssn.equals(other.ssn)) return false; return true; &#125; @java.lang.Override public int hashCode() &#123; final int PRIME = 31; int result = 1; result = result * PRIME + (this.firstName == null ? 0 : this.firstName.hashCode()); result = result * PRIME + (this.lastName == null ? 0 : this.lastName.hashCode()); result = result * PRIME + (this.gender == null ? 0 : this.gender.hashCode()); result = result * PRIME + (this.dateOfBirth == null ? 0 : this.dateOfBirth.hashCode()); result = result * PRIME + (this.ssn == null ? 0 : this.ssn.hashCode()); return result; &#125;&#125; Keep in mind that this is not just code that normally has to be written, but must also be read by maintaining developers. This means that, when using the annotations provided by Project Lombok, developers do not have to wade through countless lines of code in order to determine if the class in question is a simple data class or something more sinister. LimitationsWhile Project Lombok does some dramatic things to make a developer’s life easier, it has its limitations. Browsing the issues list will quickly illuminate some of the current shortcomings, most of which are minor. One important problem is the inability to detect the constructors of a superclass. This means that if a superclass has no default constructor any subclasses cannot use the @Data annotation without explicitly writing a constructor to make use of the available superclass constructor. Since Project Lombok respects any methods that match the name of a method to be generated, the majority of its feature shortcomings can be overcome using this approach. ControversyA number of issues have been raised against the use of Project Lombok. The most common argument holds that annotations were intended for “meta” information and are not to be used in such a way that would leave the codebase unable to be compiled were they removed. This is certainly the situation with Lombok annotations. New methods result from these annotations that are intended to be used not only by a framework, but by other parts of the application. Project Lombok’s development-time support is its bread and butter, but this does have consequences, not the least of which is limited IDE support. As previously stated, @SneakyThrows is bound to stir up the age-old argument over checked and unchecked exceptions. Opinions on this debate are often almost religious in their ferocity. As such, the arguments against the use of @SneakyThrows are also sure to excite fervor among the passionate. Another point of contention is the implementation of both the code supporting IDE integration as well as the javac annotation processor. Both of these pieces of Project Lombok make use of non-public APIs to accomplish their sorcery. This means that there is a risk that Project Lombok will be broken with subsequent IDE or JDK releases. Here is how one of the project founders, Reinier Zwitserloot described the situation: 12345678910111213It&apos;s a total hack. Using non-public API. Presumptuous casting (knowing that anannotation processor running in javac will get an instance of JavacAnnotationProcessor,which is the internal implementation of AnnotationProcessor (an interface), whichso happens to have a couple of extra methods that are used to get at the live AST).On eclipse, it&apos;s arguably worse (and yet more robust) - a java agent is used to injectcode into the eclipse grammar and parser class, which is of course entirely non-publicAPI and totally off limits.If you could do what lombok does with standard API, I would have done it that way, butyou can&apos;t. Still, for what its worth, I developed the eclipse plugin for eclipse v3.5running on java 1.6, and without making any changes it worked on eclipse v3.4 runningon java 1.5 as well, so it&apos;s not completely fragile. SummaryProject Lombok is a powerful tool for the pragmatic developer. It provides a set of useful annotations for eliminating a tremendous amount of boilerplate code from your Java classes. In the best cases, a mere five characters can replace hundreds of lines of code. The result is Java classes that are clean, concise and easy to maintain. These benefits do come with a cost however. Using Project Lombok in an IntelliJ IDEA shop is simply not yet a viable option. There is a risk of breakage with IDE and JDK upgrades as well as controversy surrounding the goals and implementation of the project. What all this translates to is no different than what must be considered for any technology choice. There are always gains to be made and losses to be had. The question is simply whether or not Project Lombok can provide more value than cost for the project at hand. If nothing else, Project Lombok is sure to inject some new life into the discussion of language features that have withered on the vine thus far and that is a win from any perspective. References Project Lombok -http://projectlombok.org Lombok API Documentation -http://projectlombok.org/api/index.html Project Lombok Issues List -http://code.google.com/p/projectlombok/issues/list Use Lombok via Maven -http://projectlombok.org/mavenrepo/index.html Project Lombok Google Group -http://groups.google.com/group/project-lombok Reviewing Project Lombok or the Right Way to Write a Library -http://www.cforcoding.com/2009/11/reviewing-project-lombok-or-right-way.html Morbok: Extensions for Lombok -http://code.google.com/p/morbok Using Project Lombok with JDeveloper -http://kingsfleet.blogspot.com/2009/09/project-lombok-interesting-bean.html Example Code -LombokExample.zip Thanks to Mark Volkmann, Eric Burke, Mario Aquino and Lance Finney for reviewing and providing suggestions for this article, and a special thanks to Mark Volkmann for introducing me to Project Lombok. http://jnb.ociweb.com/jnb/jnbJan2010.html]]></content>
      <categories>
        <category>学习经验</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>开发知识</tag>
        <tag>IntelliJ IDEA</tag>
        <tag>Lombok插件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Idea Maven父子工程+多模块创建]]></title>
    <url>%2F2019%2F07%2F31%2FIdea-%E7%88%B6%E5%AD%90%E5%B7%A5%E7%A8%8B-%E5%A4%9A%E6%A8%A1%E5%9D%97%E5%88%9B%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[使用IDEA创建Maven聚合工程Zero. 工作空间我新建了一个名为Idea_SSM04_WebProject的文件夹，用于存放这个项目： 1. 创建一个Maven工程新建一个Maven工程，作为项目的父工程，可不勾选骨架，用于统一版本号。 将pom依赖导入 2. 创建子工程在上一步建好的工程上右键，新建Module，注意在后续选项中把add as Module改为None： 新工程名：WebShop-Common 修改路径为：E:\Idea_SSM04_WebProject\WebShop-Common （然后再创建第二个子工程，与上步骤一样。） 第二个子工程名：WebShop-SysManager 修改路径为：E:\Idea_SSM04_WebProject\WebShop-SysManager 3. 子工程之间的依赖使用dependency来指定依赖关系 如WebShop-SysManager的pom文件中增加： 12345678910&lt;artifactId&gt;WebShop-SysManager&lt;/artifactId&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.SH&lt;/groupId&gt; &lt;artifactId&gt;WebShop-Common&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 4. 创建模块接着在子工程里创建模块，直接在子工程右键新建Module即可。 新建模块路径默认即可： SysManager-Dao SysManager-Service SysManager-Pojo SysManager-Web 其中Web模块需要勾选webapp骨架，其他模块无需勾选骨架。 5. 运行Maven项目在含有webapp的工程pom里，这里是WebShop-SysManager，增加Tomcat7插件： 12345678910111213&lt;build&gt; &lt;!-- 配置插件 --&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;port&gt;8080&lt;/port&gt; &lt;path&gt;/&lt;/path&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 在右侧点击Maven，可查看当前项目的Maven详情： 在Add Configuration中点击加号，选Maven： 配置如下，名字随便起： 运行前，需要先把被依赖的工程install，接着install其他工程，install前请clean。webapp模块不需要安装，每次运行前最好都这样重复清理安装:]]></content>
      <categories>
        <category>学习经验</category>
      </categories>
      <tags>
        <tag>开发知识</tag>
        <tag>IntelliJ IDEA</tag>
        <tag>Maven聚合工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[改回来用Gitment评论系统]]></title>
    <url>%2F2019%2F07%2F29%2F%E6%94%B9%E5%9B%9E%E6%9D%A5%E7%94%A8Gitment%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[先前使用Gitment评论系统，由于作者证书失效，跨域服务不可用，改用了一段时间的Valine。Valine不需要登录，昵称和邮箱都是自定义的，身份只能靠浏览器、ip来识别。评论起来方便是方便，不过可读性不高，头像也比较单一。 相比起来，Gitment是使用Github账户登录的，身份唯一，在github互动也方便，可读性强。 今天偶然看到一篇文章，写得很详细，加上同样都是next主题（我比较懒，没怎么搞主题）可以傻瓜式操作，直接cv大法把js链接copy来了，感谢。 修改内容： 关闭valine,开启gitment,修改mint为false 路径 D:\HexoBlog\ShirtinyBlog\themes\next\_config.yml 123456789101112131415# Gitment# Introduction: https://github.com/imsun/gitmentgitment: enable: true mint: false # RECOMMEND, A mint on Gitment, to support count, language and proxy_gateway count: true # Show comments count in post meta area lazy: false # Comments lazy loading with a button cleanly: true # Hide 'Powered by ...' on footer, and more language: # Force language, or auto switch by theme github_user: Shirtiny # MUST HAVE, Your Github Username github_repo: Shirtiny.github.io # MUST HAVE, The name of the repo you use to store Gitment comments client_id: &#123;id（保密）&#125; # MUST HAVE, Github client id for the Gitment client_secret: &#123;密钥（保密）&#125; # EITHER this or proxy_gateway, Github access secret token for the Gitment proxy_gateway: # Address of api proxy, See: https://github.com/aimingoo/intersect redirect_protocol: # Protocol of redirect_uri with force_redirect_protocol when mint enabled 修改引入的CSS、Js的url 路径 D:\HexoBlog\ShirtinyBlog\themes\next\layout\_third-party\comments\gitment.swing 1234567891011121314151617&lt;!-- LOCAL: You can save these files to your site and update links --&gt;&#123;% if theme.gitment.mint %&#125; &#123;% set CommentsClass = 'Gitmint' %&#125; &lt;link rel="stylesheet" href="https://aimingoo.github.io/gitmint/style/default.css"&gt; &lt;script src="https://aimingoo.github.io/gitmint/dist/gitmint.browser.js"&gt;&lt;/script&gt;&#123;% else %&#125; &#123;% set CommentsClass = 'Gitment' %&#125; &lt;!--修改前 &lt;link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"&gt; --&gt; &lt;!-- &lt;script src="https://imsun.github.io/gitment/dist/gitment.browser.js"&gt;&lt;/script&gt; --&gt;&lt;!--改后 --&gt; &lt;link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/theme-next/theme-next-gitment@1/default.css"&gt; &lt;script src="https://cdn.jsdelivr.net/gh/theme-next/theme-next-gitment@1/gitment.browser.js"&gt;&lt;/script&gt; &#123;% endif %&#125;&lt;link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/theme-next/theme-next-gitment@1/default.css"/&gt;&lt;!-- END LOCAL --&gt; 也可使用： 12&lt;link rel="stylesheet" href="https://jjeejj.github.io/css/gitment.css"&gt;&lt;script src="https://jjeejj.github.io/js/gitment.js"&gt;&lt;/script&gt; 或 12&lt;link rel="stylesheet" href="https://jjeejj.github.io/css/gitment.css"&gt;&lt;script src="https://www.wenjunjiang.win/js/gitment.js"&gt;&lt;/script&gt; 我的Giment样式、js（最终修改） 12&lt;link rel="stylesheet" href="https://shirtiny.cn/css/myGitment.css"&gt;&lt;script src="https://shirtiny.cn/js/myGitment.js"&gt;&lt;/script&gt;]]></content>
      <categories>
        <category>系统维护</category>
      </categories>
      <tags>
        <tag>博客维护</tag>
        <tag>评论系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSM_SysManager_Security]]></title>
    <url>%2F2019%2F07%2F15%2FSSM-Security%2F</url>
    <content type="text"><![CDATA[SSM_后台数据管理+安全认证数据列表1. 商品表Product 变量名 类型 备注 id String 主键 productNum String 商品编号 productName String 商品名 cityName String 出发城市 departureTime Date 出发时间 departureTimeStr String 出发时间的字符串，不在数据库中 productPrice double 商品价格 productDesc String 商品描述 productStatus Integer 值0为关闭状态，值1为打开状态 productStatusStr String 商品状态的字符串，不在数据库中 1.1. Date与String之间的类型转换 赋值 Controller接收参数时，需要把用户输入的String类型的departureTime转为date类型，这里我设置了全局的类型转换器，由springMVC处理转换： 12345678910111213public class StringToDate implements Converter&lt;String, Date&gt; &#123; @Override public Date convert(String string) &#123; SimpleDateFormat sdf=new SimpleDateFormat("yyyy-MM-dd HH:mm"); Date date = null; try &#123; date = sdf.parse(string); &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; return date; &#125;&#125; springMVC配置： 12345678910111213141516171819&lt;!-- 配置类型转换器de固定步骤--&gt; &lt;!-- 01、 先将写好的转换器类放入IOC容器--&gt; &lt;bean id="SToDateConvertor" class="com.SH.Converters.StringToDate"&gt;&lt;/bean&gt; &lt;bean id="DToStringConvertor" class="com.SH.Converters.DateToString"&gt;&lt;/bean&gt; &lt;!-- 02、 再将自定义的转换器设置到springMVC中的转换器里 --&gt; &lt;!-- &lt;bean id="springConvertors" class="org.springframework.context.support.ConversionServiceFactoryBean"&gt;这是转换器的类--&gt; &lt;!-- 由于数据格式化的类是.format.support.FormattingConversionServiceFactoryBean包括了转换器的类，所以可以用格式化的类同时实现两个功能--&gt; &lt;bean id="springConvertors" class="org.springframework.format.support.FormattingConversionServiceFactoryBean"&gt; &lt;property name="converters" &gt; &lt;set&gt; &lt;ref bean="SToDateConvertor"/&gt; &lt;ref bean="xxx"/&gt; ... &lt;/set&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 03、 在&lt;mvc:annotation-driven&gt;里的conversion-service注册 02的bean --&gt; &lt;!-- 开启SpringMVC注解支持 --&gt; &lt;mvc:annotation-driven conversion-service="springConvertors"/&gt; 取值 输出时，可以使用事先定义的departureTimeStr，这样可以保持departureTime不变，需要对departureTimeStr赋值，在get方法中写： 1234567public String getDepartureTimeStr() &#123; if (departureTime!=null)&#123; String pattern="yyyy-MM-dd HH:mm"; departureTimeStr = DateAndString.DateToString(departureTime, pattern); &#125; return departureTimeStr; &#125; DateAndString是自定义的工具类，将date转为string，详情： 1234567public class DateAndString &#123; public static String DateToString(Date date,String pattern)&#123; SimpleDateFormat sdf=new SimpleDateFormat(pattern); return sdf.format(date); &#125;&#125; 注解方式 详情：@DateTimeFormat与@JsonFormat 2. 订单表Orders 变量名 类型 备注 id String 无意义，主键id orderNum String 订单编号 不为空 且唯一 orderTime Date 下单时间 orderTimeStr String 用于输出下单时间，不在数据库中 peopleCount int 出行人数 orderDesc String 订单备注和描述信息 payType int 支付方式（0支付宝，1微信，2其他） payTypeStr String 用于输出支付方式，不在数据库中 orderStatus int 订单的状态（0未支付 1已支付） orderStatusStr; String 用于输出下单状态，不在数据库中 productId int 产品的id，外键 memberid int 会员（联系人）id外键 travellers List 旅客 member Member 会员 2.1. 订单查询一个订单对应一个产品、一个会员（联系人）、多个旅客，使用注解方式查询数据时，使用@Results指定关系，一对一多对一使用@One指定方法，一对多多对多使用@Many指定方法 123456789101112131415//查询一个订单的具体信息@Select("select * from orders where id=#&#123;orderId&#125;") @Results(&#123; @Result(column = "id",property = "id",id = true), @Result(column = "orderNum",property = "orderNum"), @Result(property = "orderTime",column = "orderTime",javaType = Date.class,jdbcType =JdbcType.TIMESTAMP), @Result(property = "orderStatus",column = "orderStatus"), @Result(property = "peopleCount",column = "peopleCount"), @Result(property = "product",column = "productId",javaType = Product.class,one = @One(select = "com.SH.Dao.IproductDao.selectByid")), @Result(property = "travellers",column = "id",javaType = List.class,many = @Many(select = "com.SH.Dao.ItravellerDao.selectByid")), @Result(property = "member",column = "memberId",javaType = Member.class,one = @One(select = "com.SH.Dao.ImemberDao.selectById")), @Result(property = "payType",column = "payType"), @Result(property = "orderDesc",column = "orderDesc") &#125;) Orders selectById(String orderId) throws Exception; 3. 会员表Member 变量名 类型 备注 id String 无意义、主键id name String 姓名 nickName String 昵称 phoneNum String 电话号码 email String 邮箱 3.1. 单个会员查询：12@Select("select * from member where id=#&#123;id&#125;") Member selectById(String id); 4. 旅客表Traveller 变量名 类型 备注 id String 无意义、主键id name String 姓名 sex String 性别 phoneNum String 电话号码 credentialsType int 证件类型 0身份证 1护照 2军官证 credentialsTypeStr String 用于输出证件类型，不在数据库中 credentialsNum String 证件号码 travellerType int 旅客类型(人群) 0 成人 1 儿童 travellerTypeStr String 用于输出旅客类型，不在数据库中 5. 旅客与订单之间的多对多关系，order_traveller中间表 字段名 字段类型 字段描述 orderId varchar(32) 订单id，与对应表绑定外键 travellerId varchar(32) 旅客id，与对应表绑定外键 5.1. 根据指定订单号，多个旅客的查询：1234@Select("select * from traveller where id in( select travellerId from order_traveller where orderId=#&#123;orderId&#125; )") List&lt;Traveller&gt; selectByid(String orderId); 6. 用户表Users 变量名 类型 备注 id String 无意义，主键id email String 非空，唯一 username String 用户名 password String 密码（加密) phoneNum String 电话 status int 状态0 未开启 1 开启 roles List 角色集 6.1. 用户的查询：123456789101112//查询所有用户 @Select("select * from users") @Results(&#123; @Result(id = true,property = "id",column = "id"), @Result(property = "email",column = "email"), @Result(property = "username",column = "username"), @Result(property = "password",column = "password"), @Result(property = "phoneNum",column = "phoneNum"), @Result(property = "status",column = "status"), @Result(property = "roles",column = "id",javaType = List.class,many = @Many(select = "com.SH.Dao.IroleDao.selectByUserid")) &#125;) List&lt;UserInfo&gt; selectAllUser() throws Exception; 7. 角色表Role 变量名 类型 备注 id String 无意义，主键id roleName String 角色名 roleDesc String 角色描述 UserInfos List 用户集 permissions List 权限集 8. 用户与角色的多对多关系，user_role中间表 变量名 类型 备注 userId String 用户id,与用户id外键关联 roleId String 角色id，与角色id外键关联 8.1. 根据用户查询角色集合：123//根据用户id查询角色集 @Select("select * from role where id in(select roleId from user_role where userId=#&#123;userid&#125;)") List&lt;Role&gt; selectByUserid(String userid); 9. 权限表Permission 变量名 类型 备注 id String 无意义，主键id permissionName String 权限名 url String 资源路径 roles List 角色集 10. 角色与权限多对多关系，role_permission中间表 变量名 类型 备注 permissionId String 权限id，与权限id关联外键 roleId String 角色id，与角色id关联外键 Spring Security安全框架Spring Security是一种基于 Spring AOP 和 Servlet 过滤器的安全框架,它提供全面的安全性解决方案，同时在 Web 请求级和方法调用级处理认证和授权。 1.Pom依赖12345678910111213141516171819202122232425&lt;properties&gt; &lt;spring.security.version&gt;5.0.1.RELEASE&lt;/spring.security.version&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.security.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-config&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.security.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-core&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.security.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-taglibs&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.security.version&#125;&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 2. spring-Security.xml配置文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:security="http://www.springframework.org/schema/security" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/security http://www.springframework.org/schema/security/spring-security.xsd"&gt;&lt;!-- 不拦截的资源--&gt; &lt;security:http pattern="/css/**" security="none"/&gt; &lt;security:http pattern="/img/**" security="none"/&gt; &lt;security:http pattern="/plugins/**" security="none"/&gt; &lt;security:http pattern="/page/login.jsp" security="none"/&gt; &lt;security:http pattern="/page/fail.jsp" security="none"/&gt; &lt;!-- 配置具体的规则 auto-config="true" 不用自己编写登录的页面，框架提供默认登录页面 use-expressions="false" 是否使用SPEL表达式 --&gt; &lt;security:http auto-config="true" use-expressions="false"&gt; &lt;!-- 配置具体的拦截的规则, 限制用户添加页面的访问角色 ，小范围在前，大范围在后 --&gt; &lt;security:intercept-url pattern="/page/user-add.jsp" access="ROLE_GM"/&gt; &lt;!-- pattern="请求路径的规则" access="访问系统的人，必须有USER或GM的角色，ROLE_ 是框架需要的前缀" --&gt; &lt;security:intercept-url pattern="/**" access="ROLE_USER,ROLE_GM"/&gt; &lt;!-- 设置跳转的页面 --&gt; &lt;security:form-login login-page="/page/login.jsp" login-processing-url="/login.action" default-target-url="/page/main.jsp" authentication-failure-url="/page/fail.jsp" authentication-success-forward-url="/page/main.jsp" username-parameter="username" password-parameter="password" /&gt; &lt;!-- 关闭跨域请求，csrf主要是为了防止攻击 --&gt; &lt;security:csrf disabled="true"/&gt; &lt;!-- 用户注销，退出 --&gt; &lt;security:logout invalidate-session="true" logout-url="/logout.action" logout-success-url="/page/login.jsp" /&gt; &lt;/security:http&gt; &lt;!-- 切换成数据库中的用户名和密码 --&gt; &lt;security:authentication-manager&gt; &lt;!--配置userService类，它实现了继承了UserDetailsService的IuserService接口，重写了loadUserByUsername(String username)方法，返回一个UserDetails类对象，使用security提供的User对象封装数据库查询到的userinfo信息 --&gt; &lt;security:authentication-provider user-service-ref="userService"&gt; &lt;!-- 配置加密的方式，引用上面配置的加密类，指定密码被加密的方式，框架才能识别，以便找到合适的密码验证方式，不然会报There is no PasswordEncoder mapped for the id "null", 注意！若在xml中配置了加密类，&#123;id&#125;(密码前加&#123;noop&#125;、&#123;bcrypt&#125;等)将不可用，框架会直接使用指定加密类匹配字符串，不会再判断字符串加密类型 --&gt;&lt;!-- &lt;security:password-encoder ref="passwordEncoder"/&gt;--&gt; &lt;/security:authentication-provider&gt;&lt;/security:authentication-manager&gt; &lt;!-- 配置加密类，存储密码明文的加盐哈希 hash(m+salt)，不可逆加密，验证时匹配哈希值,注意，此项放在 &lt;security:authentication-manager&gt;前会在密码验证时影响&#123;id&#125;是否使用--&gt; &lt;bean id="passwordEncoder" class="org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder"/&gt; &lt;!-- 提供了入门的方式，在内存中存入用户名和密码 --&gt;&lt;!-- &lt;security:authentication-manager&gt;--&gt;&lt;!-- &lt;security:authentication-provider&gt;--&gt;&lt;!-- &lt;security:user-service&gt;--&gt;&lt;!-- &lt;security:user name="sh" password="&#123;noop&#125;123" authorities="ROLE_USER"/&gt;--&gt;&lt;!-- &lt;/security:user-service&gt;--&gt;&lt;!-- &lt;/security:authentication-provider&gt;--&gt;&lt;!-- &lt;/security:authentication-manager&gt;--&gt;&lt;/beans&gt; 3. Web.xml配置文件1234567891011121314151617181920212223&lt;!--监听器 --&gt;&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt;&lt;!--指定spring配置文件与security配置文件的位置 --&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:ApplicationContext.xml,classpath:spring- Security.xml&lt;/param-value&gt; &lt;/context-param&gt;&lt;!-- 过滤器,filter-name值必须为springSecurityFilterChain--&gt; &lt;filter&gt; &lt;filter-name&gt;springSecurityFilterChain&lt;/filter-name&gt; &lt;filter-class&gt; org.springframework.web.filter.DelegatingFilterProxy &lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;springSecurityFilterChain&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 4. 密码加密流程由于用户注册时，数据库中的用户密码需要加密保存，以保护用户信息安全。Spring Security提供的加密方式里，有一种为BCryptPasswordEncoder类，使用BCrypt强哈希方法来加密密码。这是种加盐哈希方式，每次加密产生的密文都不同，密码验证时通过匹配hash值来进行认证，可以抵御彩虹表，提高破解难度。 使用时，只需在接收用户信息后，调用BCryptPasswordEncoder对象的encode方法，对用户密码进行加密，然后将加密后的用户信息放入数据库即可,由于加密后数据比较长，注意数据库字符长度。如： 12345678910111213141516171819202122232425262728@Service("userService")@Transactionalpublic class userServiceImpl implements IuserService &#123; @Autowired private IuserDao userDao; @Autowired private BCryptPasswordEncoder passwordEncoder; @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123;...&#125;//添加用户，加密测试 @Override public void addUser(UserInfo userInfo) throws Exception &#123; //获取用户密码 String password=userInfo.getPassword(); //加密密码 String encode = passwordEncoder.encode(password); //修改用户密码 userInfo.setPassword(encode); //打印，以查看加密结果 System.out.println(encode); //插入数据库 userDao.insertOne(userInfo); &#125; 5. 登录认证流程5.1. 创建UserInfo类，用来封装数据库返回的用户信息1234567891011121314public class UserInfo &#123; private String id; private String email; private String username; private String password; private String phoneNum; private int status; private String statusStr; private List&lt;Role&gt; roles; .... //省略setter、getter、构造器 &#125; 5.2. Dao层查询出用户信息123456789101112//按照用户名查找单个用户，验证登录 @Select("select * from users where username=#&#123;username&#125;") @Results(&#123; @Result(id = true,property = "id",column = "id"), @Result(property = "email",column = "email"), @Result(property = "username",column = "username"), @Result(property = "password",column = "password"), @Result(property = "phoneNum",column = "phoneNum"), @Result(property = "status",column = "status"), @Result(property = "roles",column = "id",javaType = List.class,many = @Many(select = "com.SH.Dao.IroleDao.selectByUserid")) &#125;) UserInfo selectUserByName(String username); 5.3. 创建IuserService接口，继承UserDetailsService接口123public interface IuserService extends UserDetailsService &#123;&#125; 5.4. 创建userServiceImpl类，实现IuserService接口12345678910111213141516171819202122232425262728293031323334353637383940//放入IOC容器，取名为userService，供xml中配置@Service("userService")//事务管理@Transactionalpublic class userServiceImpl implements IuserService &#123; @Autowired private IuserDao userDao; //重写loadUserByUsername方法 @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123; //查询出对应用户信息 UserInfo userInfo = userDao.selectUserByName(username); //获取用户的角色集合 List&lt;Role&gt; roles = userInfo.getRoles(); //遍历权限并放入SimpleGrantedAuthority集合 SimpleGrantedAuthority authority; List&lt;SimpleGrantedAuthority&gt; authorities = new ArrayList&lt;&gt;(); for (Role role : roles) &#123; String roleName = role.getRoleName(); authority = new SimpleGrantedAuthority("ROLE_" + roleName); authorities.add(authority); &#125; //获取用户密码 String uPwd = userInfo.getPassword(); //使用Security提供的User类，至少需要用户名、密码、权限 User user; if (uPwd.length() &lt;= 50) &#123;//判断密码长度，以区分是否是加密的密码，因为加密后的密码比较长 //此时密码未进行加密，所以要加"&#123;noop&#125;"前缀，让框架识别 user = new User(userInfo.getUsername(), "&#123;noop&#125;" + uPwd, authorities); &#125; else &#123; //此时密码已经加密(正常情况下密码用户的密码应该不会大于50吧)，加"&#123;bcrypt&#125;"前缀，因为加密方式为bcrypt，让框架识别 user = new User(userInfo.getUsername(), "&#123;bcrypt&#125;" + uPwd, authorities); //若在xml中配置了加密方式，&#123;id&#125;就会失效，只使用配置的加密方式匹配密码，加密类的bean也不能靠前 &#125; //直接返回User类对象，因为User类实现了UserDetails return user; &#125; tips： 5.4.1. 关于”{noop}”前缀在spring5.0之后，springsecurity存储密码的格式发生了改变，新的密码存储格式为：加密方式和加密后的密码，{id}encodedPassword 1234567891011//均为字符串&#123;noop&#125;password//无加密，明文密码，前缀使用&#123;noop&#125;让框架识别，noop是no operate的意思 //各种加密方式的前缀，和对应的密文样式&#123;bcrypt&#125;$2a$10$dXJ3SW6G7P50lGmMkkmwe.20cQQubK3.HZWzG3YB1tlRy.fqvM/BG //BCryptPasswordEncoder类加密&#123;pbkdf2&#125;5d923b44a6d129f3ddf3e3c8d29412723dcbde72445e8ef6bf3b508fbf17fa4ed4d6b99ca763d8dc &#123;scrypt&#125;$e0801$8bWJaSu2IKSn9Z9kM+TPXfOc/9bdYSrN1oD9qfVThWEwdRTnO7re7Ei+fUZRJ68k9lTyuTeUp4of4g24hHnazw==$OAOec05+bXxvuu/1qZ6NUR+xQYvYv7BeL1QxwRpY5Pc= &#123;sha256&#125;97cde38028ad898ebc02e690819fa220e88c62e0699403e94fff291cfffaf8410849f27605abcbc0 5.4.2. 关于框架提供的User类Security的User类，提供了两个构造方法： 12345678910111213141516171819202122232425262728//Security提供的User类public class User implements UserDetails, CredentialsContainer &#123; private static final long serialVersionUID = 500L; private String password; private final String username; private final Set&lt;GrantedAuthority&gt; authorities; private final boolean accountNonExpired; private final boolean accountNonLocked; private final boolean credentialsNonExpired; private final boolean enabled; public User(String username, String password, Collection&lt;? extends GrantedAuthority&gt; authorities) &#123; this(username, password, true, true, true, true, authorities); &#125; public User(String username, String password, boolean enabled, boolean accountNonExpired, boolean credentialsNonExpired, boolean accountNonLocked, Collection&lt;? extends GrantedAuthority&gt; authorities) &#123; if (username != null &amp;&amp; !"".equals(username) &amp;&amp; password != null) &#123; this.username = username; this.password = password; this.enabled = enabled; this.accountNonExpired = accountNonExpired; this.credentialsNonExpired = credentialsNonExpired; this.accountNonLocked = accountNonLocked; this.authorities = Collections.unmodifiableSet(sortAuthorities(authorities)); &#125; else &#123; throw new IllegalArgumentException("Cannot pass null or empty values to constructor"); &#125; &#125; 三参构造（用户名，密码，权限集合 ），如： 1user = new User(userInfo.getUsername(), "&#123;bcrypt&#125;" + uPwd, authorities); 七參构造（用户名，密码，是否启用，账号是否过期，认证信息是否过期，是否被锁定，权限集合），如： 12User user = new User(userInfo.getUsername(), "&#123;bcrypt&#125;" + userInfo.getPassword(),userInfo.getStatus() == 0 ? false : true, true, true, true, authoritys); 5.5. 在Security的xml文件配置userService即可1234567 &lt;security:authentication-manager&gt; &lt;!--配置userService类，它实现了继承了UserDetailsService的IuserService接口，重写了loadUserByUsername(String username)方法，返回一个UserDetails类对象，使用security提供的User对象封装数据库查询到的userinfo信息 --&gt; &lt;security:authentication-provider user-service-ref="userService"&gt; &lt;/security:authentication-provider&gt;&lt;/security:authentication-manager&gt; 6. 注解方式的权限控制注解都默认关闭,使用前均需开启，在Spring-Security.xml中配置: 123&lt;!-- 启用注解,用于进行权限控制--&gt;&lt;!-- 开启JSR250注解、secured注解,支持spel表达式的注解--&gt;&lt;security:global-method-security jsr250-annotations="enabled" secured-annotations="enabled" pre-post-annotations="enabled"/&gt; 6.1. JSR250注解依赖、jar包: 12345&lt;dependency&gt; &lt;groupId&gt;javax.annotation&lt;/groupId&gt; &lt;artifactId&gt;jsr250-api&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt;&lt;/dependency&gt; @RolesAllowed注解，指定类、或方法需要的角色，无需加ROLE_前缀，使用： 1234567891011121314151617181920212223242526272829303132@Controller@RequestMapping(value = "/userController")//指定类内方法都默认需要GM的身份@RolesAllowed("GM")public class userController &#123; @Autowired private IuserService userService; //添加用户@RequestMapping(value = "/addUser") public String addUser(UserInfo userInfo) throws Exception &#123; userService.addUser(userInfo); return "redirect:/userController/findAll.action"; &#125; //查询所有用户 @RequestMapping(value = "/findAll") //指定此方法GM和USER都可以访问 @RolesAllowed(&#123;"GM","USER"&#125;) public ModelAndView findAllUser() throws Exception &#123; List&lt;UserInfo&gt; users = userService.selectAllUser(); ModelAndView mv=new ModelAndView(); mv.addObject("userList",users); mv.setViewName("user-list"); return mv; &#125;&#125; @PermitAll注解，表示允许所有的角色进行访问，也就是说不进行权限控制 @DenyAll注解，是和PermitAll相反的，表示无论什么角色都不能访问 6.2. @Secured注解此注解为Spring Security自带注解,用法与@RolesAllowed大致相同，不过角色要加ROLE_前缀,如: 123456789101112131415161718192021222324252627282930@Controller@RequestMapping(value = "/userController")//指定类内方法都默认需要GM的身份@Secured("ROLE_GM")public class userController &#123; @Autowired private IuserService userService; //添加用户@RequestMapping(value = "/addUser") public String addUser(UserInfo userInfo) throws Exception &#123; userService.addUser(userInfo); return "redirect:/userController/findAll.action"; &#125; //查询所有用户 @RequestMapping(value = "/findAll") //指定此方法GM和USER都可以访问 @Secured(&#123;"ROLE_USER","ROLE_GM"&#125;) public ModelAndView findAllUser() throws Exception &#123; List&lt;UserInfo&gt; users = userService.selectAllUser(); ModelAndView mv=new ModelAndView(); mv.addObject("userList",users); mv.setViewName("user-list"); return mv; &#125;&#125; 6.3. 支持SPEL表达式的注解常用的权限表达式： 表达式 说明 permitAll 永远返回true denyAll 永远返回false anonymous 当前用户是anonymous时返回true rememberMe 当前用户是rememberMe用户时返回true authenticated 当前用户不是anonymous时返回true fullAuthenticated 当前用户既不是anonymous也不是rememberMe用户时返回true hasRole（role） 用户拥有指定的角色权限时返回true hasAnyRole（[role1，role2]） 用户拥有任意一个指定的角色权限时返回true hasAuthority（authority） 用户拥有指定的权限时返回true hasAnyAuthority（[authority1,authority2]） 用户拥有任意一个指定的权限时返回true hasIpAddress（’192.168.1.0’） 请求发送的Ip匹配时返回true @PreAuthorize注解， 在方法调用之前,基于表达式的计算结果来限制对方法的访问如： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950@Controller@RequestMapping(value = "/userController")/*指定类内方法都默认需要GM的身份* @PreAuthorize("hasRole('ROLE_GM')") * 或 * @PreAuthorize("hasAuthority('ROLE_GM')") */public class userController &#123; @Autowired private IuserService userService; //添加用户@RequestMapping(value = "/addUser") public String addUser(UserInfo userInfo) throws Exception &#123; userService.addUser(userInfo); return "redirect:/userController/findAll.action"; &#125; //查询所有用户 @RequestMapping(value = "/findAll")/* * 指定此方法GM和USER都可以访问* @PreAuthorize("hasAnyRole('ROLE_GM','ROLE_USER')")* 或 * @PreAuthorize("hasAnyAuthority('ROLE_GM','ROLE_USER')")**/ public ModelAndView findAllUser() throws Exception &#123; List&lt;UserInfo&gt; users = userService.selectAllUser(); ModelAndView mv=new ModelAndView(); mv.addObject("userList",users); mv.setViewName("user-list"); return mv; &#125; //修改密码（测试） @RequestMapping(value = "/changeP") //取方法形参中的username，如果传入参数的值与登录用户的值相同，或者拥有GM权限，便可访问 @PreAuthorize("#username == authentication.principal.username or hasAuthority('ROLE_GM')") public String changeP(@P("username") String username) throws Exception&#123; return "ok"; &#125;&#125; @PostAuthorize 注解，允许方法调用,但是如果表达式计算结果为false,将抛出一个安全性异常示例： 123@PostAuthorizeUser getUser("returnObject.userId == authentication.principal.userId orhasPermission(returnObject, 'ADMIN')"); @PostFilter 注解，允许方法调用,但必须按照表达式来过滤方法的结果@PreFilter 注解，允许方法调用,但必须在进入方法之前过滤输入值 7. 权限控制标签依赖、jar（已有）： 1234567891011&lt;properties&gt; &lt;spring.security.version&gt;5.0.1.RELEASE&lt;/spring.security.version&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-taglibs&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.security.version&#125;&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; jsp页面引入taglib: 1&lt;%@taglib prefix="security" uri="http://www.springframework.org/security/tags" %&gt; 常用标签: authentication 允许访问当前的Authentication对象，获得属性的值，用来取值和获取对象。 1&lt;security:authentication property="" htmlEscape="" scope="" var=""/&gt; property： 只允许指定Authentication所拥有的属性，可以进行属性的级联获取 如“principle.username”，不允许直接通过方法进行调用 htmlEscape：表示是否需要将html进行转义。默认为true。 scope：与var属性一起使用，用于指定存放获取的结果的属性名的作用范围，默认我pageContext。Jsp中拥有的作用范围都进行进行指定 var： 用于指定一个属性名，这样当获取到了authentication的相关信息后会将其以var指定的属性名进行存放，默认是存放在pageConext中 实例： 1234567891011121314151617&lt;%@ page contentType="text/html;charset=UTF-8" language="java" isELIgnored="false" %&gt;&lt;%@ taglib prefix="security" uri="http://www.springframework.org/security/tags" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;用户属性&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;%--将用户对象在session中命名为user--%&gt;&lt;security:authentication property="principal" var="user" scope="session"/&gt; &lt;p&gt;$&#123;user&#125;&lt;/p&gt; &lt;p&gt;$&#123;user.username&#125;&lt;/p&gt; &lt;%--或直接输出值--%&gt;&lt;security:authentication property="principal.username"/&gt;&lt;/body&gt;&lt;/html&gt; 当然，你可以在你的MVC控制器中访问Authentication对象 （通过调用SecurityContextHolder.getContext().getAuthentication()） 然后直接在模型中添加数据，来渲染视图: 1234// Authentication authentication = SecurityContextHolder.getContext().getAuthentication();//User principal = (User)authentication.getPrincipal();//principal.getUsername(); authorize authorize是用来判断普通权限的，通过判断用户是否具有对应的权限而控制其所包含内容的显示。 1&lt;security:authorize access="" method="" url="" var=""&gt;&lt;/security:authorize&gt; access： 需要使用表达式来判断权限，当表达式的返回结果为true时表示拥有对应的权限 method：是配合url属性一起使用的，表示用户应当具有指定url指定method访问的权限，method的默认值为GET，可选值为http请求的7种方法 url：表示如果用户拥有访问指定url的权限即表示可以显示authorize标签包含的内容 var：用于指定将权限鉴定的结果存放在pageContext的哪个属性中 accesscontrollist accesscontrollist标签是用于鉴定ACL权限的。其一共定义了三个属性：hasPermission、domainObject和var，其中前两个是必须指定的。 1&lt;security:accesscontrollist hasPermission="" domainObject="" var=""&gt;&lt;/security:accesscontrollist&gt; hasPermission：用于指定以逗号分隔的权限列表 domainObject：用于指定对应的域对象 var：则是用以将鉴定的结果以指定的属性名存入pageContext中，以供同一页面的其它地方使用 操作日志记录每个用户的操作详情，方便管理和监控。这里使用Spring AOP的前置通知、后置通知，来控制日志的生成。 1. 日志表sysLog1.1. 数据库表 字段名称 字段类型 字段描述 id VARCHAR 无意义，完成时间的字符串 visitTime timestamp 访问时间 username VARCHAR 操作者用户名 ip VARCHAR 访问ip url VARCHAR 访问资源url executionTime int 执行时长 method VARCHAR 访问方法 1.1.1. 插入日志12@Insert("insert into syslog(id,visitTime,username,ip,url,executionTime,method) values(#&#123;id&#125;,#&#123;visitTime&#125;,#&#123;username&#125;,#&#123;ip&#125;,#&#123;url&#125;,#&#123;executionTime&#125;,#&#123;method&#125;)") boolean insertOne(SysLog sysLog); 1.1.2. 查询日志12345678910111213@Select("select * from syslog") @Results(&#123; @Result(id = true,property = "id",column = "id"), @Result(property = "visitTime",column = "visitTime",javaType = Date.class,jdbcType = JdbcType.TIMESTAMP), @Result(property = "username",column = "username"), @Result(property = "ip",column = "ip"), @Result(property = "url",column = "url"), @Result(property = "executionTime",column = "executionTime",javaType = long.class,jdbcType = JdbcType.INTEGER), @Result(property = "method",column = "method") &#125;) List&lt;SysLog&gt; selectAll() throws Exception; 1.2. 实体类123456789101112public class SysLog &#123;private String id;private Date visitTime;private String visitTimeStr;private String username;private String ip;private String url;private Long executionTime;private String method; //setter&amp;getter｝ 1.3. AOP生成数据开启spring-MVC对AOP的注解支持 123456&lt;!-- 支持AOP的注解支持，AOP底层使用代理技术 JDK动态代理，要求必须有接口 cglib代理，生成子类对象，proxy-target-class="true" 默认使用cglib的方式--&gt;&lt;aop:aspectj-autoproxy proxy-target-class="true"/&gt; 创建sysLogAOP类，使用aop的前置通知、后置通知，生成需要的数据，详细如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148package com.SH.AOP;import ...@Component@Aspectpublic class sysLogAOP &#123; @Autowired private HttpServletRequest request; @Autowired private IsysLogService sysLogService; private Class aClass; private Method method; private Date visitTime; private String visitTimeStr=""; private String ip=""; private String url=""; private String username=""; /* * 前置通知 * 生成访问方法时的时间 *获取操作者的信息 *获取ip *获取访问方法的类、类名、方法、方法名 *利用方法、类获取requestMapping的valueof[0]，拼接成url * 单个方法作为切入点 * @Before("execution(public String com.SH.Controller.productController.findAll(java.util.Map&lt;java.lang.String,java.lang.Object&gt;))") * */// 全部类型的 com.SH.Controller包下 全部类的全部方法 @Before("execution(* com.SH.Controller.*.*(..))")//前置通知 public void BeforeAd(JoinPoint joinPoint) throws NoSuchMethodException,SecurityException &#123;//异常由Class对象中的getMethod方法产生 //当前访问时间 visitTime = new Date(); //转为年-月-日 时:分:秒字符串 visitTimeStr = DateAndString.DateToString(visitTime, "yyyy-MM-dd HH:mm:ss"); //获取操作者信息 SecurityContext context = SecurityContextHolder.getContext(); User user = (User) context.getAuthentication().getPrincipal(); username = user.getUsername();//用户名 Collection&lt;GrantedAuthority&gt; authorities = user.getAuthorities();//角色 //获取操作者IP地址 ip = request.getRemoteAddr(); //获取访问的类和方法，拼接成url //获取切入对象的类 aClass = joinPoint.getTarget().getClass(); //★获取方法 //1. 获取切入对象（方法）的名字 String methodName=joinPoint.getSignature().getName(); //2. 获得方法的参数 Object[] args = joinPoint.getArgs(); //3. 判断要获取的方法是否有参数 if (args==null||args.length==0)//没有参数 &#123; //通过方法名获取方法//无参方法获取 method = aClass.getMethod(methodName); &#125;else &#123;//有参数 //创建一个argsClass数组 Class[] argsClass=new Class[args.length]; //循环，获取args数组里每个参数的类，并且装入argsClass数组 for (int i=0;i&lt;args.length;i++)&#123; argsClass[i]= args[i].getClass(); &#125; //通过方法名+参数类型获取方法//有参方法获取 method= aClass.getMethod(methodName,argsClass);//有的方法，参数是基本数据类型如int，方法内int参数换成Integer包装类 &#125; //拼接url String classURL="";//类路径 String methodURL="";//类后方法路径// class和method都拿到后，就可以拿到requestMapping注解里的值 if (aClass!=null&amp;&amp;method!=null&amp;&amp;aClass!=sysLogAOP.class)&#123;//防止空指针，并且class不为自身（？看有人这么写）//获取类和方法的RequestMapping对象 RequestMapping classAnnotation =(RequestMapping) aClass.getAnnotation(RequestMapping.class); RequestMapping methodAnnotation =(RequestMapping) method.getAnnotation(RequestMapping.class); if (classAnnotation!=null)&#123; classURL=classAnnotation.value()[0]; &#125; if (methodAnnotation!=null)&#123; methodURL=methodAnnotation.value()[0]; &#125;//.value()值为数组 url=classURL+methodURL; &#125; //打印输出，方便测试 System.out.println("访问时间"+ visitTimeStr); System.out.println("用户："+username+"；身份："+authorities+"IP地址："+ip); System.out.println("访问的类"+aClass+"；方法"+methodName+"\n；URL："+url); System.out.println("传递参数值："+ Arrays.toString(args)); &#125; /* * 后置通知 * 生成方法的完成时间 * 计算耗时 * 封装日志数据 * 调用service处理 * */ @After("execution(* com.SH.Controller.*.*(..))") public void AfterAd() throws Exception&#123; //记录方法完成的时间 Date completeTime=new Date(); //转换成指定格式字符串 String completeTimeStr =DateAndString.DateToString(completeTime,"yyyy-MM-dd HH:mm:ss"); //计算耗时 Long usedTime=completeTime.getTime()-visitTime.getTime(); //封装数据 SysLog sysLog=new SysLog(); sysLog.setId(completeTimeStr); sysLog.setVisitTime(visitTime); sysLog.setVisitTimeStr(visitTimeStr); sysLog.setUsername(username); sysLog.setIp(ip); sysLog.setUrl(url); sysLog.setExecutionTime(usedTime); sysLog.setMethod(method.getName()); //存入数据库 boolean flag = sysLogService.insertOne(sysLog); //打印输出，方便测试 System.out.println("完成时间："+completeTimeStr+"；耗时："+usedTime+"毫秒"); System.out.println("封装日志："+sysLog); System.out.println("将日志，存入数据库结果："+flag); &#125;&#125; tips： 1.3.1. 关于获取IPspring提供了一个RequestContextListener，可以在spring中直接使用（先注入）HttpServletRequest对象。在web.xml中配置监听器： 123456&lt;!-- 为spring提供 request对象,监听器--&gt;&lt;listener&gt; &lt;listener-class&gt; org.springframework.web.context.request.RequestContextListener &lt;/listener-class&gt;&lt;/listener&gt; 1.3.2. 关于获取用户信息可以通过SecurityContextHolder.getContext()获取sercurity上下文对象，从而可以getAuthentication().getPrincipal()获得用户对象，这个上文在权限控制标签中说过。 12SecurityContext context = SecurityContextHolder.getContext();//获取Security上下文对象User user = (User) context.getAuthentication().getPrincipal();//获取用户对象 创建sysLogAOP类，使用aop的前置通知、后置通知，详细如下： 1.3.3. 关于获取URL这里的url是拼接Controller类&amp;方法的@RequestMapping值得到的。 首先需要获取类、方法。 类使用JoinPoint获取： 1234//获取对象的类aClass = joinPoint.getTarget().getClass();//或dClass = joinPoint.getSignature().getDeclaringType(); 至于方法，因为将调用的Class对象的getMethod方法为： 12345678910@CallerSensitive public Method getMethod(String name, Class&lt;?&gt;... parameterTypes) throws NoSuchMethodException, SecurityException &#123; checkMemberAccess(Member.PUBLIC, Reflection.getCallerClass(), true); Method method = getMethod0(name, parameterTypes, true); if (method == null) &#123; throw new NoSuchMethodException(getName() + "." + name + argumentTypesToString(parameterTypes)); &#125; return method; &#125; 所以要按有无参数分开获取： 先使用JoinPoint得到方法名和方法的参数： 1234//1. 获取切入对象（方法）的名字String methodName=joinPoint.getSignature().getName();//2. 获得方法的参数（一个Object数组）Object[] args = joinPoint.getArgs(); 通过判断参数是否为空，来确认方法是否有參。 若无参数： 12345//3. 判断要获取的方法是否有参数 if (args==null||args.length==0)//没有参数 &#123; //通过方法名获取方法//无参方法获取 method = aClass.getMethod(methodName); 若有参数： 123456789101112&#125;else &#123;//有参数 //创建一个argsClass数组 Class[] argsClass=new Class[args.length]; //循环，获取args数组里每个参数的类，并且装入argsClass数组 for (int i=0;i&lt;args.length;i++)&#123; argsClass[i]= args[i].getClass();//这里会将int等基础数据类型获取成Integer包装类型// System.out.println("参数："+args[i]); &#125; //通过方法名+参数类型获取方法//有参方法获取 method= aClass.getMethod(methodName,argsClass);//有的方法，参数是基本数据类型如int，需要将方法内int参数换成Integer包装类,也就Controller层形参都使用Inter类型 &#125; 此处参数类型问题的详情： 这里参数获取类型（arg.getClass()），会把基本数据类型（如int等）获取成包装类型（如Integer等），而实际上是基本数据类型，这会使class.getMethod(String name, Class&lt;?&gt;... parameterTypes)执行时找不到匹配的方法对象，报NoSuchMethodException异常，以及后续的空指针异常。因为获取时便是Integer，使用isPrimitive()（确认是否为基本数据类型）的结果始终为false，目前我并未找到完美的解决方法。 临时的解决方式： ①让Controller内方法的参数类型只使用Integer等包装类，不能使用int等基本数据类型。直接把Controller内的int、char等类型改成Integer、Char就行了，不再用代码举例了。 ②创建一个HashMap用来存放包装类型与基本类型的&lt;K、V&gt;对，将获取的包装类型转换为基本类型。这样做就会使Controller类内方法的参数类型只能用int等基本数据类型，不能使用Integer等包装类型。当然，其他类型是不影响的。详细代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364@Component@Aspectpublic class sysLogAOP &#123; //创建一个HashMap，存放包装类与基本类型的KV对，用来将包装类型转为基本数据类型private static HashMap&lt;String, Class&gt; map = new HashMap&lt;String, Class&gt;() &#123; &#123; put("java.lang.Integer", int.class); put("java.lang.Double", double.class); put("java.lang.Float", float.class); put("java.lang.Long", long.class); put("java.lang.Short", short.class); put("java.lang.Boolean", boolean.class); put("java.lang.Char", char.class); &#125; &#125;; //获取切入对象的类 aClass = joinPoint.getTarget().getClass(); //★获取方法 String methodName=joinPoint.getSignature().getName();//1. 获取切入对象（方法）的名字 Object[] args = joinPoint.getArgs();//2. 获得方法的参数 //3. 判断要获取的方法是否有参数 Class[] argsClass=null;//参数类型数组 if (args==null||args.length==0)//没有参数 &#123; //通过方法名获取方法//无参方法获取 method = aClass.getMethod(methodName);//获取指定的方法，第二个参数可以不传 &#125;else &#123;//有参数 argsClass=new Class[args.length];//创建一个argsClass数组,长度与参数数组相同 for (int i=0;i&lt;args.length;i++)&#123;//循环 argsClass[i]= args[i].getClass();//获取args数组里每个参数的类，并且装入argsClass数组 //打印，以供观察 System.out.println("遍历出的参数的类名为："+args[i].getClass().getName()); if (map.get(args[i].getClass().getName())!=null)&#123;//能根据参数的类名在自定义的hashMap中找到对应的基本类型 argsClass[i]=map.get(args[i].getClass().getName());//则放入class数组,覆盖掉之前的class数组值，此时通过map将参数类型转为了基本数据类型 //打印，以供观察 System.out.println("参数类型转换为："+argsClass[i]); &#125;else &#123;//如果根据参数的类名在自定义的map集合中取不到值，则说明参数是其他类型 //打印，以供观察 System.out.println("参数是其他类型，或者是基本类型，保持class不变"); &#125; &#125; //打印出最终参数类型 System.out.println("最终参数类型："+ Arrays.toString(argsClass)); //通过方法名+参数类型获取方法//有参方法获取 method= aClass.getMethod(methodName,argsClass);//此时Controller类内方法参数类型就不能为包装类型了，只能用int、char等基本数据类型 &#125; 补充：还有个同样的问题，它有时还会把其他类型的参数获取成特定类型，如java.util.Map会获取成org.springframework.validation.support.BindingAwareModelMap。我将Controller类内方法的Map类型替换为BindingAwareModelMap类型，暂时避免异常。 BindingAwareModelMap类的信息如图所示，目前使用中尚未出现其他问题。 获取类和方法后，就可获取需要的注解（需要转换），这里是@RequestMapping注解 12RequestMapping classAnnotation =(RequestMapping) aClass.getAnnotation(RequestMapping.class);//类的RequestMapping注解 RequestMapping methodAnnotation =(RequestMapping) method.getAnnotation(RequestMapping.class);//方法的RequestMapping注解 当然前提是类和方法不为null 1if (aClass!=null&amp;&amp;method!=null) 然后就可以通过获得的RequestMapping对象，获得需要的属性。 注意： 虽然是Controller类，但类和方法不能保证都一定有@RequestMapping注解，并且value属性是数组 123456if (classAnnotation!=null)&#123; classURL=classAnnotation.value()[0]; &#125; if (methodAnnotation!=null)&#123; methodURL=methodAnnotation.value()[0]; &#125; 将两个RequestMapping的value值拼接起来，就拿到一个Controller-方法的URL了 1String URL=classURL+methodURL; 1.3.4. 关于获取参数值和参数名先获取参数 12//获得方法的参数（一个Object数组）Object[] args = joinPoint.getArgs(); 1.参数值 for循环打印出参数值 1234//循环，打印args数组里的值 for (int i=0;i&lt;args.length;i++)&#123; System.out.println("参数："+args[i]); &#125; 利用Array的toString方法打印参数值 1System.out.println("传递参数值："+ Arrays.toString(args)); 参考：数组输出的三种方式 2.参数名 123ParameterNameDiscoverer dpnd = new DefaultParameterNameDiscoverer();String[] argsNames = dpnd.getParameterNames(method);//method是之间获取方法时，得到的Method对象System.out.println("参数名："+ Arrays.toString(argsNames)); 然后做个数据分页即可，操作日志就完成了 2. 登录足迹loginLog我的做法是：在上文Security登录流程中的userServiceImpl类里，获取用户登录时间、ip。将数据拿到后封装，插入到数据库即可。 12345678910111213141516171819202122232425262728package com.SH.Service.ServiceImpl;import ...@Service("userService")//起个名字，供xml中配置@Transactionalpublic class userServiceImpl implements IuserService &#123; @Autowired private HttpServletRequest request; ... @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123; ... //获取用户ip、登录时间 String ip = request.getRemoteAddr();// Date logintime=new Date(); String logintime=DateAndString.DateToString(new Date(),"yyyy-MM-dd HH:mm:ss"); //打印以观察 System.out.println("用户："+username+"登陆ip"+ip+"；时间："+logintime); //将数据插入数据库即可 ... &#125; @Override public void addUser(UserInfo userInfo) throws Exception &#123;... &#125; 3. 日志数据分页依然是使用MyBatis的分页插件PageHelper，分页上次说过，这里简要复习，有一些知识的更新。 3.1. 依赖、Jar包12345&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;5.1.2&lt;/version&gt;&lt;/dependency&gt; 3.2. 分页后台这里使用了@RequestParam注解，属性name是前端参数名、required为是否必要、defaultValue为默认值。 分页插件的使用： 分页需要pageNum、pageSize两个参数，int或Integer类型。 PageHelper.startPage(int pageNum,int pageSize)方法后直接跟需要分页的方法即可，在service层写好后调用service也是可以的。 将查询方法返回的List集合交给PageInfo封装 在request域放入PageInfo对象即可 12345678910111213141516@RequestMapping("/selectBypage") public ModelAndView selectBypage(@RequestParam(name = "pageNum",required = true,defaultValue = "1") int pageNum, @RequestParam(name = "pageSize",required = true,defaultValue = "10") int pageSize) throws Exception &#123; //分页 PageHelper.startPage(pageNum,pageSize); List&lt;SysLog&gt; sysLogList = sysLogService.selectAll(); //pageInfo封装 PageInfo pageInfo=new PageInfo&lt;&gt;(sysLogList); ModelAndView mv=new ModelAndView(); mv.setViewName("syslog-list"); mv.addObject("pageInfo",pageInfo); return mv; &#125; PageInfo包装类的属性： 12345678910111213141516171819202122232425262728293031323334353637383940414243//当前页private int pageNum;//每页的数量private int pageSize;//当前页的数量private int size;//排序private String orderBy;//可以在页面中"显示startRow到endRow 共size条数据"//当前页面第一个元素在数据库中的行号private int startRow;//当前页面最后一个元素在数据库中的行号private int endRow;//总记录数private long total;//总页数private int pages;//结果集private List&lt;T&gt; list;//第一页private int firstPage;//前一页private int prePage;//下一页private int nextPage;//最后一页private int lastPage;//是否为第一页private boolean isFirstPage = false;//是否为最后一页private boolean isLastPage = false;//是否有前一页private boolean hasPreviousPage = false;//是否有下一页private boolean hasNextPage = false;//导航页码数private int navigatePages;//所有导航页号private int[] navigatepageNums; 3.3. 分页前端3.3.1. 环境准备EL表达式 前端Jsp页面使用EL表达式较为方便，要使用EL表达式注意将isELIgnored设为false，是否需要设置，要根据web.xml文件的声明部分的xsd版本而定，因为有的版本默认这个属性是true，会将EL表达式当字符串处理。 .jsp页面设置isELIgnored=”false”： 12&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8" isELIgnored="false" %&gt; web.xml，一个默认开启EL的版本： 12345&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://xmlns.jcp.org/xml/ns/javaee" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd" version="3.1"&gt; JSTL标签 在jsp页面头部引入JSP标准标签库 1&lt;%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core"%&gt; 3.3.2. 功能实现 数据展示 1234567891011121314151617&lt;!--数据列表--&gt;...前略&lt;!--使用jstl的forEach标签，进行数据遍历，items是要遍历的集合--&gt;&lt;c:forEach items="$&#123;pageInfo.list&#125;" var="syslog"&gt; &lt;tr&gt; &lt;td&gt;&lt;input name="ids" type="checkbox"&gt;&lt;/td&gt; &lt;td&gt;$&#123;syslog.id&#125;&lt;/td&gt; &lt;td&gt;$&#123;syslog.visitTimeStr &#125;&lt;/td&gt; &lt;td&gt;$&#123;syslog.username &#125;&lt;/td&gt; &lt;td&gt;$&#123;syslog.ip &#125;&lt;/td&gt; &lt;td&gt;$&#123;syslog.url&#125;&lt;/td&gt; &lt;td&gt;$&#123;syslog.executionTime&#125;毫秒&lt;/td&gt; &lt;td&gt;$&#123;syslog.method&#125;&lt;/td&gt; &lt;/tr&gt;&lt;/c:forEach&gt;...后略&lt;!--数据列表/--&gt; 分页按钮 1234567891011121314151617 &lt;a href="$&#123;pageContext.request.contextPath&#125;/sysLogController/selectBypage.action?pageNum=1&amp;pageSize=$&#123;pageInfo.size&#125;" &gt;首页&lt;/a&gt;&lt;a href="$&#123;pageContext.request.contextPath&#125;/sysLogController/selectBypage.action?pageNum=$&#123;pageInfo.pageNum-1&#125;&amp;pageSize=$&#123;pageInfo.size&#125;"&gt;上一页&lt;/a&gt; &lt;!-- 第一页、第二页、第三页...--&gt;&lt;ul&gt;&lt;c:forEach begin="1" end="$&#123;pageInfo.pages&#125;" var="num"&gt; &lt;li&gt;&lt;a href="$&#123;pageContext.request.contextPath&#125;/sysLogController/selectBypage.action?pageNum=$&#123;num&#125;&amp;pageSize=$&#123;pageInfo.size&#125;"&gt;$&#123;num&#125;&lt;/a&gt;&lt;/li&gt; &lt;/c:forEach&gt; &lt;/ul&gt; &lt;a href="$&#123;pageContext.request.contextPath&#125;/sysLogController/selectBypage.action?pageNum=$&#123;pageInfo.pageNum+1&#125;&amp;pageSize=$&#123;pageInfo.size&#125;"&gt;下一页&lt;/a&gt; &lt;a href="$&#123;pageContext.request.contextPath&#125;/sysLogController/selectBypage.action?pageNum=$&#123;pageInfo.pages&#125;&amp;pageSize=$&#123;pageInfo.size&#125;"&gt;尾页&lt;/a&gt; 改变每页容量 123456789101112131415161718&lt;div class="form-group form-inline"&gt;总共$&#123;pageInfo.pages&#125; 页，共$&#123;pageInfo.total&#125; 条数据。 每页 &lt;select id="selectSize" class="form-control" onchange="checkChange()"&gt; &lt;option&gt;10&lt;/option&gt; &lt;option&gt;15&lt;/option&gt; &lt;option&gt;20&lt;/option&gt; &lt;option&gt;50&lt;/option&gt; &lt;option&gt;80&lt;/option&gt; &lt;/select&gt; 条&lt;/div&gt;&lt;script&gt;//改变每页条数jsfunction checkChange()&#123;var size=$("#selectSize").val();location.href= "$&#123;pageContext.request.contextPath&#125;/sysLogController/selectBypage.action?pageNum=$&#123;pageInfo.pageNum&#125;&amp;pageSize="+size;&#125;&lt;/script&gt; 项目中使用了AdminLTE来美化页面。 AdminLTE：一款建立在bootstrap和jquery之上的开源的模板主题工具，它提供了一系列响应的、可重复使用的组件，并内置了多个模板页面；同时自适应多种屏幕分辨率，兼容PC和移动端。]]></content>
      <categories>
        <category>学习经验</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Maven聚合工程</tag>
        <tag>SSM</tag>
        <tag>用户关系管理项目</tag>
        <tag>Spring-security</tag>
        <tag>权限安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSM基础整合]]></title>
    <url>%2F2019%2F07%2F08%2FSSM%E5%9F%BA%E7%A1%80%E6%95%B4%E5%90%88%2F</url>
    <content type="text"><![CDATA[SSM基础整合Zero. 创建Maven项目， pom依赖： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.SH&lt;/groupId&gt; &lt;artifactId&gt;SSM_01Project&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;name&gt;SSM_01Project Maven Webapp&lt;/name&gt; &lt;!-- FIXME change it to the project's website --&gt; &lt;url&gt;http://www.example.com&lt;/url&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt; &lt;spring.version&gt;4.3.3.RELEASE&lt;/spring.version&gt; &lt;slf4j.version&gt;1.6.6&lt;/slf4j.version&gt; &lt;log4j.version&gt;1.2.12&lt;/log4j.version&gt; &lt;mysql.version&gt;5.1.6&lt;/mysql.version&gt; &lt;mybatis.version&gt;3.4.5&lt;/mybatis.version&gt; &lt;jackson.version&gt;2.6.1&lt;/jackson.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.6.8&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;$&#123;mysql.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- log start --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;$&#123;log4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- log end --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;c3p0&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.1.2&lt;/version&gt; &lt;type&gt;jar&lt;/type&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-dbcp&lt;/groupId&gt; &lt;artifactId&gt;commons-dbcp&lt;/artifactId&gt; &lt;version&gt;1.4&lt;/version&gt; &lt;/dependency&gt;&lt;!--json数据格式--&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;$&#123;jackson.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;$&#123;jackson.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--sql 解析工具依赖,配合分页使用--&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.jsqlparser&lt;/groupId&gt; &lt;artifactId&gt;jsqlparser&lt;/artifactId&gt; &lt;version&gt;0.9.5&lt;/version&gt; &lt;/dependency&gt; &lt;!--myBatis分页插件 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;5.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;SSM_01Project&lt;/finalName&gt; &lt;pluginManagement&gt;&lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/plugin&gt; &lt;!-- see http://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_war_packaging --&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.8.0&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;version&gt;2.22.1&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;version&gt;3.2.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-install-plugin&lt;/artifactId&gt; &lt;version&gt;2.5.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt; &lt;version&gt;2.8.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.2&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;showWarnings&gt;true&lt;/showWarnings&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;/build&gt;&lt;/project&gt; 1. ApplicationContext.xml 新建db.properties，写数据库配置需要的数据 加载db.properties，class为：PreferencesPlaceholderConfigurer，属性locations下用array，value，classpath引用db.properties datasource，class为：BasicDatasource，property下配置数据库链接信息 sqlSessionFactory，Class为：SqlSessionFactroyBean，属性需要引用datasource和mapperlocations值为classpath：*.xml加载mybatis的mapperxml mappers批量生成mapper接口的对象，class为：MapperScannerConfigurer，注意属性basePackage的值用value，而不是ref 开启注解扫描，component-scan，并且使用排除Controller注解（annotation），（org.springframework.stereotype.Controller） 配置事务管理，DataSourceTransactionManager，其属性中引入datasource，开启事务注解支持:&lt;tx:annotation-driven,空格后配置transaction-manager属性将上面bean的id值输入 代码： db.properties 1234driver=com.mysql.jdbc.Driverurl=jdbc:mysql://localhost:3306/databaseusername=rootpassword=123456 log4j.properties 123456789101112131415161718# Set root category priority to INFO and its only appender to CONSOLE.#log4j.rootCategory=INFO, CONSOLE debug info warn error fatallog4j.rootCategory=info, CONSOLE, LOGFILE# Set the enterprise logger category to FATAL and its only appender to CONSOLE.log4j.logger.org.apache.axis.enterprise=FATAL, CONSOLE# CONSOLE is set to be a ConsoleAppender using a PatternLayout.log4j.appender.CONSOLE=org.apache.log4j.ConsoleAppenderlog4j.appender.CONSOLE.layout=org.apache.log4j.PatternLayoutlog4j.appender.CONSOLE.layout.ConversionPattern=%d&#123;ISO8601&#125; %-6r [%15.15t] %-5p %30.30c %x - %m\n# LOGFILE is set to be a File appender using a PatternLayout.log4j.appender.LOGFILE=org.apache.log4j.FileAppenderlog4j.appender.LOGFILE.File=d:\axis.loglog4j.appender.LOGFILE.Append=truelog4j.appender.LOGFILE.layout=org.apache.log4j.PatternLayoutlog4j.appender.LOGFILE.layout.ConversionPattern=%d&#123;ISO8601&#125; %-6r [%15.15t] %-5p %30.30c %x - %m\n ApplicationContext.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd"&gt;&lt;!-- 数据源--&gt;&lt;bean id="dbproperties" class="org.springframework.beans.factory.config.PreferencesPlaceholderConfigurer"&gt; &lt;property name="locations"&gt; &lt;array&gt; &lt;value&gt;classpath:db.properties&lt;/value&gt; &lt;/array&gt; &lt;/property&gt;&lt;/bean&gt; &lt;bean id="datasource" class="org.apache.commons.dbcp.BasicDataSource"&gt; &lt;property name="driverClassName" value="$&#123;driver&#125;"/&gt; &lt;property name="url" value="$&#123;url&#125;"/&gt; &lt;property name="username" value="$&#123;username&#125;"/&gt; &lt;property name="password" value="$&#123;password&#125;"/&gt;&lt;/bean&gt;&lt;bean id="sqlsessionFactroy" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;property name="dataSource" ref="datasource"/&gt; &lt;property name="mapperLocations" value="classpath:MapperXml/*.xml"/&gt;&lt;!-- 插件列表--&gt; &lt;property name="plugins"&gt; &lt;array&gt;&lt;!-- myBatis分页--&gt; &lt;bean class="com.github.pagehelper.PageInterceptor"&gt; &lt;property name="properties"&gt; &lt;value&gt;helperDialect=mysql&lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/array&gt; &lt;/property&gt;&lt;/bean&gt;&lt;!-- 批量生成mapper对象--&gt;&lt;bean id="mappers" class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;property name="basePackage" value="com.SH.mapper"/&gt;&lt;/bean&gt;&lt;!-- 注解扫描，不扫描Controller--&gt; &lt;context:component-scan base-package="com.SH"&gt; &lt;context:exclude-filter type="annotation" expression="org.springframework.stereotype.Controller"/&gt; &lt;/context:component-scan&gt;&lt;!--事务管理--&gt; &lt;bean id="transManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="datasource"/&gt; &lt;/bean&gt;&lt;!-- 事务注解支持--&gt; &lt;tx:annotation-driven transaction-manager="transManager"/&gt;&lt;/beans&gt; 2. mpper.xml 配置mybaitis的mpper.xml 代码： MapperXml/VocaloidMapper.xml（放置在resources/MapperXml包下） 12345678910111213&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.SH.mapper.VocaloidMapper"&gt; &lt;select id="selectAll" resultType="com.SH.bean.Vocaloid"&gt; select * from vocaloid &lt;/select&gt;&lt;/mapper&gt; 3. 建立数据库表的对应类 生成set、get方法，构造器，重写toString 代码： com.SH.bean.Vocaloid 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package com.SH.bean;public class Vocaloid &#123;private Integer id;private String name;private Integer sex;private String color;private Integer team_id; public Vocaloid() &#123; &#125; @Override public String toString() &#123; return "Vocaloid&#123;" + "id=" + id + ", name='" + name + '\'' + ", sex=" + sex + ", color='" + color + '\'' + ", team_id=" + team_id + '&#125;'; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getSex() &#123; return sex; &#125; public void setSex(Integer sex) &#123; this.sex = sex; &#125; public String getColor() &#123; return color; &#125; public void setColor(String color) &#123; this.color = color; &#125; public Integer getTeam_id() &#123; return team_id; &#125; public void setTeam_id(Integer team_id) &#123; this.team_id = team_id; &#125; public Vocaloid(Integer id, String name, Integer sex, String color, Integer team_id) &#123; this.id = id; this.name = name; this.sex = sex; this.color = color; this.team_id = team_id; &#125;&#125; 3. Mapper接口 建立mapper.xml对应的接口 代码： com.SH.mapper.VocaloidMapper 123456789101112package com.SH.mapper;import com.SH.bean.Vocaloid;import java.util.HashMap;import java.util.List;public interface VocaloidMapper &#123; List&lt;Vocaloid&gt; selectAll();&#125; 4. springMVC.xml 开启mvc注解支持，annotation-driven 开启注解扫描component-scan，使用base-package只扫描Controller包 配置视图解析器InternalResourceViewResolver,prefix前缀，suffix后缀 代码： springMVC.xml 1234567891011121314151617181920212223242526272829303132&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt;&lt;!-- 配置组件扫描，注解扫描，只扫描Controller包--&gt;&lt;context:component-scan base-package="com.SH.controller"/&gt;&lt;!-- 开启mvc注解驱动，处理器映射器，处理器解析器--&gt; &lt;mvc:annotation-driven/&gt;&lt;!-- 视图解析器--&gt; &lt;bean id="internalviewresovler" class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/resources/jsp/"/&gt; &lt;property name="suffix" value=".jsp"/&gt; &lt;/bean&gt;&lt;!--释放静态资源，对静态资源使用原生态servlet--&gt;&lt;mvc:default-servlet-handler/&gt;&lt;!-- 配置放置静态资源的路径--&gt;&lt;!-- &lt;mvc:resources mapping="/resources/**" location="/resources/"/&gt;--&gt;&lt;/beans&gt; 5. web.xml 配置spring，使用listener,class为ContextLoaderListener,再使用Context-Param指定spring配置文件的位置 配置springMVC，使用servlet标签，class为DispatcherServlet,使用init-param初始化参数，使用load-on-start配置随服务器加载，最后再servlet-mapping设置需要拦截的请求，如*.action 配置解决中文的过滤器(filter)，class为：CharacterEncodingFilter,使用init-param初始化参数（参数名为encoding，值为utf-8） ,在filter-mapping里拦截所有请求（/*） classPath的使用 代码： web.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE web-app PUBLIC "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN" "http://java.sun.com/dtd/web-app_2_3.dtd" &gt;&lt;web-app&gt; &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt; &lt;!--配置spring--&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:ApplicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt;&lt;!-- 配置springMVC--&gt;&lt;servlet&gt; &lt;servlet-name&gt;Dispatchservlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springMVC.xml&lt;/param-value&gt; &lt;/init-param&gt;&lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;Dispatchservlet&lt;/servlet-name&gt; &lt;url-pattern&gt;*.action&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;!-- 配置解决中文乱码的过滤器--&gt; &lt;filter&gt; &lt;filter-name&gt;charactEncoding&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;charactEncoding&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt;]]></content>
      <categories>
        <category>学习经验</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>开发知识</tag>
        <tag>SSM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[int和Integer的区别]]></title>
    <url>%2F2019%2F07%2F06%2Fint%E5%92%8CInteger%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[int和Integer的区别 int是八大基本数据类型（byte，char，short，int，long，float，double，boolean）之一，而Integer是int 包装类，所以 int的默认值是0 Integer的默认值是null 在JDK1.5以后，Integer 有自动装箱和拆箱的语法糖。 自动装箱,假如写个Integer a： 其实为：Integer a=Integer.valueOf(int a); 自动拆箱，当涉及到计算时，如a+b： 其实为：a.intValue()+b.intValue(); Integer创建对象时，若数值在[-128,127]区间，第一次声明会将值放入缓存，第二次时会直接将上次缓存里的值给对象，所以地址不变，不是重新创建一个Ingeter 对象。 public static void main(String[] args) { Integer i = 10; Integer j = 10; System.out.println(i == j); }//结果为true 分析源码我们可以知道在 i &gt;= -128 并且 i &lt;= 127 的时候，第一次声明会将 i 的值放入缓存中，第二次直接取缓存里面的数据，而不是重新创建一个Ingeter 对象。 那么第一个打印结果因为 i = 10 在缓存表示范围内，所以为 true。 当值为128时，不放入缓存,会重新创建对象，地址变化: Integer i =128; Integer j = 128; System.out.println(i == j); }//结果为false 两个Integer对象比较时，使用equals 定义泛型时，必须使用Integer，而不是int，泛型参数必须是一个类，即Object的子类 Map&lt;String,Object&gt; map1 Map&lt;Integer,Object&gt; map2]]></content>
      <categories>
        <category>学习经验</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>开发知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSM+easyUI实现数据分页]]></title>
    <url>%2F2019%2F07%2F06%2F%E6%95%B0%E6%8D%AE%E5%88%86%E9%A1%B5%2F</url>
    <content type="text"><![CDATA[使用mybatis分页插件1. jar包和依赖： jsqlparser-0.9.5.jar（sql 解析工具） 123456&lt;!--sql 解析工具依赖,配合分页使用--&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.jsqlparser&lt;/groupId&gt; &lt;artifactId&gt;jsqlparser&lt;/artifactId&gt; &lt;version&gt;0.9.5&lt;/version&gt;&lt;/dependency&gt; pagehelper-5.1.2.jar 123456&lt;!--myBatis分页插件 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;5.1.2&lt;/version&gt;&lt;/dependency&gt; 2. spring配置文件ApplicatonContext.xml的sqlSessionFactory里配置一个载入插件的属性，名为plugins，用array来配置多个插件。 增加一个插件（拦截器），用标签 用bean，class为pagehelper的jar包中的PageInterceptor类。 此类中有个名为properties的属性，使用value对其赋值 value内填写：helperDialect=mysql（设置连接的是什么数据库,如mysql、Oracle） 如: 1234567891011121314 &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;property name="plugins"&gt; &lt;array&gt; &lt;bean class="com.github.pagehelper.PageInterceptor"&gt; &lt;property name="properties"&gt; &lt;value&gt; helperDialect=mysql &lt;/value&gt; &lt;/property&gt;&lt;/bean&gt; &lt;/array&gt; &lt;/property&gt; &lt;/bean&gt; 3. Controller在你需要进行分页的 MyBatis 查询方法前调用 PageHelper.startPage 静态方法即可，该方法需要两个参数pageNum、pageSize，紧跟在这个方法后的第一个MyBatis 查询方法会被进行分页。 12345678//request: url?pageNum=1&amp;pageSize=10//支持 ServletRequest,Map,POJO 对象，需要配合 params 参数PageHelper.startPage(request);//紧跟着的第一个select方法会被分页List&lt;Country&gt; list = countryMapper.selectIf(1);//后面的不会被分页，除非再次调用PageHelper.startPageList&lt;Country&gt; list2 = countryMapper.selectIf(null); 使用： 1234567891011121314151617181920 /** 使用pagehelper+PageInfo进行分页查询 *///private Map&lt;String,Object&gt; result= new HashMap&lt;String,Object&gt;(); @RequestMapping(value = "/selectBypage") @ResponseBody//将返回值转为json数据格式 public Map&lt;String,Object&gt; selectBypage(Integer page,Integer rows,HashMap&lt;String,Object&gt; map)&#123; //使紧跟其后的mybatis查询分页 PageHelper.startPage(page,rows); List&lt;Vocaloid&gt; vocaloidsBypage=vocaloidService.selectAll(); //将查询结果封装 PageInfo&lt;Vocaloid&gt; pageInfo=new PageInfo&lt;&gt;(vocaloidsBypage); long total = pageInfo.getTotal(); List&lt;Vocaloid&gt; list = pageInfo.getList(); map=new HashMap&lt;&gt;(); map.put("rows",list); map.put("total",total); //其实直接把查询结果vocaloidsBypage放到rows就可以了 return map; &#125; 4. 什么时候会导致不安全的分页？12345678//获取第1页，10条内容，默认查询总数countPageHelper.startPage(1, 10);List&lt;Country&gt; list;if(param1 != null)&#123; list = countryMapper.selectIf(param1);&#125; else &#123; list = new ArrayList&lt;Country&gt;();&#125; 这种情况下由于 param1 存在 null 的情况，就会导致 PageHelper 生产了一个分页参数，但是没有被消费，这个参数就会一直保留在这个线程上。当这个线程再次被使用时，就可能导致不该分页的方法去消费这个分页参数，这就产生了莫名其妙的分页。 上面这个代码，应该写成下面这个样子： 12345678List&lt;Country&gt; list;if(param1 != null)&#123; //获取第1页，10条内容，默认查询总数count PageHelper.startPage(1, 10); list = countryMapper.selectIf(param1);&#125; else &#123; list = new ArrayList&lt;Country&gt;();&#125; 这种写法就能保证安全。 5. 跳转页面过界如果你分页插件使用于类似分页查看列表式的数据，如新闻列表，软件列表， 你希望用户输入的页数不在合法范围（第一页到最后一页之外）时能够正确的响应到正确的结果页面， 那么你可以配置 reasonable 为 true，这时如果 pageNum&lt;=0 会查询第一页，如果 pageNum&gt;总页数 会查询最后一页。 1234567891011121314151617181920212223242526 &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;property name="mapperLocations"&gt; &lt;array&gt; &lt;value&gt;classpath:mapper/*.xml&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;property name="typeAliasesPackage" value="com.isea533.mybatis.model"/&gt; &lt;property name="plugins"&gt; &lt;array&gt; &lt;bean class="com.github.pagehelper.PageInterceptor"&gt; &lt;!-- 这里的几个配置主要演示如何使用，如果不理解，一定要去掉下面的配置 --&gt; &lt;property name="properties"&gt; &lt;value&gt; helperDialect=mysql reasonable=true supportMethodsArguments=true params=count=countSql autoRuntimeDialect=true &lt;/value&gt; &lt;/property&gt;&lt;/bean&gt; &lt;/array&gt; &lt;/property&gt; &lt;/bean&gt; 了解更多… 使用easyUI1. 启用easyui-datagrideasyui-datagrid下设置：pagination:true 显示分页菜单： 整体代码如： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!--数据网络--&gt;&lt;table id="vstable"&gt;&lt;/table&gt;&lt;script type="text/javascript" &gt; $(function () &#123; $("#vstable").datagrid(&#123; fitcolumns:true, url:"$&#123;pageContext.request.contextPath&#125;/vocaloidController/vSelectAll.action", columns:[[ &#123; field:"null", checkbox:true &#125;, &#123; field:"id", title:"ID", width:100 &#125;, &#123; field:"name", title:"Name", width:100 &#125;, &#123; field:"sex", title:"Sex", width:100 &#125;, &#123; field:"color", title:"Color", width:100 &#125;, &#123; field:"team_id", title:"Team_ID", width:100 &#125; ]], //显示分页栏 pagination:true, //工具条 toolbar:"#tb" &#125;); &#125;);&lt;/script&gt; 2. 参数解析easyUI会向后台发送两个参数,page和rows： 传参形式为： 而后台不仅需要给easyUI传递json格式的查询结果，而且还需要传递total和rows： 3. easyUI配合controller的增删改查 添加： Controller: 123456789101112131415@RequestMapping(value = "/InsertBypage")@ResponseBodypublic Map&lt;String,Object&gt; InsertBypage(Vocaloid vocaloid,HashMap&lt;String,Object&gt; map)&#123; boolean b = vocaloidService.insertOne(vocaloid); map=new HashMap&lt;&gt;(); System.out.println(b); if (b)&#123; map.put("success",b); return map; &#125;else&#123; map.put("success",b); return map; &#125;&#125; Service: 123456789101112131415 @Override public boolean insertOne(Vocaloid vocaloid) &#123; boolean b; //将插入成功的返回值设为true，异常的返回值为false try &#123; b = vocaloidMapper.insertOne(vocaloid); &#125;catch (Exception e)&#123; b=false; e.printStackTrace(); &#125;// int e=11/0;//异常测试 System.out.println("新增一行vocaloid,返回：" + b); return b; &#125; html&amp;Js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;%--easyUI按钮，增删改查工具条，iconCls是图标，plain:true是按钮3d感？--%&gt;&lt;div id="CRUDbutton"&gt; &lt;a id="addButton" href="#" class="easyui-linkbutton" data-options="iconCls:'icon-add'"&gt;添加&lt;/a&gt; &lt;a id="updateButton" href="#" class="easyui-linkbutton" data-options="iconCls:'icon-edit',plain:true"&gt;修改&lt;/a&gt; &lt;a id="deleteButton" href="#" class="easyui-linkbutton" data-options="iconCls:'icon-remove',plain:true"&gt;删除&lt;/a&gt;&lt;/div&gt;&lt;%--编辑窗口，默认关闭状态，用js控制打开--%&gt;&lt;%--div--%&gt;&lt;div id="Edit_window" class="easyui-window" title="客户数据编辑" style="width:500px;height:300px" data-options="modal:true,closed:true"&gt; &lt;form id="insertForm" method="post"&gt; &lt;label&gt;ID&lt;/label&gt;&lt;input type="text" name="id" class="easyui-validatebox" data-options="required:true"&gt;&lt;br&gt; &lt;label&gt;Name&lt;/label&gt;&lt;input type="text" name="name" class="easyui-validatebox"&gt;&lt;br&gt; &lt;label&gt;Sex&lt;/label&gt;&lt;input type="text" name="sex"&gt;&lt;br&gt; &lt;label&gt;Color&lt;/label&gt;&lt;input type="text" name="color"&gt;&lt;br&gt; &lt;label&gt;Team_ID&lt;/label&gt;&lt;input type="text" name="team_id"&gt;&lt;br&gt; &lt;a id="insert_Button" href="#" class="easyui-linkbutton"&gt;确定&lt;/a&gt; &lt;/form&gt;&lt;/div&gt;&lt;%--增加按钮的事件--%&gt;&lt;script type="text/javascript"&gt; $(function () &#123; // 点击“添加”按钮时，打开窗口 $("#addButton").click(function () &#123; //打开窗口前清空里面的表单 $("#insertForm").form("clear"); //打开窗口 $("#Edit_window").window("open") &#125;); //点击确定按钮（上面的a标签）触发controller和事件 $("#insert_Button").click(function () &#123; $("#insertForm").form( "submit", &#123;url:"$&#123;pageContext.request.contextPath&#125;/vocaloidController/InsertBypage.action", //success:服务器执行完毕回调函数 success:function(data)&#123; //data: 服务器返回的数据，类型字符串类，此时我在InsertBypage方法返回值里放入了success变量 //把data字符串类型转换对象类型 data = eval("("+data+")"); if (data.success) &#123; //关闭窗口 $("#Edit_window").window("close"); //刷新datagrid $("#vstable").datagrid("reload"); $.messager.alert("提示"+data.success,"增加成功"); &#125;else &#123; //关闭窗口 $("#Edit_window").window("close"); //刷新datagrid $("#vstable").datagrid("reload"); $.messager.alert("提示"+data.success+"增加失败：","可能是id重复"); &#125; &#125; &#125; ); &#125;); &#125;);&lt;/script&gt;]]></content>
      <categories>
        <category>学习经验</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>开发知识</tag>
        <tag>mybatis分页插件</tag>
        <tag>数据分页</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL Error:Lost connection to MySQL server]]></title>
    <url>%2F2019%2F07%2F05%2FMySQL-Error-2013%2F</url>
    <content type="text"><![CDATA[MySQL 提示：1. Lost connection to MySQL server at ‘waiting for initial communication packet’,system error:0 错误产生经过：昨天试加速器试用，改了硬件信息，隔天上午数据库运行正常，下午重启后mysql连接时就出错了。 解决方法： 找到mysql安装目录下的my.ini文件(我mysql安装目录是在D:\SP GAME),记事本打开my.ini, 找到[mysqld],在末尾添加一行： skip-name-resolve 记得保存。 在“计算机管理-服务和应用程序-服务”找到MySQL， 重启该服务。 2. Lost connection to MySQL server at ‘reading initial communication packet’, system error: 0 重启MySQL服务]]></content>
      <categories>
        <category>开发问题</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>mysql</tag>
        <tag>error</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JQuery EasyUI入门]]></title>
    <url>%2F2019%2F07%2F03%2FEasyUI%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[EasyUI入门使用简 介easyui是一种基于jQuery、Angular.、Vue和React的用户界面插件集合，可简单快速的搭建页面布局，方便后台人员制作简易的管理界面，节省网页开发的时间和规模，现在开始学习easyUI的jquery版本的入门使用。 引入资源文件在官网下载jQuery版的easyUI后，在项目的webapp中建立一个文件夹，用于存放easyUI的资源文件，如图所示： 分别选择themes、jquery.easyui.min.js和jquery.min.js，导入到项目中，如图所示： 新建html或jsp，在&lt; head&gt;里引用项目中的资源文件，如下所示： 1234567891011&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;easyUI.html-class&lt;/title&gt; &lt;link rel="stylesheet" type="text/css" href="easyUI/themes/default/easyui.css"&gt; &lt;link rel="stylesheet" type="text/css" href="easyUI/themes/icon.css"&gt; &lt;script type="text/javascript" src="easyUI/jquery.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="easyUI/jquery.easyui.min.js"&gt;&lt;/script&gt; &lt;!-- 新增 --&gt; &lt;script type="text/javascript" src="easyUI/locale/easyui-lang-zh_CN.js"&gt;&lt;/script&gt;&lt;/head&gt; 功能和使用1、树（tree）easyui-tree：树形菜单 效果如图： 使用： easyui-tree 、 .tree() 属性： checkbox：true（可开启复选框） 可直接在标签中用class=“easyui-tree”来使用，注意&lt; span&gt;标签，data-options中配置属性，多个属性之间用逗号隔开： 12345678&lt;ul class="easyui-tree" data-options="checkbox:true"&gt; &lt;li&gt;&lt;span&gt;菜单a&lt;/span&gt; &lt;ul &gt; &lt;li&gt;&lt;span&gt;菜单1&lt;/span&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt;&lt;span&gt;菜单b&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt; 推荐使用普通html标签+js的方式来实现。这样能处理更复杂的样式。 具体写法为在标签设置一个id或class，接下来在js写$(function(){ }),大括号中使用$(&quot;#id&quot;)或是class用$(&quot;.class&quot;)来指定对象。 接着对象后.tree();即可设置树应用到对象，关于.tree()里的属性的设置，直接在（）中使用｛｝大括号将属性包括即可，多个属性用逗号隔开，与data-options相同。 如 $(&quot;#uitree&quot;).tree( { checkbox:true ，... } ); ， 整体代码如下： 1234567891011121314151617&lt;%--树形菜单 可设置checkbox属性--%&gt; &lt;ul id="uitree"&gt; &lt;li&gt;&lt;span&gt;菜单a&lt;/span&gt; &lt;ul&gt; &lt;li&gt;&lt;span&gt;菜单a-1&lt;/span&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt;&lt;span&gt;菜单b&lt;/span&gt;&lt;/li&gt; &lt;/ul&gt; &lt;script type="text/javascript"&gt; $(function () &#123; $("#uitree").tree(&#123; checkbox:true &#125;); &#125;) &lt;/script&gt; .tree()应用tree功能，tree()的属性如checkbox设为true可开启选择框，部分其他功能用法与tree一样，非必要时不再赘述。 2、拖动和放置easyui-draggable：可拖动 easyui-droppable：可放置 效果如图： 使用： easyui-draggable 、 .draggable()；easyui-droppable 、 .droppable()； 拖动和放置两个功能，可同时作用于一个对象。 拖动 handle:&#39;&#39;#xxx&#39;（指定只有拖住’#xxx‘时，才可拖动整个div） proxy proxy:&#39;clone&#39;（拖动时创建复制的副本，拖动时拖动副本，松手时本体位置改变，副本消失） proxy:function(source){}（自定义一个副本） revert:true（拖动时松手，元素将返回原来位置） disabled:true（停用拖动）更多… 放置 accept:&quot;#xx1,#xx2&quot; （指定可放置的对象） disabled:true（停用可放置） onDrop:function (e, source) { $(this).append(source);}（将对象放置区域内部） 更多… class方式使用： 1234&lt;!--可拖动的div draggable, 在data-options将属性handle进行下例的设置，就可设置只有拖动id为title的div才会生效--&gt;&lt;div class="easyui-draggable" data-options="handle:'#title'" style="width: 200px;height: 100px;background-color: #00bbee"&gt; &lt;div id="title" style="width: auto;height: 20px"&gt;div的标题title&lt;/div&gt;&lt;/div&gt; JS方式（css+html+js代码如下）： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;%--拖动和放置div的CSS--%&gt; &lt;style type="text/css"&gt; .DDbox &#123; width: 700px; height: 200px; border: 1px solid black; &#125; #Div_draggable &#123; width: 300px; height: 100px; background-color: #00ee00; margin-right: 100px; border: 1px solid black; float: left; &#125; .content &#123; height: 20px; width: 100px; background-color: #00bbee; margin: 5px; &#125; #Div_droppable &#123; width: 200px; height: 100px; border: 1px solid black; float: left; &#125; &lt;/style&gt; &lt;%--可拖动div 可设置handle属性、proxy代理属性（clone或自定义新对象(传递一个function)）,revert设置为true可在鼠标释放时复原，其他也可设置拖拽范围--%&gt; &lt;div class="DDbox"&gt; &lt;div id="Div_draggable" &gt; &lt;div id="title" style="width: auto;height: 20px"&gt;拖拽我 才可拖动整个div &lt;/div&gt; &lt;div class="content" id="drag1"&gt;内容1&lt;/div&gt; &lt;div class="content" id="drag2"&gt;内容2&lt;/div&gt; &lt;div class="content" id="drag3"&gt;内容3&lt;/div&gt; &lt;/div&gt; &lt;%--与draggable组合，可放置元素的容器--%&gt; &lt;div id="Div_droppable"&gt; &lt;div id="title2" style="width: auto;height: 20px"&gt;可放置的容器&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;%--拖动和放置的js, 可拖动和可放置 能同时作用于同一个div--%&gt; &lt;script type="text/javascript"&gt; &lt;%-- （注意大小写） 左： 拖动--%&gt; $(function () &#123; $("#Div_draggable").draggable(&#123; handle:'#title',proxy:'clone' &#125;).droppable(&#123; onDrop:function (e,source) &#123; $(this).append(source); &#125; &#125;); $(".content").draggable(&#123; proxy:'clone',revert:true &#125;) &#125;); &lt;%--右： 放置 --%&gt; $(function () &#123; $("#Div_droppable").droppable(&#123; accept:"#drag1,#drag2", onDrop:function (e, source) &#123; $(this).append(source); &#125; &#125;).draggable(&#123; proxy:'clone',handle:'#title2' &#125;); &#125;) &lt;/script&gt; 3、调节尺寸easyui-resizable：可调节尺寸大小，注意单词是resizable ，不是resize，没有e。效果如图： 鼠标放置区域的边框上即可调节长宽。 【属性】（区分大小写，像素不用带px）： minWidth：最小宽度 minHeight：最小高度 maxWidth：最大宽度 maxHeight：最大高度 更多… 使用1： 123&lt;!--可缩放的div区域 resizable,有minWidth、minHeight、maxWidth等属性，注意像素直接写数字不要带px，逗号隔开--&gt;&lt;div class="easyui-resizable" data-options="minWidth:100,minHeight:100,maxWidth:500" style="border: solid;width: 100px;height: 150px"&gt;&lt;/div&gt; 使用2： 12345678910&lt;%--可缩放调整大小的div resizable--%&gt; &lt;div id="resize" style="height: 50px;width: 50px;border: solid"&gt;&lt;/div&gt; &lt;script type="text/javascript"&gt; $(function () &#123; $("#resize").resizable(&#123; minWidth:25,minHeight:25 &#125;) &#125;) &lt;/script&gt; 博主：(╯﹏╰)给自己挖个大坑，这样写太耗时间了，后面会有个easyUI实际运用的文章。]]></content>
      <categories>
        <category>学习经验</category>
      </categories>
      <tags>
        <tag>开发知识</tag>
        <tag>javaScript</tag>
        <tag>easyUI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[宫泽贤治]]></title>
    <url>%2F2019%2F06%2F23%2F%E5%AE%AB%E6%B3%BD%E8%B4%A4%E6%B2%BB%2F</url>
    <content type="text"><![CDATA[童话作家所有人的童话宫泽贤治写的故事里，常常有会说话、会像人一样行走的动物（废话，因为是童话啊），虽说是童话，但有的故事我依然还没能看明白，比如为什么山猫会消失，黑熊为什么2年后死去？不过他的故事并不难读，有孩童能看到的结局，有大人能看懂的深意。记得作者在自序中写道： 因此，这些故事当中，也许有些会对您有益处，有的没有，关于这一点我自己也无法分辨其中的差别。其中有些部分，或许您读了会觉得一头雾水，其实我也不知道为什么会写出这些内容。 看到这段话时我不由笑起来，觉得作者坦白得可爱，让我想起了曾经高中的语文。 澄净透明的文字宫泽贤治的文字充满自然的气息，纯净又真挚，总是有着丰富的想象力，诗一样精致，绘出浪漫唯美的景象。就如同他在自序中所说： 我所写的故事，全都来自森林、原野、铁道线路、彩虹或月光。 《文少》中这样评价宫泽贤治的作品： 「贤治的作品是非常质朴的，散发着大地、风和阳光一样的香味，透明又真切，让人不禁产生一种怀念的感觉呢。就好比，在吹着爽朗的微风的田间，穿着沾着泥土的围裙，低着头作业的感觉——散发着青草的气味，有点酸，有点苦，又有点甜的感觉，在口中渐渐融开，喉咙也好像被滋润了一样。又像是用冰冷河水洗过的黄瓜味，像是嚼着生茄子般带着的新鲜和甜味，像是祭典的夜里喝下的橘子汽水——不光是贤治写下的故事，连他的行文方式，文章的节奏，甚至语言本身都有着独特的味道呢！」 银河铁道之夜 宫泽贤治写的童话有很多，作者也说过“其实我也不知道为什么会写出这些内容”。但我相信《银河铁道之夜》的每一个字都有其特别的用意。宫泽贤治在病床不断修改着《银河铁道之夜》的原稿，直到去世时也没有最终版本。 乔班尼才刚听见某处传来奇异的声音：”银河站——银河站——“ 眼前倏地一片亮光。仿佛数以亿万计的荧光鱿鱼瞬间成为化石，沉入天空； 这篇童话描述了一段在银河铁道上从北十字星站到南十字星站的旅途，一段神奇美丽的星星之旅，可却让读者在故事里感受到一种强烈的孤独。 乔班尼像子弹一样奋力起身。为了不让其他人听见，他将身子伸出窗外，接着激动地吼叫、用力的捶胸，最后失声痛苦。他的世界仿佛陷入一片黑暗。 志同道合的妹妹（宫泽登志|敏子）的病逝，是宫泽贤治创作《银河铁道之夜》的契机. 「有传闻说，乔班尼和柯贝内拉在现实中是有其原形的。内向又孤独的乔班尼就是贤治自己，而柯贝内拉的原形虽然有很多种不同的说法，但是最为大家接受的则是贤治的妹妹登志。 登志比贤治还要小两岁，在学校里也经常是第一名，是一个优等生。贤治一直都为登志感到非常自豪，登志也一直仰慕着自己的哥哥。两人的感情非常的好，就连登志去东京上学的时候，两人的信件也不曾间断过。十八岁的时候，因为法华经而深受感悟的贤治，和热心于净土真宗的父亲产生了深刻的对立。而登志却相信了那样的贤治，成了贤治以外家中唯一信仰法华经的人，一直在背后支持着贤治。对于贤治来说，登志不仅仅是他的妹妹，还是与他共有思想和世界观的唯一的存在吧。」 在贤治二十六岁的冬天，他如此喜爱着的妹妹登志，因为疾病而过世了……贤治把当时所受到的打击，在『永诀的早晨』、『松之针』、『无声恸哭』等几首诗中写了出来。那是连灵魂都流出鲜血，连声音都发不出来的绝望哀叫，让人觉得胸口也要崩溃了一样……然后，在失去了『唯一一个拥有相同信仰的同伴』之后的两年里，贤治写下了《银河铁道之夜》的初稿…… 他竭力去创作一个“能让所有人幸福”的乌托邦、一幅人类的“永恒世界”，并且自己为此“宁愿舍弃这一切的幸福”。失去亲伴的悲痛让他产生无比强烈的愿望、舍弃一切的冲动、生与死的思考，”蝎之火“、因沉船遇难的青年、主人公“乔班尼(Giovanni )”以及故事的另一个主人公“柯贝内拉(Campanella)”都能体现出作者自己的愿望。 宫泽贤治在诗歌《永诀之朝》中写道： 面对你所渴求的那两碗雪， 我衷心的祈祷着。 愿它变成上天的赐予， 为你和大家， 得到神圣的粮食 我宁愿舍弃这一切的幸福 到底大家真正的幸福是什么？这是《银河铁道之夜》中宫泽贤治对幸福的探究与心中的迷惘。乔班尼的幸福，是和最好的朋友“无论到哪里，我们都要一起去”，而柯贝内拉的幸福，仅是做好事，牺牲自己奉献他人吗？ 《文少》中这样提问： 「……你觉得柯贝内拉的愿望，是什么呢？」 乔班尼和柯贝内拉的愿望相互纠缠，或许他们是同一个人也说不定，而贤治和登志，谁是乔班尼，谁又是柯贝内拉呢，或许二者没有关联，但总能从这童话里看到他们模糊的影子。 诗人与作词家败北少年之歌(败れし少年の歌へる) 是咏叹宫泽贤治在海边看到破晓时分的景象的一首诗，改编自贤治在三陆旅行时写下的《对晓穹之嫉妒》，这首诗收录在《春与修罗》的第二集里。 如下： 闪耀在拂晓的星光 「 ひかりわななくあけぞらに 」犹如蓝宝石般散发着光芒 「 清丽サフィアのさまなして 」可与你相比的它 「 きみにたぐへるかの惑星(ほし)の 」给人即将消失于天空的悲伤 「 いま融け行くぞかなしけれ 」 覆盖在松柏上的白雪 「 雪をかぶれるびゃくしんや 」与无数的海峡被黎明点亮 「 百の海岬いま明けて 」一望无际的深蓝大海 「 あをうなばらは万叶の 」被悠远的曲调所吸引 「 古きしらべにひかれるを 」 夜晚被层层乌云覆盖 「 夜はあやしき积云の 」却从中闪耀出星星的光辉 「 なかより生れてかの星ぞ 」就如你那动人的语句 「 さながらきみのことばもて 」在我内心燃烧 「 われをこととひ燃えけるを 」 就如最美丽的宝石 「 よきロダイトのさまなして 」却在拂晓的天空中 「 ひかりわなゝくかのそらに 」慢慢消失 「 溶け行くとしてひるがへる 」正因为你是星星才更让人悲伤 「 きみが星こそかなしけれ 」 《败北少年之歌》名字有些奇怪，似乎与内容并没有什么关联。不过，读过后确实发现其中宁静的败北，可能真如文少中提及，是首失恋的诗吧。（结合贤治本人的恋爱经历，这难道是写妹妹的？嗯哼？[#破事水]） 看到《败北少年之歌》这样的标题的时，虽然会让人有一种心跳的感觉，但读过之后就会明白，其实诗里并非是对伤痛和绝望的悲叹，而是又宁静又美丽的诗喔。遥望群星渐渐消失，远方天际缓缓发白，还带着一种悲伤的感觉……也有人说这是首失恋的诗歌。 不畏风雨(雨ニモマケズ) 大学毕业后，宫泽贤治任教四年，做农业指导，后来却辞职务农，离家在郊外独居，过着普通农民生活，乐在其中。 《文少》中关于宫泽贤治务农的介绍： 宫泽贤治是1896年出生在岩手县的诗人和童话作家。而且，他还有着农业指导家的身份，不仅开发了新的肥料，还经常在农村指导农民科学的农业和种植方法，又引进了当时岩手很少看到的郁金香、花椰菜、土豆等新品种。而且他还自学了风琴和大提琴，在当地举办一些演奏会，为当地文化的兴盛而努力着。 诗歌内容： 不怕风 不怕雨 不畏寒冬酷暑 总有强健的体魄 没有欲望 不生气 一直静静地笑着 每天只吃一些糙米、酱汤以及少于的蔬菜 对于包括自己在内的任何事情都无动于衷 耳闻目睹就已足够 然后不会忘记 在山野的松树林下的树荫里的小茅草屋里 就已足够安身 假若东边有生病的孩子 我便会前去看望 西边人家的母亲因干活而劳累 我会上前帮她背着成捆的稻草 南边若要有垂死之人 我便会给他说不用害怕 假若北边居住的人发生争执 我便会耐心劝解他们 太阳高照，大旱成灾时我会因此而伤心落泪 在酷暑炎夏里遇见寒潮我会因此而心急如焚 大家都叫我傻瓜 可我却不求赞扬 也不会将苦恼挂在心头 我想成为这样的人 永诀之朝(永诀の朝) 妹妹冬日病逝，这应当是宫泽贤治一生最痛苦的事情，他在这之后的1922年，写下了《永诀之朝》。 诗歌的部分如下： 我小心翼翼地站在那上面， 保持着雪与水那纯洁的联系， 满载着透明的冰冷安静的雪水， 从这闪烁着残微光亮的脆嫩松枝上， 为我那心爱的善良美好的妹妹取下那最后的渴求。 在伴随着我们一起长大的岁月里， 早已熟悉了这陶瓷碗上的蓝色花纹。 如是今朝却也要与你永诀， （我将独自前行） 在那封闭了的病房里， 在那昏暗的屏风和帐子里， 你正面色苍白温情脉脉地燃尽着生命 这首诗歌有些长，详见百度百科：永诀の朝 巡星之歌(星めぐりの歌) *星めぐりの歌 *(ほしめぐりのうた)是宫泽贤治创作的一首童谣，由宫泽贤治作词作曲，歌曲描绘在银河遨游看到的景色，星座与星座之间构成的美丽图画，在其作品《双子之星》和《银河铁路之夜》有出现，现在也常在各种影像作品中被引用。这首歌我最早在《星之梦》中就有所接触，虽说是个Galgame，当时并不知道宫泽贤治，也没读过《银河铁道之夜》。 *歌词如下：* あかいめだまの さそり 天蝎闪烁著红眼睛（天蝎座 Scorpio） ひろげた鷲の つばさ 天鹰展翅翱翔天际（天鹰座 Aquila） あをいめだまの 小いぬ、 小犬眨著蓝色眼眸（小犬座 Canis Minor） ひかりのへびの とぐろ。 蜷曲巨蛇隐隐透出光芒（蛇夫座 Ophiuchus） オリオンは高く うたひ 当猎户在天上高声歌唱时（猎户座 Orion） つゆとしもとを おとす、 地上便降下了露水和冰霜（猎户座的最佳观测时间在冬季） アンドロメダの くもは 仙女座中的云气（仙女座 Andromedae） さかなのくちの かたち。 宛如鱼的嘴形（仙女座大星云，椭圆形螺旋星云） 大ぐまのあしを きたに 从大熊前脚向北（大熊座 Ursae Majoris） 五つのばした ところ。 延伸五倍之处 小熊のひたいの うへは 在那小熊额顶（小熊座 Ursa Minor） そらのめぐりの めあて。 正是巡星游天的枢轴（北极星 Polaris） 宫泽贤治​ 宫泽贤治生前埋头文学，可写的童话无人问津，死后却声名显赫，这不禁让人联想到同样遭遇的梵高。他生前创作了94篇童话和一千多首诗歌，可只有《渡雪原》获得过稿费，出版的童话集《要求很多的餐馆》和诗歌集《春与修罗》还是自费出版的，并且沒卖出几本，贤治自己不忍心，向父亲借钱，自掏腰包买了两百本自己的书 ​ 关于贤治死后的成功，就要归功于弟弟宫泽清六的推动，弟弟与诗人草野心平等人编写了《追悼宫泽贤治》一书，并全部由宫泽家出资，将书出版，之后宫泽贤治的作品才被文坛所重视，引起世人瞩目。 ​ “父亲啊父亲，您为何故意要在舍监面前转动那块银表的发条呢？”，宫泽贤治身为富家子弟，却十分不满自家对穷人的剥削，身为长子，却并不想顺从父亲的意愿继承家业，虽说如此，父亲依然是他生前支持他文学创作的“出资人”。 ​ 大学毕业后就开始任教指导农民科学种田,之后又辞职务农，边与大自然接触边写童话诗歌，其实贤治早在盛冈高等农林学校读大三时便到岩手县种山平原进行过地质考察。当时贤治刚和朋友们一起创办了同人志『杜鹃花』，满怀着对与未来的理想和希望，每天都过着充实的生活。在这个人生最幸福的时期里感受到的美丽大自然，深深地印刻在贤治的心底，在贤治以后的作品中，也能看到很多与种山平原相关的痕迹。也有种说法，《银河铁道之夜》的星空便出自这个地方。 ​ 贤治一生未娶，高中时曾要与一名同年龄的护士结婚，被父亲拒绝，后又对大学同学以及妹妹敏子有疑似恋爱的情结，三十岁后拒绝女方两次，三十七岁因肺病早逝。]]></content>
      <categories>
        <category>闲谈</category>
      </categories>
      <tags>
        <tag>银河铁道之夜</tag>
        <tag>宫泽贤治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown练习（html版）]]></title>
    <url>%2F2019%2F06%2F13%2Fmarkdown%E8%AF%AD%E6%B3%95%E7%BB%83%E4%B9%A02%2F</url>
    <content type="text"><![CDATA[markdown语法练习html {overflow-x: initial !important;}:root { --bg-color:#ffffff; --text-color:#333333; --select-text-bg-color:#B5D6FC; --select-text-font-color:auto; --monospace:"Lucida Console",Consolas,"Courier",monospace; } html { font-size: 14px; background-color: var(--bg-color); color: var(--text-color); font-family: "Helvetica Neue", Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; } body { margin: 0px; padding: 0px; height: auto; bottom: 0px; top: 0px; left: 0px; right: 0px; font-size: 1rem; line-height: 1.42857; overflow-x: hidden; background: inherit; tab-size: 4; } iframe { margin: auto; } a.url { word-break: break-all; } a:active, a:hover { outline: 0px; } .in-text-selection, ::selection { text-shadow: none; background: var(--select-text-bg-color); color: var(--select-text-font-color); } #write { margin: 0px auto; height: auto; width: inherit; word-break: normal; word-wrap: break-word; position: relative; white-space: normal; overflow-x: visible; padding-top: 40px; } #write.first-line-indent p { text-indent: 2em; } #write.first-line-indent li p, #write.first-line-indent p * { text-indent: 0px; } #write.first-line-indent li { margin-left: 2em; } .for-image #write { padding-left: 8px; padding-right: 8px; } body.typora-export { padding-left: 30px; padding-right: 30px; } .typora-export .footnote-line, .typora-export li, .typora-export p { white-space: pre-wrap; } @media screen and (max-width: 500px) { body.typora-export { padding-left: 0px; padding-right: 0px; } #write { padding-left: 20px; padding-right: 20px; } .CodeMirror-sizer { margin-left: 0px !important; } .CodeMirror-gutters { display: none !important; } } #write li > figure:first-child { margin-top: -20px; } #write ol, #write ul { position: relative; } img { max-width: 100%; vertical-align: middle; } button, input, select, textarea { color: inherit; font-style: inherit; font-variant: inherit; font-weight: inherit; font-stretch: inherit; font-size: inherit; line-height: inherit; font-family: inherit; } input[type="checkbox"], input[type="radio"] { line-height: normal; padding: 0px; } *, ::after, ::before { box-sizing: border-box; } #write h1, #write h2, #write h3, #write h4, #write h5, #write h6, #write p, #write pre { width: inherit; } #write h1, #write h2, #write h3, #write h4, #write h5, #write h6, #write p { position: relative; } h1, h2, h3, h4, h5, h6 { break-after: avoid-page; break-inside: avoid; orphans: 2; } p { orphans: 4; } h1 { font-size: 2rem; } h2 { font-size: 1.8rem; } h3 { font-size: 1.6rem; } h4 { font-size: 1.4rem; } h5 { font-size: 1.2rem; } h6 { font-size: 1rem; } .md-math-block, .md-rawblock, h1, h2, h3, h4, h5, h6, p { margin-top: 1rem; margin-bottom: 1rem; } .hidden { display: none; } .md-blockmeta { color: rgb(204, 204, 204); font-weight: 700; font-style: italic; } a { cursor: pointer; } sup.md-footnote { padding: 2px 4px; background-color: rgba(238, 238, 238, 0.7); color: rgb(85, 85, 85); border-radius: 4px; cursor: pointer; } sup.md-footnote a, sup.md-footnote a:hover { color: inherit; text-transform: inherit; text-decoration: inherit; } #write input[type="checkbox"] { cursor: pointer; width: inherit; height: inherit; } figure { overflow-x: auto; margin: 1.2em 0px; max-width: calc(100% + 16px); padding: 0px; } figure > table { margin: 0px !important; } tr { break-inside: avoid; break-after: auto; } thead { display: table-header-group; } table { border-collapse: collapse; border-spacing: 0px; width: 100%; overflow: auto; break-inside: auto; text-align: left; } table.md-table td { min-width: 32px; } .CodeMirror-gutters { border-right: 0px; background-color: inherit; } .CodeMirror-linenumber { user-select: none; } .CodeMirror { text-align: left; } .CodeMirror-placeholder { opacity: 0.3; } .CodeMirror pre { padding: 0px 4px; } .CodeMirror-lines { padding: 0px; } div.hr:focus { cursor: none; } #write pre { white-space: pre-wrap; } #write.fences-no-line-wrapping pre { white-space: pre; } #write pre.ty-contain-cm { white-space: normal; } .CodeMirror-gutters { margin-right: 4px; } .md-fences { font-size: 0.9rem; display: block; break-inside: avoid; text-align: left; overflow: visible; white-space: pre; background: inherit; position: relative !important; } .md-diagram-panel { width: 100%; margin-top: 10px; text-align: center; padding-top: 0px; padding-bottom: 8px; overflow-x: auto; } #write .md-fences.mock-cm { white-space: pre-wrap; } .md-fences.md-fences-with-lineno { padding-left: 0px; } #write.fences-no-line-wrapping .md-fences.mock-cm { white-space: pre; overflow-x: auto; } .md-fences.mock-cm.md-fences-with-lineno { padding-left: 8px; } .CodeMirror-line, twitterwidget { break-inside: avoid; } .footnotes { opacity: 0.8; font-size: 0.9rem; margin-top: 1em; margin-bottom: 1em; } .footnotes + .footnotes { margin-top: 0px; } .md-reset { margin: 0px; padding: 0px; border: 0px; outline: 0px; vertical-align: top; background: 0px 0px; text-decoration: none; text-shadow: none; float: none; position: static; width: auto; height: auto; white-space: nowrap; cursor: inherit; -webkit-tap-highlight-color: transparent; line-height: normal; font-weight: 400; text-align: left; box-sizing: content-box; direction: ltr; } li div { padding-top: 0px; } blockquote { margin: 1rem 0px; } li .mathjax-block, li p { margin: 0.5rem 0px; } li { margin: 0px; position: relative; } blockquote > :last-child { margin-bottom: 0px; } blockquote > :first-child, li > :first-child { margin-top: 0px; } .footnotes-area { color: rgb(136, 136, 136); margin-top: 0.714rem; padding-bottom: 0.143rem; white-space: normal; } #write .footnote-line { white-space: pre-wrap; } @media print { body, html { border: 1px solid transparent; height: 99%; break-after: avoid; break-before: avoid; } #write { margin-top: 0px; padding-top: 0px; border-color: transparent !important; } .typora-export * { -webkit-print-color-adjust: exact; } html.blink-to-pdf { font-size: 13px; } .typora-export #write { padding-left: 32px; padding-right: 32px; padding-bottom: 0px; break-after: avoid; } .typora-export #write::after { height: 0px; } @page { margin: 20mm 0px; } } .footnote-line { margin-top: 0.714em; font-size: 0.7em; } a img, img a { cursor: pointer; } pre.md-meta-block { font-size: 0.8rem; min-height: 0.8rem; white-space: pre-wrap; background: rgb(204, 204, 204); display: block; overflow-x: hidden; } p > .md-image:only-child:not(.md-img-error) img, p > img:only-child { display: block; margin: auto; } p > .md-image:only-child { display: inline-block; width: 100%; } #write .MathJax_Display { margin: 0.8em 0px 0px; } .md-math-block { width: 100%; } .md-math-block:not(:empty)::after { display: none; } [contenteditable="true"]:active, [contenteditable="true"]:focus { outline: 0px; box-shadow: none; } .md-task-list-item { position: relative; list-style-type: none; } .task-list-item.md-task-list-item { padding-left: 0px; } .md-task-list-item > input { position: absolute; top: 0px; left: 0px; margin-left: -1.2em; margin-top: calc(1em - 10px); border: none; } .math { font-size: 1rem; } .md-toc { min-height: 3.58rem; position: relative; font-size: 0.9rem; border-radius: 10px; } .md-toc-content { position: relative; margin-left: 0px; } .md-toc-content::after, .md-toc::after { display: none; } .md-toc-item { display: block; color: rgb(65, 131, 196); } .md-toc-item a { text-decoration: none; } .md-toc-inner:hover { text-decoration: underline; } .md-toc-inner { display: inline-block; cursor: pointer; } .md-toc-h1 .md-toc-inner { margin-left: 0px; font-weight: 700; } .md-toc-h2 .md-toc-inner { margin-left: 2em; } .md-toc-h3 .md-toc-inner { margin-left: 4em; } .md-toc-h4 .md-toc-inner { margin-left: 6em; } .md-toc-h5 .md-toc-inner { margin-left: 8em; } .md-toc-h6 .md-toc-inner { margin-left: 10em; } @media screen and (max-width: 48em) { .md-toc-h3 .md-toc-inner { margin-left: 3.5em; } .md-toc-h4 .md-toc-inner { margin-left: 5em; } .md-toc-h5 .md-toc-inner { margin-left: 6.5em; } .md-toc-h6 .md-toc-inner { margin-left: 8em; } } a.md-toc-inner { font-size: inherit; font-style: inherit; font-weight: inherit; line-height: inherit; } .footnote-line a:not(.reversefootnote) { color: inherit; } .md-attr { display: none; } .md-fn-count::after { content: "."; } code, pre, samp, tt { font-family: var(--monospace); } kbd { margin: 0px 0.1em; padding: 0.1em 0.6em; font-size: 0.8em; color: rgb(36, 39, 41); background: rgb(255, 255, 255); border: 1px solid rgb(173, 179, 185); border-radius: 3px; box-shadow: rgba(12, 13, 14, 0.2) 0px 1px 0px, rgb(255, 255, 255) 0px 0px 0px 2px inset; white-space: nowrap; vertical-align: middle; } .md-comment { color: rgb(162, 127, 3); opacity: 0.8; font-family: var(--monospace); } code { text-align: left; vertical-align: initial; } a.md-print-anchor { white-space: pre !important; border-width: initial !important; border-style: none !important; border-color: initial !important; display: inline-block !important; position: absolute !important; width: 1px !important; right: 0px !important; outline: 0px !important; background: 0px 0px !important; text-decoration: initial !important; text-shadow: initial !important; } .md-inline-math .MathJax_SVG .noError { display: none !important; } .html-for-mac .inline-math-svg .MathJax_SVG { vertical-align: 0.2px; } .md-math-block .MathJax_SVG_Display { text-align: center; margin: 0px; position: relative; text-indent: 0px; max-width: none; max-height: none; min-height: 0px; min-width: 100%; width: auto; overflow-y: hidden; display: block !important; } .MathJax_SVG_Display, .md-inline-math .MathJax_SVG_Display { width: auto; margin: inherit; display: inline-block !important; } .MathJax_SVG .MJX-monospace { font-family: var(--monospace); } .MathJax_SVG .MJX-sans-serif { font-family: sans-serif; } .MathJax_SVG { display: inline; font-style: normal; font-weight: 400; line-height: normal; zoom: 90%; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; } .MathJax_SVG * { transition: none; } .MathJax_SVG_Display svg { vertical-align: middle !important; margin-bottom: 0px !important; } .os-windows.monocolor-emoji .md-emoji { font-family: "Segoe UI Symbol", sans-serif; } .md-diagram-panel > svg { max-width: 100%; } [lang="mermaid"] svg, [lang="flow"] svg { max-width: 100%; } [lang="mermaid"] .node text { font-size: 1rem; } table tr th { border-bottom: 0px; } video { max-width: 100%; display: block; margin: 0px auto; } iframe { max-width: 100%; width: 100%; border: none; } .highlight td, .highlight tr { border: 0px; } .CodeMirror { height: auto; } .CodeMirror.cm-s-inner { background: inherit; } .CodeMirror-scroll { overflow-y: hidden; overflow-x: auto; z-index: 3; } .CodeMirror-gutter-filler, .CodeMirror-scrollbar-filler { background-color: rgb(255, 255, 255); } .CodeMirror-gutters { border-right: 1px solid rgb(221, 221, 221); background: inherit; white-space: nowrap; } .CodeMirror-linenumber { padding: 0px 3px 0px 5px; text-align: right; color: rgb(153, 153, 153); } .cm-s-inner .cm-keyword { color: rgb(119, 0, 136); } .cm-s-inner .cm-atom, .cm-s-inner.cm-atom { color: rgb(34, 17, 153); } .cm-s-inner .cm-number { color: rgb(17, 102, 68); } .cm-s-inner .cm-def { color: rgb(0, 0, 255); } .cm-s-inner .cm-variable { color: rgb(0, 0, 0); } .cm-s-inner .cm-variable-2 { color: rgb(0, 85, 170); } .cm-s-inner .cm-variable-3 { color: rgb(0, 136, 85); } .cm-s-inner .cm-string { color: rgb(170, 17, 17); } .cm-s-inner .cm-property { color: rgb(0, 0, 0); } .cm-s-inner .cm-operator { color: rgb(152, 26, 26); } .cm-s-inner .cm-comment, .cm-s-inner.cm-comment { color: rgb(170, 85, 0); } .cm-s-inner .cm-string-2 { color: rgb(255, 85, 0); } .cm-s-inner .cm-meta { color: rgb(85, 85, 85); } .cm-s-inner .cm-qualifier { color: rgb(85, 85, 85); } .cm-s-inner .cm-builtin { color: rgb(51, 0, 170); } .cm-s-inner .cm-bracket { color: rgb(153, 153, 119); } .cm-s-inner .cm-tag { color: rgb(17, 119, 0); } .cm-s-inner .cm-attribute { color: rgb(0, 0, 204); } .cm-s-inner .cm-header, .cm-s-inner.cm-header { color: rgb(0, 0, 255); } .cm-s-inner .cm-quote, .cm-s-inner.cm-quote { color: rgb(0, 153, 0); } .cm-s-inner .cm-hr, .cm-s-inner.cm-hr { color: rgb(153, 153, 153); } .cm-s-inner .cm-link, .cm-s-inner.cm-link { color: rgb(0, 0, 204); } .cm-negative { color: rgb(221, 68, 68); } .cm-positive { color: rgb(34, 153, 34); } .cm-header, .cm-strong { font-weight: 700; } .cm-del { text-decoration: line-through; } .cm-em { font-style: italic; } .cm-link { text-decoration: underline; } .cm-error { color: red; } .cm-invalidchar { color: red; } .cm-constant { color: rgb(38, 139, 210); } .cm-defined { color: rgb(181, 137, 0); } div.CodeMirror span.CodeMirror-matchingbracket { color: rgb(0, 255, 0); } div.CodeMirror span.CodeMirror-nonmatchingbracket { color: rgb(255, 34, 34); } .cm-s-inner .CodeMirror-activeline-background { background: inherit; } .CodeMirror { position: relative; overflow: hidden; } .CodeMirror-scroll { height: 100%; outline: 0px; position: relative; box-sizing: content-box; background: inherit; } .CodeMirror-sizer { position: relative; } .CodeMirror-gutter-filler, .CodeMirror-hscrollbar, .CodeMirror-scrollbar-filler, .CodeMirror-vscrollbar { position: absolute; z-index: 6; display: none; } .CodeMirror-vscrollbar { right: 0px; top: 0px; overflow: hidden; } .CodeMirror-hscrollbar { bottom: 0px; left: 0px; overflow: hidden; } .CodeMirror-scrollbar-filler { right: 0px; bottom: 0px; } .CodeMirror-gutter-filler { left: 0px; bottom: 0px; } .CodeMirror-gutters { position: absolute; left: 0px; top: 0px; padding-bottom: 30px; z-index: 3; } .CodeMirror-gutter { white-space: normal; height: 100%; box-sizing: content-box; padding-bottom: 30px; margin-bottom: -32px; display: inline-block; } .CodeMirror-gutter-wrapper { position: absolute; z-index: 4; background: 0px 0px !important; border: none !important; } .CodeMirror-gutter-background { position: absolute; top: 0px; bottom: 0px; z-index: 4; } .CodeMirror-gutter-elt { position: absolute; cursor: default; z-index: 4; } .CodeMirror-lines { cursor: text; } .CodeMirror pre { border-radius: 0px; border-width: 0px; background: 0px 0px; font-family: inherit; font-size: inherit; margin: 0px; white-space: pre; word-wrap: normal; color: inherit; z-index: 2; position: relative; overflow: visible; } .CodeMirror-wrap pre { word-wrap: break-word; white-space: pre-wrap; word-break: normal; } .CodeMirror-code pre { border-right: 30px solid transparent; width: fit-content; } .CodeMirror-wrap .CodeMirror-code pre { border-right: none; width: auto; } .CodeMirror-linebackground { position: absolute; left: 0px; right: 0px; top: 0px; bottom: 0px; z-index: 0; } .CodeMirror-linewidget { position: relative; z-index: 2; overflow: auto; } .CodeMirror-wrap .CodeMirror-scroll { overflow-x: hidden; } .CodeMirror-measure { position: absolute; width: 100%; height: 0px; overflow: hidden; visibility: hidden; } .CodeMirror-measure pre { position: static; } .CodeMirror div.CodeMirror-cursor { position: absolute; visibility: hidden; border-right: none; width: 0px; } .CodeMirror div.CodeMirror-cursor { visibility: hidden; } .CodeMirror-focused div.CodeMirror-cursor { visibility: inherit; } .cm-searching { background: rgba(255, 255, 0, 0.4); } @media print { .CodeMirror div.CodeMirror-cursor { visibility: hidden; } } :root { --side-bar-bg-color: #fafafa; --control-text-color: #777; } html { font-size: 16px; } body { font-family: "Open Sans", "Clear Sans", "Helvetica Neue", Helvetica, Arial, sans-serif; color: rgb(51, 51, 51); line-height: 1.6; } #write { max-width: 860px; margin: 0px auto; padding: 30px 30px 100px; } #write > ul:first-child, #write > ol:first-child { margin-top: 30px; } a { color: rgb(65, 131, 196); } h1, h2, h3, h4, h5, h6 { position: relative; margin-top: 1rem; margin-bottom: 1rem; font-weight: bold; line-height: 1.4; cursor: text; } h1:hover a.anchor, h2:hover a.anchor, h3:hover a.anchor, h4:hover a.anchor, h5:hover a.anchor, h6:hover a.anchor { text-decoration: none; } h1 tt, h1 code { font-size: inherit; } h2 tt, h2 code { font-size: inherit; } h3 tt, h3 code { font-size: inherit; } h4 tt, h4 code { font-size: inherit; } h5 tt, h5 code { font-size: inherit; } h6 tt, h6 code { font-size: inherit; } h1 { padding-bottom: 0.3em; font-size: 2.25em; line-height: 1.2; border-bottom: 1px solid rgb(238, 238, 238); } h2 { padding-bottom: 0.3em; font-size: 1.75em; line-height: 1.225; border-bottom: 1px solid rgb(238, 238, 238); } h3 { font-size: 1.5em; line-height: 1.43; } h4 { font-size: 1.25em; } h5 { font-size: 1em; } h6 { font-size: 1em; color: rgb(119, 119, 119); } p, blockquote, ul, ol, dl, table { margin: 0.8em 0px; } li > ol, li > ul { margin: 0px; } hr { height: 2px; padding: 0px; margin: 16px 0px; background-color: rgb(231, 231, 231); border: 0px none; overflow: hidden; box-sizing: content-box; } li p.first { display: inline-block; } ul, ol { padding-left: 30px; } ul:first-child, ol:first-child { margin-top: 0px; } ul:last-child, ol:last-child { margin-bottom: 0px; } blockquote { border-left: 4px solid rgb(223, 226, 229); padding: 0px 15px; color: rgb(119, 119, 119); } blockquote blockquote { padding-right: 0px; } table { padding: 0px; word-break: initial; } table tr { border-top: 1px solid rgb(223, 226, 229); margin: 0px; padding: 0px; } table tr:nth-child(2n), thead { background-color: rgb(248, 248, 248); } table tr th { font-weight: bold; border-width: 1px 1px 0px; border-top-style: solid; border-right-style: solid; border-left-style: solid; border-top-color: rgb(223, 226, 229); border-right-color: rgb(223, 226, 229); border-left-color: rgb(223, 226, 229); border-image: initial; border-bottom-style: initial; border-bottom-color: initial; text-align: left; margin: 0px; padding: 6px 13px; } table tr td { border: 1px solid rgb(223, 226, 229); text-align: left; margin: 0px; padding: 6px 13px; } table tr th:first-child, table tr td:first-child { margin-top: 0px; } table tr th:last-child, table tr td:last-child { margin-bottom: 0px; } .CodeMirror-lines { padding-left: 4px; } .code-tooltip { box-shadow: rgba(0, 28, 36, 0.3) 0px 1px 1px 0px; border-top: 1px solid rgb(238, 242, 242); } .md-fences, code, tt { border: 1px solid rgb(231, 234, 237); background-color: rgb(248, 248, 248); border-radius: 3px; padding: 2px 4px 0px; font-size: 0.9em; } code { background-color: rgb(243, 244, 244); padding: 0px 2px; } .md-fences { margin-bottom: 15px; margin-top: 15px; padding-top: 8px; padding-bottom: 6px; } .md-task-list-item > input { margin-left: -1.3em; } @media print { html { font-size: 13px; } table, pre { break-inside: avoid; } pre { word-wrap: break-word; } } .md-fences { background-color: rgb(248, 248, 248); } #write pre.md-meta-block { padding: 1rem; font-size: 85%; line-height: 1.45; background-color: rgb(247, 247, 247); border: 0px; border-radius: 3px; color: rgb(119, 119, 119); margin-top: 0px !important; } .mathjax-block > .code-tooltip { bottom: 0.375rem; } .md-mathjax-midline { background: rgb(250, 250, 250); } #write > h3.md-focus::before { left: -1.5625rem; top: 0.375rem; } #write > h4.md-focus::before { left: -1.5625rem; top: 0.285714rem; } #write > h5.md-focus::before { left: -1.5625rem; top: 0.285714rem; } #write > h6.md-focus::before { left: -1.5625rem; top: 0.285714rem; } .md-image > .md-meta { border-radius: 3px; padding: 2px 0px 0px 4px; font-size: 0.9em; color: inherit; } .md-tag { color: rgb(167, 167, 167); opacity: 1; } .md-toc { margin-top: 20px; padding-bottom: 20px; } .sidebar-tabs { border-bottom: none; } #typora-quick-open { border: 1px solid rgb(221, 221, 221); background-color: rgb(248, 248, 248); } #typora-quick-open-item { background-color: rgb(250, 250, 250); border-color: rgb(254, 254, 254) rgb(229, 229, 229) rgb(229, 229, 229) rgb(238, 238, 238); border-style: solid; border-width: 1px; } .on-focus-mode blockquote { border-left-color: rgba(85, 85, 85, 0.12); } header, .context-menu, .megamenu-content, footer { font-family: "Segoe UI", Arial, sans-serif; } .file-node-content:hover .file-node-icon, .file-node-content:hover .file-node-open-state { visibility: visible; } .mac-seamless-mode #typora-sidebar { background-color: var(--side-bar-bg-color); } .md-lang { color: rgb(180, 101, 77); } .html-for-mac .context-menu { --item-hover-bg-color: #E6F0FE; } #md-notification .btn { border: 0px; } .dropdown-menu .divider { border-color: rgb(229, 229, 229); } .typora-export li, .typora-export p, .typora-export, .footnote-line {white-space: normal;} 学生目录：Markdown一二三四与 五六七八九十1. 引文、注释2. 链接3. 图片4. 简单表格5.高亮、顔色等6. 列表、代码块前往我的Blog首页↩&nbsp;一二三四与 五六七八九十&nbsp;1. 引文、注释「拉威福特的《因斯茅斯上空的阴影》1尝起来，就像是在啜饮生鱼血一样呢~」（啦啦啦啦啦啦啦啦啦啦啦哇哈哈哈哈哈哈）&nbsp;&nbsp;2. 链接百度百科: 拉威福特详情&nbsp;3. 图片&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;4. 简单表格&nbsp;快捷键功能Ctrl+C复制Ctrl+X剪切Ctrl+V粘贴&nbsp;5.高亮、顔色等&nbsp;「关于作者霍华德·菲利普·拉威福特，他是1890年生的美国作家，他在世时曾经写下了许多关于太古诸神复活的故事，这些故事在他去世以后被体系化，最终形成了所谓的『克苏鲁神话体系』。自那以来，有很多作家被这种阴暗凄惨的黑暗神话所吸引，以克苏鲁为主题写下了不计其数的文章呢。在故事中登场的诸神，都是长相奇怪的海洋生物，长着触手、鱼鳍啊什么的，散发着生腥味。」&nbsp;6. 列表、代码块&nbsp;html jsjavapython等等xxxxxxxxxx41&lt;span class="post-meta-item-text"&gt;评论数：2 &lt;a href="/2019/06/13/markdown练习/#comments" itemprop="discussionUrl"&gt;3 &lt;/a&gt;4 &lt;/span&gt;&nbsp;前往我的Blog首页↩&nbsp; 1 拉威福特，全名H. P. Lovecraft，1890-1937，恐怖小说作家，《因斯茅斯上空的阴影》（The Shadow Over Innsmouth），为其代表作之一。↩]]></content>
      <categories>
        <category>学习经验</category>
      </categories>
      <tags>
        <tag>-markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Yahoo~!]]></title>
    <url>%2F2019%2F06%2F11%2FYahoo%2F</url>
    <content type="text"><![CDATA[域名&amp;..第一个公网访问的博客改造ing，是基于nodejs的一个网站，用来记一些东西吧，也方便查看。外观风格想做简约可又喜欢乱加东西，搞得不是很美观，暂时用别人的主题做基础，以后慢慢弄吧。现在域名为 Shirtiny.cn 6.13 增加标签、友链、分类、归档、404页面、搜索功能 6.17 增加头像挂件、社交链接 6.18 增加看板娘【随便拉来打工的】 7.16 调整整体色调、不由自主的加了些挂件、增加Valine评论系统 7.29 把Valine换成Gitment【越来越懒】 8.03 拉出来改了下bug、尝试调试移动端适配（放弃）、追加内建标签【想换Spring Boot做了】 8.06 增加视频播放标签 8.23 增设一台服务器，使用子域名server.shirtiny.cn，ip不定 域名购买： 腾讯云 域名解析： DNSPOD 搭建Hexo：哔哩哔哩教程 域名绑定：CN博客教程 解决部署使：CName消失的问题]]></content>
      <categories>
        <category>闲谈</category>
      </categories>
      <tags>
        <tag>开局第一篇 - 测试</tag>
      </tags>
  </entry>
</search>
