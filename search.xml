<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[React Native 与 Expo]]></title>
    <url>%2F2020%2F08%2F28%2FReact-Native-%E4%B8%8E-Expo%2F</url>
    <content type="text"><![CDATA[使用JavaScript构建原生移动端应用React Native 与 Expo React Native由Facebook开源， 是目前流行的跨平台移动应用开发框架之一，与React一样为组件式，熟悉前端的开发人员可以快速上手。 Expo包含一组工具、库和服务， 在React Native的基础上做了很多的设置与简化，可以快速上手项目同时为开发提供了多种便利的服务，也可以让我们使用自己喜欢的编辑器来写代码。 初始化项目开发环境 12# node 12以上# yarn/npm/cnpm 安装expo cli 123# 网慢用淘宝的 cnpm i expo-cli -gnpm i expo-cli -gexpo --version 创建项目 123expo init 项目名# 可以先选blank 熟悉一下项目初始化的流程# 如果安装js依赖失败但提示项目already 可以手动进入到项目运行yarn 或者 npm i 运行项目 123# 先进入到项目中yarn start# 或 npm start 点击左下方的Run in web browser即可在浏览器端打开项目。 连接Android使用自己的手机 先到官网下载安卓版的Expo Client安装包，在自己手机上装好。让手机和电脑在同一个局域网内，打开手机端的客户端，扫描浏览器左下方或者控制台出现的二维码即可（启动后需要等一会儿左下角才会出现二维码）。 使用模拟器 下载Android Studio，官网。 安装，选标准安装，一直下一步即可，如果提示Setup Proxy，点击cancel，最后等待下载安装完成。 SDK Manager里可以查看和安装Android SDK，如果是标准安装的话，不用动。 创建模拟器 选择AVD Manager进入模拟器管理页面，点击Create Virtual Device然后选择一个带有谷歌套件的系统（我用的Pixel 3a, Q），然后启动模拟器即可，等待模拟器开机完成。 连接到模拟器模拟器启动完成后，在运行中的Expo控制台按a键，或者浏览器端左下角点击Run on Android即可连接到模拟器，它会自动先安装一个Expo Cilent给模拟器，如果提示安装失败，就手动从官网下一个apk安装包，手动安装到模拟器（直接把安装包拖到模拟器即可），再重新连接到模拟器即可。ctrl + m 可以打开开发者菜单 远程调试可以在Chrome或Vscode中对程序debug chrome：启用开发者菜单中的Debug Remote JS，会自动打开chrome，可在chrome中debug。 vscode：先下载React native tools扩展，等待安装完成。同样启用开发者菜单中的Debug Remote JS，关闭chrome，然后在vscode中进入调试页面，点击左侧的创建文件，然后在下拉菜单中选择React Native，调试配置项只选择Attach to packager。在打开的launch.json文件中，添加一个configuration，输入react native在提示中选择Debug Android。该文件会保存在项目根目录的.vscode文件夹内，最终的文件内容： 123456789101112131415161718192021&#123; // 使用 IntelliSense 了解相关属性。 // 悬停以查看现有属性的描述。 // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387 "version": "0.2.0", "configurations": [ &#123; "name": "Debug Android", "cwd": "$&#123;workspaceFolder&#125;", "type": "reactnative", "request": "launch", "platform": "android" &#125;, &#123; "name": "Attach to packager", "cwd": "$&#123;workspaceFolder&#125;", "type": "reactnative", "request": "attach" &#125; ]&#125; 打开vscode的设置，搜索react-native.packager.port，将值改为19001，和上面chrome调试页同样的端口号。最后启动调试即可。]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[金木犀]]></title>
    <url>%2F2020%2F08%2F18%2F%E9%87%91%E6%9C%A8%E7%8A%80%2F</url>
    <content type="text"><![CDATA[[00:00.000] 金木犀 feat.Ado [00:14.699] " If today wer the last day of my life, " [00:15.196] " would I want to do what I am about to do today ? " [00:16.415] " ? " [00:17.103] ( * Drop it ) [00:32.896] 事到如今才来回答 [00:35.094] 但那些事已经无所谓了 [00:37.111] 只会再陷入忧愁的涟漪重复着聚拢散开 [00:40.905] 落下的烟头 伏在地面上的回忆 [00:46.500] 拾起收集 [00:48.712] 味同嚼蜡的cookie coin laundry， 像是笨蛋一样的hamburger [00:52.500] 画满涂鸦的排气管 心中充满苦涩 再见吧 [00:56.511] 你那握着电车吊环的手 [01:00.305] 我已忘记了它的温暖 [01:03.400] 「别把我一个人留在 黄昏里 」、 在播放着唱片时说出这话的 [01:06.212] 那一天 [01:07.300] 飘飘然 幸福的生活也好 [01:12.000] 金木犀的香味也好 我也好 [01:14.003] 就这样 [01:15.500] 再一次 [01:16.400] 永别吧 [01:25.804] (* Drop it) [01:33.618] 在狭小的窗边 有着半透明的空白 [01:37.518] 远处的某人照亮了我 [01:41.522] 无法填补的缺口要怎么办 什么的、 [01:43.521] 平交道口 今天也好像在哭泣似的 [01:48.312] 我那样的感觉到了 [02:04.686] 「别把我一个人留在 黄昏里 」、 在播放着唱片时说出这话的 [02:06.921] 那一天 [02:08.000] 飘飘然 幸福的生活也好 [02:12.715] 金木犀的香味也好 我也好 [02:14.522] 就这样 [02:15.997] 再一次 [02:17.292] 永别吧 var ap = new APlayer({ element: document.getElementById("aplayer-hrRrXUoQ"), narrow: false, autoplay: false, showlrc: 2, music: { title: "金木犀", author: "Ado", url: "https://sh-rep.oss-cn-hongkong.aliyuncs.com/%E9%87%91%E6%9C%A8%E7%8A%80.aac", pic: "/2020/08/18/金木犀/金木犀.png", } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap);]]></content>
      <categories>
        <category>音乐</category>
      </categories>
      <tags>
        <tag>音乐</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[時を刻む唄]]></title>
    <url>%2F2020%2F08%2F12%2F%E6%99%82%E3%82%92%E5%88%BB%E3%82%80%E5%94%84%2F</url>
    <content type="text"><![CDATA[var ap = new APlayer({ element: document.getElementById("aplayer-asKJlgUj"), narrow: false, autoplay: false, showlrc: false, music: { title: "時を刻む唄", author: "Oturans", url: "https://sh-rep.oss-cn-hongkong.aliyuncs.com/%E6%99%82%E3%82%92%E5%88%BB%E3%82%80%E5%94%84.mp3", pic: "/2020/08/12/時を刻む唄/時を刻む唄.jpg", lrc: "" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap);]]></content>
      <categories>
        <category>音乐</category>
      </categories>
      <tags>
        <tag>音乐</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL复习基础语句速览]]></title>
    <url>%2F2020%2F08%2F07%2FMySQL%E5%A4%8D%E4%B9%A0%E5%9F%BA%E7%A1%80%E8%AF%AD%E5%8F%A5%E9%80%9F%E8%A7%88%2F</url>
    <content type="text"><![CDATA[MySQL基础速览数据库快忘掉了，回头再总结一下常用语句，还有事务的一些基础知识。 增加12345678#插入单行insert into user(name,pwd) values('shirtiny','123');#将现有表数据 插入到一个已有表insert into user(name,pwd) select name,pwd from user;#将现有表数据 插入到新建表select name,pwd into user2 from user;#合并数据插入多行insert user(name, pwd) select 'shirtiny','123' union select 'anro','123' 删除1234#删除满足条件的行delete from user where name = 'shirtiny'#删除整个表truncate table user; 修改12#修改 满足条件的行update user set name='anro',pwd='123' where name = 'shirtiny'; 查询distinct排除重复 12select distinct name from teacher;-- 这样会如果有同名的老师，相同名字只会查出一条 between x and y查出x到y范围内的记录 123select * from student where score between 60 and 100;-- 这样会查出分数在60到100的学生，相当于：select * from student where score &gt; 60 and score &lt; 100; in查询多个值，或的关系 1234select * from student where score in(60,70,80);-- 查出分数是60、70、80的学生select * from student where class not in(1, 2);-- 查询班级不是1班和2班的学生 or表示或者 12select * from student where score = 70 or score = 80;-- 查出分数是70、80的学生 order by ... asc/desc升序、降序 12345select * from student order by age asc;select * from student order by score desc;-- 分别以年龄升序、分数降序查询学生，如果需要多个字段同时排序：select * from student order by age asc, score desc;-- 会先按照年龄升序，年龄相同时，按照分数降序 count统计和计数 12select count(*) from student where score = 60;-- 查出分数为60的学生数 max得出某字段的最大值 12select max(score) from student;-- 查出学生分数的最高值 子查询，可以使用括号来嵌入一个子查询 12select name,age from student where score = (select max(score) from student);-- 查出分数最高的学生的名字和年龄 limit x,y，从x开始查询y个 12select name,age from student order by score desc limit 0,10;-- 先把学生按照分数降序排列，然后取前10个，得到分数前10的学生 avg计算平均值 12select avg(score) from student where class = 1;-- 计算1班学生的平均成绩 group by ... having分组 1234select avg(score) from student group by class;-- 列出每个班学生的平均成绩select avg(score) from student group by class having age&gt;16;-- 查询每个班的学生平均成绩 筛选出年龄大于16的学生 like模糊查询 1234select avg(score) from student group by class having age&gt;16 and name like '王%';-- 查询每个班的学生平均成绩 筛选出年龄大于16并且姓王的学生select avg(score) from student group by class having age&gt;16 and name not like '王%';-- 查询每个班的学生平均成绩 筛选出年龄大于16并且不姓王的学生 多表查询 12select cname,sname,score from course,student where course.cid=student.cid;-- 同时查询课程和学生这两张表，同样的方法也可以查3张表，加个and year得出时间字段的年份，now得出当前日期和时间 1234select * from student where year(birthday) = 1998;-- 查出所有在1998年出生的学生select year(now()) - year(birthday) from student;-- 查出所有学生的年龄，当前时间的年份减去生日的年份 union将两个查询语句的结果合并 12345select * from class1 union select * from class2;-- 将显示班级1和班级2的学生，但重名的学生只会显示一个，比如有2个班共有3个李华，但只会显示1个李华-- 请注意，UNION 内部的 SELECT 语句必须拥有相同数量的列。列也必须拥有相似的数据类型。同时，每条 SELECT 语句中的列的顺序必须相同。默认地，UNION 操作符选取不同的值。如果允许重复的值，请使用 UNION ALL。select * from class1 union all select * from class2;-- 将显示2个班的学生，重名的也会显示 as取别名 1234select sname as name,age from student union all select tname,age from teacher;-- 查询结果的第一列将以name为字段名select name as '姓名', year(now()) - year(birthday) as '年龄' from student;-- 查出所有学生的姓名和年龄 any(子查询语句)表示子查询语句结果的任何一个值 12select * from student where age &gt; any(select age from student where name in ('李华', 'Tom'));-- 查找满足 年龄比李华或Tom年龄大的学生 all(子查询语句)表示子查询语句结果的全部值 12select * from student where age &gt; all(select age from student where name in ('李华', 'Tom'));-- 查找满足 年龄比李华或tom年龄都大的学生 链接查询 1234567891011-- 内连接查询 inner join ，inner可省略 ，比如查出有班级的所有学生select * from student join class on student.cid = class.cid;-- 左外连接 left outer join， outer可省略，比如查出所有学生包括没有班级的学生，此时没有班级的那部分学生班级会补nullselect * from student left join class on student.cid = class.cid;-- 右外连接 right outer join，outer可省略，比如查出所有班级，包括没有学生的班级，此时没有学生的那部分班级会补nullselect * from student right join class on student.cid = class.cid;-- 全外连接查询 msyql没有full join，但可以使用左外连接+union+右外链接来实现全连接select * from student left join class on student.cid = class.cid union select * from student right join class on student.cid = class.cid;-- 可以用别名代替表名select * from student s join class c on s.cid = c.cid;-- 更直观的可以看图 https://blog.csdn.net/zjt980452483/article/details/82945663 事务感受一下什么是事务 1234567891011-- 关闭mysql的自动提交，不关会自动提交每条sql，rollback无效的 （应用中不需要关，这里是玩set autocommit = 0;-- 之后的sql需要手动提交，才会真实的在数据库中生效insert into student values(10,'lihua',16,78);-- 回滚 撤销未提交的sqlrollback;insert into student values(10,'李华',16,78);-- 手动提交 提交后无法再撤销commit;-- 把自动提交改回来set autocommit = 1; begin或start transaction可以开启一个事务 12345678910111213-- 开启事务 begin和start transaction都行begin;insert into student values(10,'lihua',16,78);update student set age = 21 where sid = 10;-- 可以rollback 撤销事务并结束rollback;-- 再开启一个事务start transaction;insert into student values(10,'李华',16,78);update student set age = 20 where sid = 10;-- 提交后结束事务commit; 事务的四大特征 ACID 1234A 原子性C 一致性 事务内的sql必须同时成功或失败I 隔离性D 持久性 一旦结束（commit和rollback），就不可返回 事务的隔离级别 1234567-- 查看数据库的隔离级别-- mysql 8.0 系统、会话select @@global.transaction_isolation;select @@transaction_isolation;-- mysql 5.x 系统、会话select @@global.tx_isolation;select @@tx_isolation; read uncommitted 123--修改数据库的隔离级别 为read uncommittedset global transaction isolation level read uncommitted;-- 此时事务a可以读到事务b未commit的数据，一旦b事务rollback，a的事务就会受到影响 就会出现脏读：事务a读到了事务b未commit的数据 read committed 123-- 修改数据库的隔离级别 为read committedset global transaction isolation level read committed;-- 此时事务a只能读到事务b commit后的数据，但读的数据前后可能会发生改变，因为b可能对表做了修改 会出现不可重复读：读取同一个表的数据，发现前后不一致 repeatable read可重复读 123-- 修改数据库的隔离级别 为repeatable readset global transaction isolation level repeatable read;-- 此时即使事务b对表插入了id为1的一行记录，事务a也不会察觉到表发生了改变 会出现幻读：事务a明明看到表没有变化，但无法插入id为1的行 serializable串行化 123-- 修改数据库的隔离级别 为serializableset global transaction isolation level serializable;-- 此时类似线程同步，事务a对表操作时，事务b对这个表的操作会排在a后面，a提交后，b的操作才会被执行 性能很差。 隔离与锁有关，隔离级别越高性能越差，未提交读取 &gt; 已提交读取 &gt; 可重复读取 &gt; 串行化mysql默认为可重复读取]]></content>
      <categories>
        <category>学习经验</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React项目Travis CI持续集成]]></title>
    <url>%2F2020%2F07%2F02%2FReact%E9%A1%B9%E7%9B%AETravis-CI%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%2F</url>
    <content type="text"><![CDATA[使用Travis CI 持续集成部署开源项目Travis CI是Github的好基友，是一个CI/CD的免费工具。可以自动化的进行项目的测试、打包等。不同于本机运行的Jenkins，Travis提供了云服务器来帮助我们完成自动化流程。 前置工作 一个Github项目 注册Travis CI，使用Github账号授权即可 步骤1. 使用Github Pages服务 如果是Create-React-App的话，package.json添加homepage字段 123456"private": false,"homepage": "./","repository": &#123; "type": "git", "url": "https://github.com/Shirtiny/SubEditor"&#125;, 安装gh-pages 12#yarn add gh-pages -Dnpm install gh-pages -D 设置scripts 12345678"scripts": &#123; "start": "react-scripts start", "build": "react-scripts build(你的dist目录)", "test": "react-scripts test", "eject": "react-scripts eject", "predeploy": "npm run build", "deploy": "gh-pages -d build(你的dist目录)" &#125;, 自定域名，在gh-pages分支根目录，添加CNAME，例如自定域名subeditor.js.org 1subeditor.js.org 最后打开Github pages服务，选择使用gh-pages分支。 2. 创建GitHub Access Token 这里使用了Github pages服务，需要push内容到仓库，需要提供 Access Token 来授权。 前往：GitHub-&gt;Settings-&gt;Developer Settings-&gt;Personal access tokens 勾选repo、user，然后点击Generate Token即可。记住token，后面会用到 使用Travis CI 注册Travis CI完成后，点击左侧加号新建项目，搜索你的项目名 点击开关开启对项目的监控 点击Setting，在此处设置环境变量GithubToken，值为刚刚的token。输入完毕后点击Add Github用户名 Github邮箱 Github仓库名 在项目根目录添加文件.travis.yml，内容为： 1234567891011121314151617181920language: node_js# node版本 node -vnode_js: "12.14.0"#缓存依赖cache: directories: - node_modulesinstall: - npm ibefore_script: - git config user.name "$&#123;UserName&#125;" - git config user.email "$&#123;UserEmail&#125;" - git remote rm origin - git remote add origin https://$&#123;UserName&#125;:$&#123;GithubToken&#125;@github.com/$&#123;RepName&#125; - git remote -vscript: npm run deploy# 只有指定的分支提交时才会运行脚本branches: only: - master Travis CI的一次构建分两个步骤： install安装，安装任何所需的依赖 script脚本，运行构建脚本 Travis CI提供了一些构建生命周期的“钩子” 一个完整的 Travis CI 构建生命周期： OPTIONAL Install apt addons OPTIONAL Install cache components before_install install before_script script OPTIONAL before_cache(for cleaning up cache) after_success or after_failure OPTIONAL before_deploy OPTIONAL deploy OPTIONAL after_deploy after_script 在 before_install、before_script之前，或者after_script之后，都可以运行自定义命令，详细资料可参考官方文档：Job Lifecycle 还有个可以参考，这样来保留git日志： 123456789101112131415161718192021222324language: node_jsnode_js: "12.14.0"cache: directories: - node_modulesinstall: - npm iscript: - npm run buildafter_script: - git clone https://github.com/$&#123;RepName&#125; .temp - cd .temp - git checkout gh-pages - cd ../ - mv .temp/.git dist - cd dist - git config user.name "$&#123;UserName&#125;" - git config user.email "$&#123;UserEmail&#125;" - git add . - git commit -m "Build &amp; Deploy by Travis CI" - git push --force --quiet "https://$&#123;GithubToken&#125;@github.com/$&#123;RepName&#125;" gh-pages:$&#123;D_BRANCH&#125;branches: only: - master Git提交更改并push 123git add .git commit -m "create .travis.yml"git push 仓库更新后，Travis会自动构建，查看build日志]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>Travis CI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mpvue开发微信小程序]]></title>
    <url>%2F2020%2F07%2F01%2Fmpvue%E5%BC%80%E5%8F%91%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[使用mpvue开发微信小程序mpvue，方便的使用vue语法开发微信小程序。 我回来了，半年没更新了。用React做了个字幕编辑器，但感觉实际意义不大。 0. 环境首先确保本地已安装nodejs 123# 查看本地node、npm版本node -vnpm -v vue-cli 123# 安装vue脚手架npm i -g vue-cli -Dvue -V 1. 初始化项目创建 123# 项目名为 shmp# cd D:\programming\JsProjectvue init mpvue/mpvue-quickstart shmp 按提示回车确认即可，中间需要小程序的appid 运行 123cd shmpnpm inpm run dev 2. 导入到微信开发工具首先需要安装微信开发工具，然后运行。 导入项目 点击导入项目，选择mpvue项目的目录即可 在微信开发工具查看效果 mpvue输出在dist目录下 3. 其他如使用scss 123npm i sass-loader@7.3.1 node-sass -D# node-sass如果安装失败 可以尝试更换国内源# npm config set sass_binary_site=https://npm.taobao.org/mirrors/node-sass 123456789101112131415161718192021222324&lt;style lang="scss" scoped&gt;.container &#123; display: flex; height: 100vh; width: 100vw; justify-content: center; align-items: center; .innerBox &#123; display: flex; flex-direction: column; justify-content: flex-start; align-items: center; .boxTitle &#123; font-weight: bold; font-size: 24px; margin-bottom: 30vh; &#125; .boxContent &#123; justify-content: center; align-items: center; &#125; &#125;&#125;&lt;/style&gt; 取消eslint格式检测 前往：build&gt;webpack_base_conf.js，注释掉eslint-loader 12345678910111213141516module: &#123; rules: [ // &#123; // test: /\.(js|vue)$/, // loader: 'eslint-loader', // enforce: 'pre', // include: [resolve('src'), resolve('test')], // options: &#123; // formatter: require('eslint-friendly-formatter') // &#125; // &#125;, &#123; test: /\.vue$/, loader: "mpvue-loader", options: vueLoaderConfig, &#125;, 提示prettier版本过低 移除项目中的prettier依赖，重新安装 12npm uninstall prettiernpm i prettier -D 使用小程序客户端腾讯云增强SDK 1npm i -S wafer2-client-sdk 文档]]></content>
      <categories>
        <category>学习经验</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
        <tag>mpvue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[创建企业邮箱]]></title>
    <url>%2F2019%2F12%2F18%2F%E5%88%9B%E5%BB%BA%E4%BC%81%E4%B8%9A%E9%82%AE%E7%AE%B1%2F</url>
    <content type="text"><![CDATA[创建企业邮箱并集成到项目有些业务需要使用邮箱来完成，这时使用Gmail或qq等个人邮箱就不合适了。需要一个企业自用的邮箱域名，使用自定域名的邮箱，来处理企业的业务。 我在这份md中介绍了，如何使用腾讯企业邮来创建企业邮箱，如何自定域名，以及在项目中的使用。 1. 注册Google搜索关键字腾讯企业邮箱，或点此前往腾讯企业邮首页。 选择免费版，点击立即开通。（视实际情况选择专业版） 选择开通方式，第一次使用选左边，点击开通。 点击下一步，然后填写表单，微信扫描二维码进行授权和绑定，记得勾选同意协议，然后点击注册按钮。 2. 自定域名 注册完成后，会自动分配一个临时域名，点击顶部黄条提示，去添加自定域名 点击添加企业域名 输入你的域名，或者买个新域名 如果是在腾讯云买的域名，会自动添加解析记录，也可以去自己域名提供商那里，找域名解析服务，手动添加记录 添加域名解析记录为 3. 添加成员 添加一个成员，比如添加一个张先生用的邮箱 点击邀请，即可发送短信通知张先生，让他上线激活邮箱，也可以使用微信邀请。 4. 简单的使用 使用“邮我”功能，可以得到一个连接，能让用户通过此连接来发送邮件给当前邮箱。不过用户需要使用QQ邮箱。 得到的连接： 123连接： http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&amp;email=w7Crg7CrqrG3qq267aCt加个a标签： &lt;a target="_blank" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&amp;email=w7Crg7CrqrG3qq267aCt" style="text-decoration:none;"&gt;给我写信&lt;/a&gt; 5. 项目开发使用 首先开启IMAP/SMTP服务、POP/SMTP服务 一些参数的说明： 集成到springBoot项目中 需要注意上图的如下参数： 1234567891011#POP3/SMTP协议 我的项目中只需要发邮件，SMTP即可接收邮件服务器：pop.exmail.qq.com ，使用SSL，端口号995发送邮件服务器：smtp.exmail.qq.com ，使用SSL，端口号465#海外用户可使用以下服务器接收邮件服务器：hwpop.exmail.qq.com ，使用SSL，端口号995发送邮件服务器：hwsmtp.exmail.qq.com ，使用SSL，端口号465#授权信息账户名：您的企业邮箱账户名，账户名需要填写完整的邮箱地址密码：您的企业邮箱密码电子邮件地址：您的企业邮箱的完整邮件地址 IMAP和POP3/SMTP协议：两者最大的区别在于，IMAP允许双向通信，即在客户端的操作会反馈到服务器上，例如在客户端收取邮件、标记已读等操作，服务器会跟着同步这些操作。POP3/SMTP常用于“离线”邮件处理，即允许客户端下载服务器邮件，然后服务器上的邮件将会被删除，但是在客户端的操作并不会同步到服务器上面的，例如在客户端收取或标记已读邮件，服务器不会同步这些操作。 对应的spring配置参数如下： application.properties 123456789101112131415161718192021#qq邮箱收发邮件#发送邮件的服务器spring.mail.host=smtp.exmail.qq.com#对应端口号spring.mail.port=465#用户名（完整的邮箱地址） spring.mail.username=xx@xx.xx#密码spring.mail.password=你的企业邮箱密码#配置ssl加密 用于加密传输授权信息spring.mail.properties.mail.smtp.auth=truespring.mail.properties.mail.smtp.starttls.enable=truespring.mail.properties.mail.smtp.starttls.required=truespring.mail.properties.mail.smtp.ssl.enable=true#超时spring.mail.properties.mail.smtp.connectiontimeout=5000spring.mail.properties.mail.smtp.timeout=3000spring.mail.properties.mail.smtp.writetimeout=5000#from 发信邮箱的地址 这个不属于配置SH_Mail_From=sh@shirtiny.cn application.yml 123456spring: mail: host: smtp.exmail.qq.com port: 465 username: xx@xx.xx password: 你的企业邮箱密码 导入Maven依赖 12345&lt;!-- 邮件--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt; &lt;/dependency&gt; 发送两种类型的邮件 12345678910111213141516171819202122232425262728293031323334353637@Servicepublic class MailServiceImpl implements ImailService &#123; @Autowired private JavaMailSender javaMailSender; @Value("$&#123;SH_Mail_From&#125;") private String shMailFrom; //简单邮件 标题 内容 @Override public void sendSimpleMail() &#123; SimpleMailMessage simpleMailMessage = new SimpleMailMessage(); simpleMailMessage.setFrom(shMailFrom); simpleMailMessage.setTo("sssss111@xxx.com"); simpleMailMessage.setSubject("主题"); simpleMailMessage.setText("内容"); javaMailSender.send(simpleMailMessage); &#125; //复杂邮件 支持html,抄送,密送等 可以携带附件 文内可以嵌入静态资源 @Override public void sendComplexMail() throws MessagingException &#123; MimeMessage mimeMessage = javaMailSender.createMimeMessage(); MimeMessageHelper helper = new MimeMessageHelper(mimeMessage,true); helper.setFrom(shMailFrom); helper.setTo("sssss111@xxx.com"); helper.setSubject("主题，你好，欢迎您"); //支持html 设置html为true即可 helper.setText("很高兴您能使用我们的网站，如果有什么要为您效劳的，请直说,&lt;a href='http://baidu.com'&gt;SH&lt;/a&gt;",true); //嵌入静态资源 helper.addInline("thisImageO",new FileSystemResource(new File("C:\\Users\\Administrator\\Downloads\\11.png"))); //传递附件 helper.addAttachment("您的附件.png",new File("C:\\Users\\Administrator\\Downloads\\11.png")); javaMailSender.send(mimeMessage); &#125;&#125; 与thymeleaf模版引擎配合，发送模版化的html html，注意只有body内有效 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang="en" xmlns:th="http://www.thymeleaf.org"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;只有body会在邮件中显示&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div style="font-size: 17px"&gt; &lt;a th:href="@&#123;http://baidu.com?jwt=&#123;jwt&#125;(jwt=$&#123;jwt&#125;)&#125;"&gt;SH社区邮箱确认&lt;/a&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; service 12345678910111213141516171819202122232425 @Autowired private ITemplateEngine templateEngine; //与thymeleaf模版引擎配合，发送模版化的html @Override public void sendTemplateHtml() throws MessagingException &#123; Context context = new Context(); context.setVariable("jwt","shJwt"); context.setVariable("domain","community.shirtiny.cn"); String mailContent = templateEngine.process("mail", context); sendComplexMail("主题",mailContent); &#125;//复杂邮件 支持html,抄送,密送等 可以携带附件 文内可以嵌入静态资源 @Override public void sendComplexMail(String subject,String mailContent) throws MessagingException &#123; MimeMessage mimeMessage = javaMailSender.createMimeMessage(); MimeMessageHelper helper = new MimeMessageHelper(mimeMessage,true); helper.setFrom(shMailFrom); helper.setTo("shirtiny@gmail.com"); helper.setSubject(subject); //支持html 设置html为true即可 helper.setText(mailContent,true); javaMailSender.send(mimeMessage); &#125;]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>email</tag>
        <tag>腾讯企业邮</tag>
        <tag>springBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode练习]]></title>
    <url>%2F2019%2F12%2F10%2FLeetCode1%2F</url>
    <content type="text"><![CDATA[LeetCode记录①在LeetCode学习的记事本。 141. 判断一个链表是否含有环形结构 141.Linked List Cycle Given a linked list, determine if it has a cycle in it. To represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed) in the linked list where tail connects to. If pos is -1, then there is no cycle in the linked list. 解题思路 使用hash表存储访问过的节点，如果发现节点已经在表中，则表示链表含有环形结构。使用快慢指针，当快指针与慢指针相遇时，表示链表中存在环形结构。 代码java 123456789101112131415161718192021222324252627//141 hashSet方式 public boolean hasCycle1(ListNode head) &#123; Set&lt;ListNode&gt; nodeSet = new HashSet&lt;&gt;(); while (head != null) &#123; if (nodeSet.contains(head)) &#123; return true; &#125; else &#123; nodeSet.add(head); &#125; head = head.next; &#125; return false; &#125; //141 快慢指针方式 public boolean hasCycle2(ListNode head) &#123; ListNode slow = head; ListNode fast = slow; while (fast != null &amp;&amp; fast.next != null) &#123; slow = slow.next; fast = fast.next.next; if (slow == fast) &#123; return true; &#125; &#125; return false; &#125; golang 12345678910111213141516171819202122232425262728//141 map方式 存储的K是节点地址 v可以是任意值func hasCycle1(head *ListNode) bool &#123; nodeMap := make(map[*ListNode]int) node := head for node != nil &#123; if _, ok := nodeMap[node]; ok &#123; return true &#125; else &#123; nodeMap[node] = 1 &#125; node = node.Next &#125; return false&#125;//141 快慢指针方式func hasCycle2(head *ListNode) bool &#123; slow := head fast := head for fast != nil &amp;&amp; fast.Next != nil &#123; slow = slow.Next fast = fast.Next.Next if slow == fast &#123; return true &#125; &#125; return false&#125; 142. 找出链表中环结构的起点 142.Linked List Cycle II Given a linked list, return the node where the cycle begins. If there is no cycle, return null. To represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed) in the linked list where tail connects to. If pos is -1, then there is no cycle in the linked list. Note: Do not modify the linked list. 解题思路 使用hash表存储访问过的节点，返回第一个与表中重复的节点。使用快慢指针，当快指针与慢指针相遇时，相遇点与环形结构起点的距离，刚好等于head链表头节点到环形结构起点的距离。利用这一点，在第一次相遇时，让快指针再次从head开始，以与慢指针同样的速度前进，同时慢指针继续从相遇点原速前进，则接下来的相遇点即为所求的环形结构起点。这样说可能有些抽象，我下面画图说明：假设有两个运动员slow和fast，slow的速度为v，fast的速度是slow的2倍为2v，两人从head点开始通过一段长为x的直道，最后进入环形跑道做匀速运动，设两人相遇点为meet处，设环形跑道的周长C为y+z，可以得出x=kC+z,其中k 为自然数。如果没有直道，相遇点就会一直是起点，也可以说明上面的推论是正确的。 代码java 1234567891011121314151617181920212223242526272829//142 hashSet方式略 //142 快慢指针方式 public ListNode detectCycle(ListNode head) &#123; if (head == null) &#123; return null; &#125; ListNode slow = head; ListNode fast = slow; while (true) &#123; if (fast == null || fast.next == null) &#123; return null; &#125; slow = slow.next; fast = fast.next.next; if (slow == fast) &#123; break; &#125; &#125; fast = head; while (fast != null) &#123; if (fast == slow) &#123; return slow; &#125; fast = fast.next; slow = slow.next; &#125; return null; &#125; golang 1234567891011121314151617181920212223242526272829//142 hash表方式略//142 快慢指针方式func detectCycle(head *ListNode) *ListNode &#123; if head == nil &#123; return nil &#125; slow := head fast := slow for &#123; if fast == nil || fast.Next == nil &#123; return nil &#125; slow = slow.Next fast = fast.Next.Next if slow == fast &#123; break &#125; &#125; fast = head for fast != nil &#123; if fast == slow &#123; return fast &#125; fast = fast.Next slow = slow.Next &#125; return nil&#125; 78. 找出一个集合的所有子集 78.Subsets Given a set of distinct integers, nums, return all possible subsets (the power set). Note: The solution set must not contain duplicate subsets. Example: 123456789101112Input: nums = [1,2,3]Output:[ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], []] 解题思路 迭代，从每轮子集中寻找规律结果集初始为{}，第一轮为{},{1}，第二轮为{},{1},{2},{1,2}，可以得出：每轮结果都是对上一轮中所有集合的扩充。对所有上轮集合都添加1个当前元素，然后把此轮得到的集合，合并到结果集。将结果集命名为allList，我在下图解释了第二轮集合的获取方式：递归回溯，常用的方法，我在90题也使用了同样的方法。 代码java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//78. 迭代方式public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; allList = new ArrayList&lt;&gt;(); allList.add(new ArrayList&lt;&gt;()); for (int value : nums) &#123; for (int p = 0, size = allList.size(); p &lt; size; p++) &#123; List&lt;Integer&gt; temp = new LinkedList&lt;&gt;(allList.get(p)); temp.add(value); allList.add(temp); &#125; &#125; return allList; &#125;&#125; //78. 递归 public List&lt;List&lt;Integer&gt;&gt; subsets2(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; allList = new LinkedList&lt;&gt;(); backStack(nums, 0, new LinkedList&lt;&gt;(), allList); return allList; &#125; private void backStack(int[] nums, int start, List&lt;Integer&gt; list, List&lt;List&lt;Integer&gt;&gt; allList) &#123; allList.add(new LinkedList&lt;&gt;(list)); for (int i = start; i &lt; nums.length; i++) &#123; list.add(nums[i]); backStack(nums, i + 1, list, allList); list.remove(list.size() - 1); &#125; &#125; //90. 78然后去重 public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; allList = new LinkedList&lt;&gt;(); //排序 Arrays.sort(nums); backStack2(nums, 0, new LinkedList&lt;&gt;(), allList); return allList; &#125; private void backStack2(int[] nums, int start, List&lt;Integer&gt; list, List&lt;List&lt;Integer&gt;&gt; allList) &#123; allList.add(new LinkedList&lt;&gt;(list)); for (int i = start; i &lt; nums.length; i++) &#123; //去重 if (i &gt; start &amp;&amp; nums[i] == nums[i - 1]) &#123; continue; &#125; list.add(nums[i]); backStack2(nums, i + 1, list, allList); list.remove(list.size() - 1); &#125; &#125; golang 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//78 迭代方式func subsets(nums []int) [][]int &#123; all := [][]int&#123;&#123;&#125;&#125; for _,value := range nums&#123; for _,temp := range all&#123; temp = append([]int&#123;value&#125;, temp...) all = append(all, temp) &#125; &#125; return all&#125;//78 递归func subsets2(nums []int) [][]int &#123; var allList [][]int backStack(nums,0,[]int&#123;&#125;,&amp;allList) return allList&#125;func backStack(nums []int, start int, list []int, allList *[][]int) &#123; *allList = append(*allList, list) for i := start; i &lt; len(nums); i++ &#123; list := append([]int&#123;nums[i]&#125;, list...) backStack(nums, i+1, list, allList) list = list[len(list)-1:] &#125;&#125;//90. 78然后去重func subsetsWithDup(nums []int) [][]int &#123; var allList [][]int sort.Ints(nums) backStack2(nums, 0, []int&#123;&#125;, &amp;allList) return allList&#125;func backStack2(nums []int, start int, list []int, allList *[][]int) &#123; *allList = append(*allList, list) for i := start; i &lt; len(nums); i++ &#123; //排序 if i &gt; start &amp;&amp; nums[i] == nums[i-1]&#123; continue &#125; //去重 list := append([]int&#123;nums[i]&#125;, list...) backStack2(nums, i+1, list, allList) list = list[len(list)-1:] &#125;&#125; 349. 两个数组的交集 349.Intersection of Two Arrays Given two arrays, write a function to compute their intersection. Example: 12Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4]Output: [9,4] 这题应该是考集合的使用，使用set或者map都是可以的，第350题也大致相同。 java 1234567891011121314151617181920212223242526272829303132333435363738394041424344 //349. Intersection of Two Arrays public int[] intersection(int[] nums1, int[] nums2) &#123; Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); for(int num1 : nums1)&#123; set.add(num1); &#125; int min = Math.min(nums1.length,nums2.length); int[] arr = new int[min]; int p = 0; for (int num2 : nums2)&#123; if(set.contains(num2))&#123; arr[p] = num2; p += 1; set.remove(num2); &#125; &#125; return Arrays.copyOf(arr,p); &#125;//350. Intersection of Two Arrays II public int[] intersect(int[] nums1, int[] nums2) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int num1 : nums1) &#123; //下面这段可以用map.merge()方法表示 map.merge(num1, 1, Integer::sum); Integer value = map.get(num1); if (value != null) &#123; map.put(num1, value + 1); &#125; else &#123; map.put(num1, 1); &#125; &#125; int min = Math.min(nums1.length, nums2.length); int[] arr = new int[min]; int p = 0; for (int num2 : nums2) &#123; Integer value = map.get(num2); if (value != null &amp;&amp; value &gt; 0) &#123; arr[p] = num2; p += 1; map.put(num2, value - 1); &#125; &#125; return Arrays.copyOf(arr, p); &#125; golang 123456789101112131415161718192021222324252627282930313233343536//349. Intersection of Two Arraysfunc intersection(nums1 []int, nums2 []int) []int &#123; aMap := make(map[int]int) for _, num1 := range nums1 &#123; aMap[num1] = 1 &#125; var res []int for _, num2 := range nums2 &#123; if _, ok := aMap[num2]; ok &#123; res = append(res, num2) delete(aMap,num2) &#125; &#125; return res&#125;//350. Intersection of Two Arrays IIfunc Intersect(nums1 []int, nums2 []int) []int &#123; aMap := make(map[int]int) for _, num1 := range nums1 &#123; //若map[int]int无此键 value为0 if value := aMap[num1]; value &gt; 0 &#123; aMap[num1] = value + 1 &#125; else &#123; aMap[num1] = 1 &#125; &#125; var res []int for _, num2 := range nums2 &#123; if value := aMap[num2]; value &gt; 0 &#123; res = append(res, num2) aMap[num2] = value - 1 &#125; &#125; return res&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[全局唯一id生成器封装]]></title>
    <url>%2F2019%2F12%2F05%2F%E5%94%AF%E4%B8%80id%E7%94%9F%E6%88%90%E5%99%A8%E5%B0%81%E8%A3%85%2F</url>
    <content type="text"><![CDATA[UidGenerator的封装UidGenerator是百度的开源id生成器，java实现，基于Snowflake算法。 Snowflake算法描述： 指定机器 &amp; 同一时刻 &amp; 某一并发序列，是唯一的。据此可生成一个64 bits的唯一ID（long）。 UidGenerator源码 集成只需要按照文档做，借助jitpack提供的服务，在Maven中引入即可使用。 使用先提前把结果写在这，这是一个我封装好的starter： pom添加 1234567891011121314151617181920212223&lt;!-- mybatis-plus--&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.2.0&lt;/version&gt; &lt;/dependency&gt; &lt;!--唯一id生成器--&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.Shirtiny&lt;/groupId&gt; &lt;artifactId&gt;baiduUidGenerator&lt;/artifactId&gt; &lt;version&gt;e26810d2b2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 工具包 Apache Commons--&gt; &lt;dependency&gt; &lt;groupId&gt;commons-collections&lt;/groupId&gt; &lt;artifactId&gt;commons-collections&lt;/artifactId&gt; &lt;version&gt;3.2.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-lang&lt;/groupId&gt; &lt;artifactId&gt;commons-lang&lt;/artifactId&gt; &lt;version&gt;2.6&lt;/version&gt; &lt;/dependency&gt; 123456&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;jitpack.io&lt;/id&gt; &lt;url&gt;https://jitpack.io&lt;/url&gt; &lt;/repository&gt;&lt;/repositories&gt; 数据库建表 12345678910111213DROP TABLE IF EXISTS WORKER_NODE;CREATE TABLE WORKER_NODE(ID BIGINT NOT NULL AUTO_INCREMENT COMMENT 'auto increment id',HOST_NAME VARCHAR(64) NOT NULL COMMENT 'host name',PORT VARCHAR(64) NOT NULL COMMENT 'port',TYPE INT NOT NULL COMMENT 'node type: ACTUAL or CONTAINER',LAUNCH_DATE DATE NOT NULL COMMENT 'launch date',MODIFIED TIMESTAMP NOT NULL COMMENT 'modified time',CREATED TIMESTAMP NOT NULL COMMENT 'created time',PRIMARY KEY(ID)) COMMENT='DB WorkerID Assigner for UID Generator',ENGINE = INNODB; 配置数据库连接 1234spring.datasource.url=xxxspring.datasource.username=xxxspring.datasource.password=xxxspring.datasource.driver-class-name=com.mysql.jdbc.Driver mapper扫描 12345678910111213package cn.shirtiny.community.SHcommunity;import ...@SpringBootApplication@MapperScan(&#123;"com.baidu.fsg.uid.worker.dao"&#125;)public class CommunityApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(CommunityApplication.class, args); &#125;&#125; 以上配置完成后，直接注入使用即可。 12@Autowiredprivate UidGenerateService uidGenerateService; 12345@GetMapping("/shApi/getId")public String test() &#123; long id = uidGenerateService.generateUid(); return String.valueOf(id);&#125; 封装 配置文件，用默认的即可cached-uid-spring.xml 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd"&gt; &lt;!-- UID generator --&gt; &lt;bean id="disposableWorkerIdAssigner" class="com.baidu.fsg.uid.worker.DisposableWorkerIdAssigner" /&gt; &lt;bean id="cachedUidGenerator" class="com.baidu.fsg.uid.impl.CachedUidGenerator"&gt; &lt;property name="workerIdAssigner" ref="disposableWorkerIdAssigner" /&gt; &lt;!-- 以下为可选配置, 如未指定将采用默认值 --&gt; &lt;!-- Specified bits &amp; epoch as your demand. No specified the default value will be used --&gt; &lt;!-- 2^28 /(365*24*60*60) = 8年多 --&gt; &lt;property name="timeBits" value="28"/&gt; &lt;!-- 最多支持2^22 4194304 次机器启动 --&gt; &lt;property name="workerBits" value="22"/&gt; &lt;!-- 每秒支持2^13 8192个并发 --&gt; &lt;property name="seqBits" value="13"/&gt; &lt;property name="epochStr" value="2019-08-01"/&gt; &lt;!-- 以下为可选配置, 如未指定将采用默认值 --&gt; &lt;!-- RingBuffer size扩容参数, 可提高UID生成的吞吐量. --&gt; &lt;!-- 默认:3， 原bufferSize=8192, 扩容后bufferSize= 8192 &lt;&lt; 3 = 65536 --&gt; &lt;!--&lt;property name="boostPower" value="3"&gt;&lt;/property&gt;--&gt; &lt;!-- 指定何时向RingBuffer中填充UID, 取值为百分比(0, 100), 默认为50 --&gt; &lt;!-- 举例: bufferSize=1024, paddingFactor=50 -&gt; threshold=1024 * 50 / 100 = 512. --&gt; &lt;!-- 当环上可用UID数量 &lt; 512时, 将自动对RingBuffer进行填充补全 --&gt; &lt;!--&lt;property name="paddingFactor" value="50"&gt;&lt;/property&gt; --&gt; &lt;!-- 另外一种RingBuffer填充时机, 在Schedule线程中, 周期性检查填充 --&gt; &lt;!-- 默认:不配置此项, 即不实用Schedule线程. 如需使用, 请指定Schedule线程时间间隔, 单位:秒 --&gt; &lt;!--&lt;property name="scheduleInterval" value="60"&gt;&lt;/property&gt;--&gt; &lt;!-- 拒绝策略: 当环已满, 无法继续填充时 --&gt; &lt;!-- 默认无需指定, 将丢弃Put操作, 仅日志记录. 如有特殊需求, 请实现RejectedPutBufferHandler接口(支持Lambda表达式) --&gt; &lt;!--&lt;property name="rejectedPutBufferHandler" ref="XxxxYourPutRejectPolicy"&gt;&lt;/property&gt;--&gt; &lt;!-- 拒绝策略: 当环已空, 无法继续获取时 --&gt; &lt;!-- 默认无需指定, 将记录日志, 并抛出UidGenerateException异常. 如有特殊需求, 请实现RejectedTakeBufferHandler接口(支持Lambda表达式) --&gt; &lt;!--&lt;property name="rejectedPutBufferHandler" ref="XxxxYourPutRejectPolicy"&gt;&lt;/property&gt;--&gt; &lt;/bean&gt; &lt;/beans&gt; 新建UidGeneratorConfig类，引入上面的xml文件 1234567891011package com.baidu.fsg.uid.config;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.ImportResource;@Configuration@ImportResource(locations = &#123; "classpath:config/cached-uid-spring.xml" &#125;)public class UidGeneratorConfig &#123;&#125; 编写Service，这里简单封装下即可，有需要可以再改。 1234567891011121314151617package com.baidu.fsg.uid.service;import com.baidu.fsg.uid.UidGenerator;import org.springframework.stereotype.Service;import javax.annotation.Resource;@Servicepublic class UidGenerateService&#123; @Resource private UidGenerator uidGenerator; public long generateUid() &#123; return uidGenerator.getUID(); &#125;&#125; 使用META-INF/spring.factories文件来实例化UidGenerateService 123org.springframework.boot.autoconfigure.EnableAutoConfiguration=\com.baidu.fsg.uid.config.UidGeneratorConfig,\com.baidu.fsg.uid.service.UidGenerateService 使用Jitpack官网 先注册个账号，直接用github授权就可以了，然后把github上的项目地址贴在这： 然后根据提示就行了，用法在这份md的开头写了。]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>UidGenerator</tag>
        <tag>Snowflake</tag>
        <tag>全局唯一ID</tag>
        <tag>Maven</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webSocket单聊+携带Jwt认证]]></title>
    <url>%2F2019%2F11%2F29%2Fwebsocket%E5%8D%95%E8%81%8A%2F</url>
    <content type="text"><![CDATA[社区用户之间的私信功能这几天查了很多博客、文档，磕磕绊绊的总算完成了用户私信的功能，这份md记录了社区对私信功能的实现,，使用WebSocket与Jwt认证，将包括前端部分Vue、后端springBoot的代码。 具体实现后端webSocket配置类 首先设置消息代理 123456789@Override public void configureMessageBroker(MessageBrokerRegistry registry) &#123; //允许客户端订阅主题/room registry.enableSimpleBroker("/room","/user","/uid"); //注册 app的前缀/app registry.setApplicationDestinationPrefixes("/app"); //推送用户前缀 不过默认就是/user registry.setUserDestinationPrefix("/user"); &#125; 重写webSocket握手拦截器，主要功能是解析cookie中的jwt，然后将用户信息存入webSocketSession 1234567891011121314151617181920212223242526272829303132333435/**@Bean * WebSocket 握手拦截器 从cookie中解析jwt */ private HandshakeInterceptor myHandshakeInterceptor()&#123; return new HandshakeInterceptor() &#123; @Override public boolean beforeHandshake(ServerHttpRequest serverHttpRequest, ServerHttpResponse serverHttpResponse, WebSocketHandler webSocketHandler, Map&lt;String, Object&gt; map) throws Exception &#123; ServletServerHttpRequest servletServerHttpRequest = (ServletServerHttpRequest) serverHttpRequest; Cookie[] cookies = servletServerHttpRequest.getServletRequest().getCookies(); if(cookies==null || cookies.length==0) &#123; return false; &#125; UserDTO userDTO=null; //从cookie中解析jwt for (Cookie cookie : cookies)&#123; if ("shJwt".equals(cookie.getName()))&#123; userDTO = jwtService.parseJwtToUser(cookie.getValue()); if (userDTO!=null)&#123; //这里的map里的值会交给websocketSession Message对象里header里会有session的值 map.put("user",userDTO); &#125; &#125; &#125;// return userDTO!=null; //不管怎么样都握手完成 交给handler处理无效用户 return true; &#125; @Override public void afterHandshake(ServerHttpRequest serverHttpRequest, ServerHttpResponse serverHttpResponse, WebSocketHandler webSocketHandler, Exception e) &#123; System.out.println("握手成功"); &#125; &#125;; &#125; 配置服务端连接点，添加握手拦截器 12345678910//注册STOMP协议节点并映射url @Override public void registerStompEndpoints(StompEndpointRegistry registry) &#123; //添加服务端接口 终端点 js连接: let socket=new SockJS('/websocket'); registry.addEndpoint("/websocket") .setAllowedOrigins("*") //握手拦截器 .addInterceptors(myHandshakeInterceptor()) .withSockJS(); &#125; 配置WebSocket传输器，主要目的是注册DecoratorFactory装饰工厂，重写处理器WebSocketHandler中的方法。 12345678910111213141516171819202122232425262728293031323334353637383940@Override public void configureWebSocketTransport(WebSocketTransportRegistration registry) &#123; registry.addDecoratorFactory(webSocketHandler -&gt; new WebSocketHandlerDecorator(webSocketHandler)&#123; @Override public void afterConnectionEstablished(WebSocketSession session) throws Exception &#123; super.afterConnectionEstablished(session); &#125; @Override public void handleMessage(WebSocketSession session, WebSocketMessage&lt;?&gt; message) throws Exception &#123; Object user = session.getAttributes().get("user"); System.out.println(user+"\n正在发送一条消息："+message.getPayload()); /*用户离线问题 可以把经过的带有system标记信息存入数据库或缓存 handler检查客户端传来的ack，根据ack来删除数据库或缓存中的消息 当用户上线时，把对应的消息发给用户，同样携带系统标记，传来ack则删除对应信息 */ if (user==null)&#123; //不是有效的用户登录，就关闭session System.out.println("用户无效 ，关闭session"); session.close(); &#125;else &#123;// session.sendMessage(new TextMessage("用户有效")); super.handleMessage(session, message); &#125; &#125; @Override public void handleTransportError(WebSocketSession session, Throwable exception) throws Exception &#123; session.sendMessage(new TextMessage("出错了")); session.sendMessage(new TextMessage(exception.getMessage())); super.handleTransportError(session,exception); &#125; @Override public void afterConnectionClosed(WebSocketSession session, CloseStatus closeStatus) throws Exception &#123; super.afterConnectionClosed(session,closeStatus); &#125; &#125;); &#125; 配置类总体概况 12345678910111213141516171819202122package cn.shirtiny.community.SHcommunity.Config;import ....@Configuration@EnableWebSocketMessageBrokerpublic class WebSocketConfig implements WebSocketMessageBrokerConfigurer &#123; @Autowired private IjwtService jwtService; @Override public void registerStompEndpoints(StompEndpointRegistry registry) &#123; ... &#125; @Override public void configureMessageBroker(MessageBrokerRegistry registry) &#123; ... &#125; @Override public void configureWebSocketTransport(WebSocketTransportRegistration registry)&#123; ... &#125; private HandshakeInterceptor myHandshakeInterceptor()&#123; ... &#125;&#125; 数据库表模型消息历史记录 12345678910111213141516171819202122232425262728293031323334package cn.shirtiny.community.SHcommunity.Model;import com.baomidou.mybatisplus.annotation.*;import lombok.Data;//聊天记录、频道@Data@TableName("chat_history")public class ChatHistory &#123; //主键 @TableId(value = "chat_history_id") private String chatHistoryId; //聊天记录的名称，唯一 @TableField(value = "chat_history_name",insertStrategy = FieldStrategy.NOT_EMPTY) private String chatHistoryName; //聊天创建时间 @TableField(value = "gmt_created",insertStrategy = FieldStrategy.NOT_NULL) private Long gmtCreated; //更新时间 @TableField(value = "gmt_modified",insertStrategy = FieldStrategy.NOT_NULL) private Long gmtModified; //消息条数 @TableField(value = "message_num",insertStrategy = FieldStrategy.DEFAULT) private Long messageNum; //发送者id @TableField(value = "sender_id") private Long senderId; //接收者id @TableField(value = "recipient_id") private Long recipientId; //频道 @TableField(value = "channel") private String channel;&#125; 单个消息 1234567891011121314151617181920212223242526272829303132333435363738394041424344package cn.shirtiny.community.SHcommunity.Model;import cn.shirtiny.community.SHcommunity.DTO.UserDTO;import com.baomidou.mybatisplus.annotation.*;import com.fasterxml.jackson.databind.annotation.JsonSerialize;import com.fasterxml.jackson.databind.ser.std.ToStringSerializer;import lombok.Data;//聊天消息@Data@TableName("chat_message")public class ChatMessage &#123; //主键 @TableId(value = "chat_message_id",type = IdType.AUTO) @JsonSerialize(using = ToStringSerializer.class) private Long chatMessageId; //记录此消息的 聊天记录的id @TableField(value = "chat_history_id",insertStrategy = FieldStrategy.NOT_NULL) private String chatHistoryId; //消息内容 @TableField(value = "chat_message_content",insertStrategy = FieldStrategy.NOT_EMPTY) private String chatMessageContent; //创建时间 @TableField(value = "gmt_created",insertStrategy = FieldStrategy.NOT_NULL) private Long gmtCreated; //发送者id，可以为空 @TableField(value = "sender_id") @JsonSerialize(using = ToStringSerializer.class) private Long senderId; //接收者id，可以为空 @TableField(value = "recipient_id") @JsonSerialize(using = ToStringSerializer.class) private Long recipientId; //发送者 @TableField(exist = false) private UserDTO sender; //接收者 @TableField(exist = false) private UserDTO recipient; //标识为系统通知 @TableField(exist = false) private boolean system;&#125; 后端控制器和服务层 /sendToUser处理用户之间的消息传输，并记录和存储 12345678910111213141516//一对一聊天 message需要携带消息内容、接收者的id @MessageMapping("/sendToUser") public void sendToUser(Message message) &#123; //接收发送来的消息 然后转为消息对象 ChatMessage chatMessage = chatMessageService.parseMessageToChatMessage(message); //将消息存入数据库 boolean isMessageAdded = chatMessageService.addChatMessage(chatMessage); //创建历史记录 已存在则不会创建 chatHistoryService.addOneChatHistoryBy2Id(chatMessage.getSender().getUserId(), chatMessage.getRecipientId()); //消息数自增 发送消息 只有消息入库成功才会发送 if (isMessageAdded)&#123; chatHistoryService.incrMessageNum(chatMessage.getChatHistoryId()); //发送消息 会在频道路径前加上/user/'historyId' 比如此频道会被拼接为/user/historyId/121chat messagingTemplate.convertAndSendToUser(chatMessage.getChatHistoryId(), "/121chat", chatMessage); &#125; &#125; 其中，chatMessageService的parseMessageToChatMessage()内容为： 123456789101112131415161718@Override public ChatMessage parseMessageToChatMessage(Message message) &#123; String payload = new String((byte[]) message.getPayload()); ChatMessage chatMessage = JSONObject.parseObject(payload, ChatMessage.class); //取出消息头中session里的当前用户 MessageHeaders headers = message.getHeaders(); Map sessionAttributes = (Map) headers.get("simpSessionAttributes"); //断言 assert sessionAttributes != null; //从websocketSession取出发送者 UserDTO sender = (UserDTO)sessionAttributes.get("user"); chatMessage.setSender(sender); chatMessage.setSenderId(sender.getUserId()); //根据双方id得出历史记录id String historyId = chatHistoryService.createHistoryId(sender.getUserId(), chatMessage.getRecipientId()); chatMessage.setChatHistoryId(historyId); return chatMessage; &#125; createHistoryId()方法，生成该消息的消息记录Id，内容为： 123456789@Override public String createHistoryId(Long senderId, Long recipientId) &#123; if (senderId == null || recipientId == null) &#123; return ''; &#125; long min = Math.min(senderId, recipientId); long max = Math.max(senderId, recipientId); return min + "_" + max;; &#125; 这样由两个用户的id，可以唯一确定一条消息记录。 /allHistoryMessage查询某个用户的所有消息记录 123456789101112//查询某个用户的全部消息记录及其内容 @GetMapping("/shApi/allHistoryMessage") @ResponseBody public ShResultDTO&lt;String, Object&gt; retAllHistoryMessage(Long userId)&#123; List&lt;ChatHistoryDTO&gt; chatHistoryDTOS = chatHistoryService.selectAllHistoryMessageByUid(userId); if (userId==null)&#123; return new ShResultDTO&lt;&gt;(400,"参数不合法"); &#125; Map&lt;String,Object&gt; data =new HashMap&lt;&gt;(); data.put("chatHistories",chatHistoryDTOS); return new ShResultDTO&lt;&gt;(200,"已返回该用户所有的历史记录及其内容",data,null); &#125; 返回结果如： 其中selectAllHistoryMessageByUid()方法处理两个用户之前的相对关系： 12345678910111213141516171819//查询某个用户的全部消息记录及其内容 并设置targetUser的值 @Override public List&lt;ChatHistoryDTO&gt; selectAllHistoryMessageByUid(Long userId) &#123; List&lt;ChatHistoryDTO&gt; chatHistories = chatHistoryMapper.selectAllChatHistoryByUid(userId); List&lt;ChatHistoryDTO&gt; tempList = new ArrayList&lt;&gt;(); for (ChatHistoryDTO chatHistory : chatHistories)&#123; long senderId = chatHistory.getSenderId(); long recipientId = chatHistory.getRecipientId(); UserDTO targetUser=null; if (userId == senderId)&#123; targetUser = userMapper.selectUserDtoByid(recipientId); &#125;else &#123; targetUser = userMapper.selectUserDtoByid(senderId); &#125; chatHistory.setTargetUser(targetUser); tempList.add(chatHistory); &#125; return tempList; &#125; 涉及到的mapper的selectAllChatHistoryByUid()方法为： 1234567//查询出单个用户的所有聊天记录 及其全部消息@Select("select * from chat_history where sender_id = #&#123;userId&#125; or recipient_id = #&#123;userId&#125;")@Results(&#123; @Result(column = "chat_history_id",property = "chatHistoryId",id = true), @Result(column = "chat_history_id", property = "chatMessages",javaType = List.class ,many = @Many(select = "cn.shirtiny.community.SHcommunity.Mapper.ChatMessageMapper.selectAllDTOByhistoryId"))&#125;)List&lt;ChatHistoryDTO&gt; selectAllChatHistoryByUid(@Param("userId") Long userId); 前端Vue、Element 数据对象 123456789101112131415161718data: &#123; //外层激活的tab的name outTabsDefActive: 'userMessage', //激活的tab的name innerTabsDefActive: '', //内层tabs 历史消息数组 每个tab的name是targetUser.userId innerTabs: [], //待发送的消息 unSendChatMessage: '', //本地简单用户 发送消息不依赖它 user: &#123;&#125;, //客户端对象 subscribedObj: null, //标识收到了新的消息 receiveNewMessage: 0, //标识已与服务器socket建立连接 isConnected: false &#125;, 两个计算属性 12345678910computed: &#123; //接收者Id 即为当前激活的tab的name recipientId: function () &#123; return this.innerTabsDefActive; &#125;, //当前客户端的id 需要指定，否则会新建客户端，重复订阅 subId: function () &#123; return this.user.userId; &#125;, &#125;, 主要方法 从url中获取要建立通信的用户id： 比如url : http://localhost:8881/messageCenter?uid=117603681930663529 123456789101112//从url获取用户id 然后返回url里的用户id getUidFormUrl() &#123; let url = window.location.href; //正则表达式匹配 let array = url.match(`uid=([0-9]+)`); if (array != null) &#123; //取得要查询的id return array[1]; &#125; else &#123; return null; &#125; &#125;, 连接socket 123456789101112131415161718192021//以jwt为认证标准,连接服务器 connectSocket() &#123; let socket = new SockJS('/websocket'); stompClient = Stomp.over(socket); //关闭控制台输出 // stompClient.debug=null; //连接socket stompClient.connect(&#123;'head': '这是head'&#125;, (frame) =&gt; &#123; console.log("连接socket: /websocket"); console.log(frame); this.isConnected = true; //订阅新加入的频道 this.subscribe(); &#125;, (err) =&gt; &#123; console.log("socket连接失败", err); console.log("可能是用户过期，请重新登录"); this.isConnected = false; this.$message('无效用户,请检查登录是否过期'); &#125;); &#125;, 订阅频道 12345678//以当前js登录的用户，与当前激活的tabName为准，订阅频道 subscribe() &#123; //订阅单用户系统通知频道 let subscribedObj = stompClient.subscribe('/uid/' + this.user.userId, this.onGetMessage, &#123; id: this.subId, ack: this.user.userId &#125;); &#125;, 订阅回调函数，处理message 123456789101112131415161718192021222324252627282930313233343536373839/订阅消息的回调函数 onGetMessage(message) &#123; let chatMessage = JSON.parse(message.body); console.log("", chatMessage.system); //如果是系统通知 if (chatMessage.system)&#123; console.log("系统通知", chatMessage); //存储订阅频道发过来的数据 let sender = chatMessage.sender; //标识当前对象与历史是否有重复 let isExist = false; //从已有的消息列表中寻找与当前uid重复的tab for (let i = 0; i &lt; this.innerTabs.length; i++) &#123; //如果在数组找到重复的id if (this.innerTabs[i].targetUser.userId === sender.userId) &#123; //改变标识 isExist = true; &#125; &#125; //如果不存在 并且发信人不是自己 if (!isExist &amp;&amp; sender.userId !== this.user.userId) &#123; //构建一个临时的消息历史记录 存放targetUser let chatHistory = &#123; chatHistoryId: chatMessage.chatHistoryId, targetUser: sender, chatMessages: [] &#125;; //加入tab 不改变激活的tab this.addTab(chatHistory,false); //加入对应的消息列表 this.putNewMessage(chatMessage); &#125; //最后通知服务器 我已经接收了消息 message.ack(); &#125;else &#123; //直接加入对应的消息列表 this.putNewMessage(chatMessage); &#125; &#125;, 发送消息 123456789sendMessage: function () &#123; console.log("发送消息："); stompClient.send("/app/sendToUser", &#123;&#125;, JSON.stringify(&#123; 'chatMessageContent': this.unSendChatMessage, 'recipientId': this.recipientId, &#125;) ); //清空输入框 this.unsendChatMessage=''; 从通信列表中移除用户 12345678910111213141516171819202122232425//移除tab removeTab(userId) &#123; //移除 console.log("移除", userId); for (let i = 0; i &lt; this.innerTabs.length; i++) &#123; if (this.innerTabs[i].targetUser.userId === userId) &#123; //删除 this.innerTabs.splice(i, 1); //改变默认激活的tab if (i + 1 &lt; this.innerTabs.length) &#123; setTimeout(() =&gt; &#123; this.innerTabsDefActive = this.innerTabs[i + 1].targetUser.userId; &#125;, 20); &#125; if (i - 1 &gt;= 0) &#123; setTimeout(() =&gt; &#123; this.innerTabsDefActive = this.innerTabs[i - 1].targetUser.userId; &#125;, 20); &#125; //换背景图 依照数组的情况换背景 由watch来监控，这里不需要了 // this.changeBackImg(); break; &#125; &#125; &#125;, 更多内容…，可以在我Github上查看源码。 mounted() 1234mounted() &#123; //绘制canvas this.canvasStart(); &#125;, watch监控 1234567891011121314151617181920watch: &#123; receiveNewMessage: &#123; handler(newName, oldName) &#123; //dom更新之后执行 this.$nextTick(() =&gt; &#123; console.log("dom更新了 , 移动滚条到底部"); //移动滚条到底部 把class为shMessageHistoryBox的dom节点都做一次滚动条移动 因为切换tab会切换dom节点 let historyBoxArray = document.getElementsByClassName("shMessageHistoryBox"); for (let historyBox of historyBoxArray) &#123; let scrollTop = historyBox.scrollTop; let scrollHeight = historyBox.scrollHeight; let clientHeight = historyBox.clientHeight; console.log("scrollHeight:", scrollHeight, ";scrollTop:", scrollTop, ";clientHeight:", clientHeight, ";scrollHeight - scrollTop - clientHeight:", scrollHeight - scrollTop - clientHeight); //开始移动 historyBox.scrollTop = historyBox.scrollTop + (scrollHeight - scrollTop - clientHeight); &#125; &#125;); console.log("receiveNewMessage改变了", oldName, newName); &#125; &#125; 结构 主要css 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/*注意下面三个div的 overflow:hidden 的作用是清除浮动 让外层div自适应内层div高度*/ /*最小高度，=盒子里的内容高度+上下padding*/ .shMessageBox &#123; min-height: 66px; padding: 0 16px 16px; margin: 0; position: relative; line-height: 12px; font-size: 12px; overflow: hidden &#125; .shMessage &#123; margin: 0; overflow: hidden; padding: 0 10px; max-width: 480px; display: block; &#125; .shMessageContent &#123; margin: 0; /*padding: 8px 16px 8px 20px;*/ line-height: 1.5; font-size: 14px; padding: 8px 16px; word-wrap: break-word; word-break: break-word; box-sizing: border-box; z-index: 1; border-radius: 0 16px 16px 16px; background: #fff; overflow: hidden; &#125; /* 改变tab自定标签的高度 3个height要一致*/ .shELInnerTab .el-tabs__item &#123; height: 60px !important; &#125; .shELInnerTab .el-tabs__active-bar &#123; height: 60px !important; &#125; .shELInnerTab .shELInnerTabDiv &#123; height: 60px !important; width: 150px !important; padding: 5px 5px 5px 5px; &#125; /* 消息记录的盒子 带有滚动条*/ .shMessageHistoryBox &#123; overflow-x: hidden; overflow-y: scroll; height: 350px; background-color: #f4f5f7;; padding: 15px 10px; margin: 5px 5px &#125; 离线状态处理 消息的收信人离线时，无法及时收到消息，所以消息模型需要增加一个字段，来标识已读状态。 12345678910111213141516171819202122232425262728293031323334353637383940414243package cn.shirtiny.community.SHcommunity.Model;import ....//聊天消息@Data@TableName("chat_message")public class ChatMessage &#123; //主键 @TableId(value = "chat_message_id") @JsonSerialize(using = ToStringSerializer.class) private Long chatMessageId; //记录此消息的 聊天记录的id @TableField(value = "chat_history_id", insertStrategy = FieldStrategy.NOT_NULL) private String chatHistoryId; //消息内容 @TableField(value = "chat_message_content", insertStrategy = FieldStrategy.NOT_EMPTY) private String chatMessageContent; //创建时间 @TableField(value = "gmt_created", insertStrategy = FieldStrategy.NOT_NULL) private Long gmtCreated; //发送者id，可以为空 @TableField(value = "sender_id") @JsonSerialize(using = ToStringSerializer.class) private Long senderId; //接收者id，可以为空 @TableField(value = "recipient_id") @JsonSerialize(using = ToStringSerializer.class) private Long recipientId; //标识是否已读，不为空 默认false @TableField(value = "readed") private boolean readed; //标识为系统通知 @TableField(value = "systems") private boolean systems; //发送者 @TableField(exist = false) private UserDTO sender; //接收者 @TableField(exist = false) private UserDTO recipient;&#125; 当客户端收到消息时，需要message.ack()来通知服务端它已经接收了消息 123456789//订阅回调函数onGetMessage(message) &#123; //通知服务器 我已经接收了消息 让服务器把消息改成已读 message.ack(&#123;chatMessageId: chatMessage.chatMessageId&#125;);&#125;//订阅stompClient.subscribe('/user/' + subscribeChannel + '/121chat', this.onGetMessage, &#123;id: this.subId&#125;); 通过ack的自定义header传递消息对象或消息id，以传达给服务器具体消息对象的信息。 当服务器通过webSocketHandler在收到客户端回应的ack时，改变对应消息的已读状态。如果没有收到ack，则该消息保持默认的未读状态。我这里不管是否收到ack，消息都入库存储。若需求较大，也可以针对未读消息引入缓存或消息队列。 12345678910111213141516@Override public void handleMessage(WebSocketSession session, WebSocketMessage&lt;?&gt; message) throws Exception &#123; //检查客户端传来的ack，根据ack来改变数据库中的已读标识 String payload = (String)message.getPayload(); //如果stomp帧是ACK,载荷字符串以ACK开头 boolean isACK = payload.startsWith("ACK"); if (isACK)&#123; System.out.println("这是ack"); Matcher matcher = chatMessageIdReg.matcher(payload); while (matcher.find())&#123; String chatMessageId = matcher.group(1); //更新消息为已读状态 chatMessageService.updateMessageRead(chatMessageId,true); &#125; &#125; &#125; 用户上线时，在导航条提示用户未读消息的计数，引导其前往消息中心 在消息中心可以直接显示全部消息，也可以选择将消息重新发送到相应频道。最后更新用户点击过的聊天记录消息的已读状态。 12345678910111213141516//更新对应tab的消息记录的消息为已读状态 updateHistoryRead() &#123; if (this.innerTabs.length !== 0 &amp;&amp; this.recipientId != null &amp;&amp; Number(this.recipientId) !== 0 &amp;&amp; this.user != null &amp;&amp; this.isConnected) &#123; for (let i = 0; i &lt; this.innerTabs.length; i++) &#123; if (this.innerTabs[i].targetUser.userId === this.recipientId) &#123; //如果消息记录的最后一条消息的收信人是本地用户 更新该消息记录的已读状态 let lastIndex = this.innerTabs[i].chatMessages.length - 1; if (lastIndex &gt;= 0 &amp;&amp; this.user.userId === this.innerTabs[i].chatMessages[lastIndex].recipientId) &#123; axios.get('/shApi/updateChatHistoryRead?chatHistoryId=' + this.innerTabs[i].chatHistoryId).then(res =&gt; &#123; console.log(this.innerTabs[i].chatHistoryId, "更新为已读"); &#125;); &#125; &#125; &#125; &#125; &#125;, 123456789101112watch: &#123; recipientId: &#123; handler(newName, oldName) &#123; //订阅 if (this.recipientId != null &amp;&amp; this.user != null &amp;&amp; this.isConnected) &#123; this.subscribe(); &#125; //更新对应消息历史记录的消息为已读状态 this.updateHistoryRead(); &#125; &#125;,&#125;]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>springBoot</tag>
        <tag>webSocket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JWT+Shiro安全无状态服务]]></title>
    <url>%2F2019%2F11%2F13%2FJWT%2F</url>
    <content type="text"><![CDATA[【长篇】登录认证、权限控制思路整理在我论坛网站中，登录是第一个做的功能，可做的很简单，只是在河水两岸扔了块软绵绵的木板，以供临时的通行。登录认证、权限控制，这两个服务是隐私的入口，需要格外的注意。现在，社区爬取到了很多的用户数据，我觉得是时候对SSO、JWT这方面的知识做个总结了。 我将在这份md中，边写登录认证服务的代码，边记录与总结自己的思考和体会，之后会整理思路，希望能对读者有所帮助。本文所有实现，都以java为主，框架使用的是SpringBoot。 0. 需求登录注册显然是必须的，此外在我的社区网站中，站长、版主、管理员、普通成员一共有这4种角色，大概可以这么看： 1站长&gt;管理员&gt;版主&gt;普通成员 普通成员拥有发表帖子、查看帖子、回复评论、私信任意用户等权限 版主则拥有版块管理、版内帖子管理、成员发言权管理等权限 管理员自然拥有版主管理、普通成员管理、版块与帖子管理等权限 站长自然拥有所有权限，包括对权限的修改等。 成员登录，从而进入网站大门，而对成员角色的认证，则是网站的一个小门。 依赖 具体实现上，我打算选用Shiro与JWT来完成。 123456789101112&lt;!--Shiro--&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt;&lt;/dependency&gt;&lt;!--JWT--&gt;&lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt&lt;/artifactId&gt; &lt;version&gt;0.9.0&lt;/version&gt;&lt;/dependency&gt; 选择Shiro是因为其相对轻量，而且shiro这个词我好像经常听到，莫名感觉很亲切。而后者JWT大概是我这份md的主线吧。 1. 密码加密存储显然，无论如何我们都需要把用户存在数据库中，这个有状态服务是无法避免的。 用户表：Users，字段有邮箱、昵称、密码（加密存储）、身份等。 密码以密文的形式存储，用户登录时，将邮箱和密码输入，然后网站大门的系统会根据邮箱查询数据库，将用户提交的密码进行加密运算，将运算后得到值去盐与数据库中的密文进行比对，以确认用户是否合法。 关于hash加密加密需要使用hash散列函数来计算，比如%取余就是最简单的hash运算，常见的hash算法，像MD5、sha256、sha1，MD5已经被能被人为的制造hash碰撞了，所以不推荐使用。 为什么要使用hash加密呢，因为hash是不可逆的，比如x%3=9你无法确定x的值。所以就算得到了数据库中保存的hash值，也难以恢复成原来的密码，而正确的密码取hash后的值，是不变的。 然而，单纯的hash运算后的加密数据，也并不保险，比如彩虹表就能暴力的破解hash。所以又出现了一种更安全的算法加盐hash，它会在hash运算中，带上随机数或字符串，从而增加彩虹表的破解难度 关于浏览器缓存说个题外话，web服务器在返回文件时会返回一个eTag作为此文件的唯一标识会放在响应的header里，当浏览器发现再次请求的文件的eTag没有改变时，便不会再拉取文件，这是浏览器的缓存机制，可以节省流量。而eTag是怎么来的呢？我曾经以为是对文件取的hash运算，但后来发现并不是这样。eTag是由文件修改时间time与文件大小size进行按位异或运算，即： 1234//二进制 按位异或运算time ^ size = eTage//比如：101000010 ^ 10010110 = 00110100 实现借助Shiro提供的加密类即可。 1234567891011121314151617181920package cn.shirtiny.community.SHcommunity.Utils.Encryption;import ... @Component("shaEncryptor")public class ShaEncryptor &#123; //使用的加密算法名 @Value("$&#123;Shiro_AlgorithmName&#125;") private String algorithmName; //盐值 @Value("$&#123;Shiro_Salt&#125;") private String salt; /**加密 * @param source 待加密字符串 * @return 加密后的密文*/ public String encrypt(String source) &#123; SimpleHash simpleHash = new SimpleHash(algorithmName, source, salt); return simpleHash.toHex(); &#125;&#125; 对应的配置文件 1234#shiro加密密码使用的加密算法名 这里是SHA256Shiro_AlgorithmName=SHA-256#盐值Shiro_Salt=salt 重写Shiro获取用户认证信息的方法 1234567891011121314151617package cn.shirtiny.community.SHcommunity.Shiro;import ...//Shiro连接数据的桥梁 从数据库获取数据public class ShRealm extends AuthorizingRealm &#123; @Autowired private IuserService userService; //获取认证信息 @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException &#123; UsernamePasswordToken token = (UsernamePasswordToken) authenticationToken; String username = token.getUsername(); User user = userService.selectOneUserByUserName(username); //当前的realm名 this.getClass().getName() 可写可不写 return new SimpleAuthenticationInfo(user,user.getPassWord(),this.getClass().getName()); &#125;&#125; 重写Shiro密码校验方法 123456789101112131415161718192021package cn.shirtiny.community.SHcommunity.Shiro;import ... //对shiro密码验证规则重写public class ShPwdMatcher extends SimpleCredentialsMatcher &#123; @Autowired private ShaEncryptor shaEncryptor; @Override public boolean doCredentialsMatch(AuthenticationToken token, AuthenticationInfo info) &#123; UsernamePasswordToken upToken = (UsernamePasswordToken) token; //用户输入的密码 String inputPassWord = new String(upToken.getPassword()); //对用户输入的密码加密 String encryptedInput = shaEncryptor.encrypt(inputPassWord); //数据库中查出的密码密文 String dbPassword = (String)info.getCredentials(); //返回两者是否相同 return this.equals(encryptedInput,dbPassword); &#125;&#125; 2. Https在上部分中： 密码以密文的形式存储，用户登录时，将邮箱和密码输入，然后网站大门的系统会根据邮箱查询数据库，将用户提交的密码进行加密运算，将运算后得到值去盐与数据库中的密文进行比对，以确认用户是否合法。 这样看起来似乎没什么问题，设想一下，如果有一名黑客，在用户发起登录的Post请求时窃听用户邮箱和密码，这该怎么办呢？应该使用https。对于https，我觉得，需要先从非对称加密说起。 关于非对称加密最有名的非对称加密算法是RSA，非对称加密会生成一个密钥对，包含公钥和私钥。分为两种情况，私钥加密，使用公钥解密；公钥加密，使用私钥解密。 这样看，应该不是很清楚，我会举几个例子说明这两种情形： 情景一A要发送Message给BA需要先询问B的公钥，B将自己的公钥告诉对方A使用B的公钥加密Message，然后把得到的密文发给BB使用自己的私钥解密Message，获得明文这样，第三者即使看完了整个通信过程，也无法知道Message的内容。但是，第三者知晓了B的公钥，他也可以使用B的公钥加密消息，向B发送消息，此时B是无法知道写信人是谁的。所以，公钥加密，使用私钥解密，这种情形无法防止伪造的问题。 情景二依然是A要发送Message给BA先把自己公钥发给B然后A使用自己的私钥加密了Message，发送给了BB根据A的公钥解密Message，便明确的知道Message确实是来自于A私钥加密，就像一个人的字迹、签名，能够标识消息的来源。但在这个情形里，Message的内容显然被第三者看的一清二楚。 所以我们发现，只使用非对称加密算法，无法满足我们的需要，所以需要引入对称加密算法。 关于对称加密对称加密有一个共享密钥PSKPre Shared Key，原数据使用PSK加密后得到密文，密文使用PSK解密后，便会回到明文。使用对称加密，需要事先发信双方都知道PSK的值。推荐使用AES对称加密算法，DES算法已经被攻破。 情景三依然是A要发送Message给BA需要先询问B的公钥，B将自己的公钥告诉对方A把对称加密的密钥PSK放入Message，使用B的公钥加密后，发送给BB使用自己的私钥解密Message，得到PSK然后，双方便可以使用对称加密算法的PSK进行通信这样就可以防止Message内容的泄漏、修改、伪造了，看上去似乎是个很好的解决方式。 其实，这三种情形，都有一个更大的问题，A并不清楚对方是不是真正的B，B也同样如此。如何理解呢，这里是有个前提，通信是在网络上进行的，而网络上的身份和现实是不绑定的，就像百度搜索xx官网一样，没有一个充分的理由便不能确认它的真实性。此时需要一个中间的机构，比如百度认证的xx官网，我信任百度，便会相信这个xx官网是真正的。那这个组成信任链的中间机构是谁呢？ CA机构比如Let&#39;s Encrypt、DigiCert、赛门铁克等CA机构，就是中间人。CA机构会颁发数字证书给信任的网站，数字证书是公钥和私钥的密钥对，证书由CA机构的私钥签发。浏览器信任CA机构，便会信任CA机构信任的网站，然后当用户访问受信任的网站时，浏览器便会提醒该站是安全可信的。 于是，便可以简单理解为情景四： 情景四依然是A要发送Message给BA需要先询问B的CA签名公钥，B将CA签名过的公钥告诉对方A进行比对，确认是CA签发的，A信任CA，也就信任了BA把对称加密的密钥PSK放入Message，使用B的公钥加密后，发送给BB使用自己的私钥解密Message，得到PSK然后，双方便可以使用对称加密算法的PSK进行通信 RSA非对称加密实现使用java的security包即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115package cn.shirtiny.community.SHcommunity.Utils.Encryption;import javax.crypto.Cipher;import java.nio.charset.StandardCharsets;import java.security.*;import java.security.spec.PKCS8EncodedKeySpec;import java.security.spec.X509EncodedKeySpec;import java.util.Base64;public class RSAKey &#123; private PrivateKey privateKey; private PublicKey publicKey; //生成密钥 public RSAKey() throws GeneralSecurityException &#123; //密钥对生成器 生成rsa密钥对生成器 KeyPairGenerator rsaGenerator = KeyPairGenerator.getInstance("RSA"); //初始化生成器 rsaGenerator.initialize(1024); //生成密钥对 KeyPair keyPair = rsaGenerator.generateKeyPair(); //公钥 this.publicKey = keyPair.getPublic(); //私钥 this.privateKey = keyPair.getPrivate(); System.out.println("生成公钥：" + Base64.getEncoder().encodeToString(this.publicKey.getEncoded())); System.out.println("生成私钥：" + Base64.getEncoder().encodeToString(this.privateKey.getEncoded())); &#125; //从已有字符数组中恢复密钥 public RSAKey(byte[] publicKeyBytes, byte[] privateKeyBytes) throws GeneralSecurityException &#123; //RSA密钥工厂 KeyFactory rsaFC = KeyFactory.getInstance("RSA"); //恢复publicKey 需要X509EncodedKeySpec格式 X509EncodedKeySpec publicKeySpec = new X509EncodedKeySpec(publicKeyBytes); this.publicKey = rsaFC.generatePublic(publicKeySpec); //恢复privateKet 需要PKCS8EncodedKeySpec格式 PKCS8EncodedKeySpec privateKeySpec = new PKCS8EncodedKeySpec(privateKeyBytes); this.privateKey = rsaFC.generatePrivate(privateKeySpec); &#125; //从已有的Base64字符串中回复密钥 public RSAKey(String publicKeyBase64Str, String privateKeyBase64Str) throws GeneralSecurityException &#123; this(Base64.getDecoder().decode(publicKeyBase64Str), Base64.getDecoder().decode(privateKeyBase64Str)); &#125; //获得公钥对象 public PublicKey getPublicKey() &#123; return publicKey; &#125; //获得私钥对象 public PrivateKey getPrivateKey() &#123; return privateKey; &#125; //得到公钥字符数组 public byte[] getPublicKeyBytes() &#123; return this.publicKey.getEncoded(); &#125; //得到私钥字符数组 public byte[] getPrivateKeyBytes() &#123; return this.privateKey.getEncoded(); &#125; //得到公钥Base64编码的字符串 public String getPublicKeyBase64Str() &#123; return Base64.getEncoder().encodeToString(getPublicKeyBytes()); &#125; //得到私钥Base64编码的字符串 public String getPrivateKeyBase64Str() &#123; return Base64.getEncoder().encodeToString(getPrivateKeyBytes()); &#125; //加密 public byte[] encrypt(byte[] str, Key key) throws GeneralSecurityException &#123; Cipher rsaCipher = Cipher.getInstance("RSA"); //初始化 加密模式 rsaCipher.init(Cipher.ENCRYPT_MODE, key); return rsaCipher.doFinal(str); &#125; //解密 public byte[] decrypt(byte[] str, Key key) throws GeneralSecurityException &#123; Cipher rsaCipher = Cipher.getInstance("RSA"); //初始化 解密模式 rsaCipher.init(Cipher.DECRYPT_MODE, key); return rsaCipher.doFinal(str); &#125; //示例 public void rsaKeyTest() throws GeneralSecurityException &#123; RSAKey rsaKey = new RSAKey(); String message = "公钥加密的消息"; //公钥加密私钥解 //公钥加密 byte[] encryptedMessage = rsaKey.encrypt(message.getBytes(), rsaKey.getPublicKey()); System.out.println(new String(encryptedMessage, StandardCharsets.UTF_8)); //私钥解密 byte[] decryptedMessage = rsaKey.decrypt(encryptedMessage, rsaKey.getPrivateKey()); System.out.println(new String(decryptedMessage, StandardCharsets.UTF_8)); //私钥加密公钥解 message = "私钥加密的消息"; //私钥加密 encryptedMessage = rsaKey.encrypt(message.getBytes(), rsaKey.getPrivateKey()); System.out.println(new String(encryptedMessage, StandardCharsets.UTF_8)); //公钥解密 decryptedMessage = rsaKey.decrypt(encryptedMessage, rsaKey.getPublicKey()); System.out.println(new String(decryptedMessage, StandardCharsets.UTF_8)); &#125;&#125; AES对称加密实现与非对称加密类似 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192package cn.shirtiny.community.SHcommunity.Utils.Encryption;import javax.crypto.*;import javax.crypto.spec.SecretKeySpec;import java.nio.charset.StandardCharsets;import java.security.*;import java.util.Base64;public class AESKey &#123; //自定字符串 private String keyStr = "自定义"; //由keyStr生成的AES密钥 private SecretKey aesKey; //密钥的Base64编码字符串 private String aesKeyBase64Str; //基于自定字符串 生成新的密钥 public AESKey() &#123; //key生成器 KeyGenerator aesKeyGenerator = null; try &#123; aesKeyGenerator = KeyGenerator.getInstance("AES"); &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); &#125; assert aesKeyGenerator != null; //初始化key生成器 并要求密钥长度为 256 ( keySize: must be equal to 128, 192 or 256 ) aesKeyGenerator.init(256, new SecureRandom(this.keyStr.getBytes())); //构造aesKey this.aesKey = aesKeyGenerator.generateKey(); //aesKey 的base64编码表示 this.aesKeyBase64Str = Base64.getEncoder().encodeToString(this.aesKey.getEncoded()); //打印 System.out.println(this.aesKeyBase64Str); &#125; //从已有密钥base64字符串中恢复密钥 public AESKey(String aesKeyBase64Str) &#123; this.aesKeyBase64Str = aesKeyBase64Str; byte[] decode = Base64.getDecoder().decode(this.aesKeyBase64Str); this.aesKey = new SecretKeySpec(decode, "AES"); &#125; //返回aesKey public SecretKey getAesKey() &#123; return aesKey; &#125; //返回aesKey的Base64字符串 public String getAesKeyBase64Str() &#123; return aesKeyBase64Str; &#125; //加密 public byte[] encrypt(String message) throws GeneralSecurityException &#123; Cipher aesCipher = Cipher.getInstance("AES"); //初始化 加密模式 aesCipher.init(Cipher.ENCRYPT_MODE, this.aesKey); return aesCipher.doFinal(message.getBytes()); &#125; //解密 public String decrypt(byte[] encrypted) throws GeneralSecurityException &#123; Cipher aesCipher = Cipher.getInstance("AES"); //初始化 解密模式 aesCipher.init(Cipher.DECRYPT_MODE, this.aesKey); byte[] bytes = aesCipher.doFinal(encrypted); return new String(bytes, StandardCharsets.UTF_8); &#125; //示例方法 public void aesKeyTest(String[] args) &#123; //基于自定字符串 使用新的aes密钥 来测试加密解密 AESKey aesKey = new AESKey(); String message = "未加密的消息"; try &#123; //加密 byte[] encrypt = aesKey.encrypt(message); System.out.println("加密后：" + new String(encrypt, StandardCharsets.UTF_8)); //解密 String decrypt = aesKey.decrypt(encrypt); System.out.println("解密后：" + decrypt); &#125; catch (GeneralSecurityException e) &#123; e.printStackTrace(); &#125; //从已有字符串中 回复aesKey String aesBase64Str = Base64.getEncoder().encodeToString(aesKey.getAesKey().getEncoded()); AESKey aesKey2 = new AESKey(aesBase64Str); System.out.println(Base64.getEncoder().encodeToString(aesKey2.getAesKey().getEncoded())); &#125;&#125; 3. Token所以，使用Https传输，结合加盐Hash加密，便可以完成大门的系统。那么，还有个问题，小门怎么办，登录的大门进入了，权限控制的小门该如何对已登入用户进行认证。 如果，在用户通过小门时，再去通过用户邮箱查一遍他的角色信息呢？ 这是不合适的，此时大门系统和小门系统都是能查到所有用户信息的，这会把重要数据损失的责任分散，如果发现用户信息泄漏了，便不知道该对哪个组件追责。而且，这种设计，会加大数据库的压力。 使用Token（令牌） 由大门系统发放Token，token有有效期，用户携带的令牌由小门系统认证，这样小门系统便被限制了视野范围。 使用令牌，无需查询用户信息，只需要能确认Token的合法性。但还有个问题，Token存哪呢？小门怎么知道Token是合法的呢？ 先不谈把Token存在数据库或Redis里合不合适，先看这个，能把Token存Session里吗？ 为什么Session不安全对于每个用户，服务器都有一块独立内存，怎么标识这些内存所属用户的呢？Http请求之间并没有关联，服务器如果想要标识某个用户，就只能去依赖Cookie，给每个新用户发一个cookie，里面存放一个sessionId，每次用户请求时，就会携带这个cookie，服务器便会根据对应id访问对应内存。 所以说Session依赖于Cookie，而Cookie会被修改和伪造。完全可以把Cookie中的sessionId修改为另外一个用户的id，便可以伪造成别人，进而获得不该有的权限。 还有个问题，随着用户的增多，服务器内存便可能会不足，而且恶意的人可以不断使用空Cookie请求服务器，这会使服务器开辟出大量的无用内存。 最后一个问题，session是有状态的，由于在内存存储了数据，关机重启或宕机，数据便无法找回，新服务器无法承接旧服务器的工作。 为什么不把Token存在数据库或Redis我们再回头来看Token存储在数据库或Redis中会怎样： 负担加重 这个是毋庸置疑的，如果在数据库多了张Token表，我们不止要去频繁的查询，而且还要去维护Token的有效期，显然存在数据库中是不可取的。看到这，您一定会想，存redis里不就完了，访问量高的话，就做性能优化、集群，甚至用消息队列等。并非如此，问题其实并不是出在性能上，而是不合理，尽量避免有状态服务，方便扩展，减少开销。 安全隐患 为什么会说有安全隐患呢，因为小门系统通过查询数据库或redis能够拿到任何人的Token，这是不安全的，我们不该让小门系统接触到这些敏感数据，尽量把用户的敏感数据只交给一个系统去负责。 那可以怎么做呢？如何既能避免有状态服务，又能安全的认证token合法性？ 数字签名什么是数字签名呢，其实这个概念在上面说非对称加密的时候提到过。而在这儿的情景，用户在大门系统登录时，由大门系统确认用户的合法性，然后将用户需要传输的信息，比如昵称、权限等信息使用大门系统的私钥与加密算法进行加密，这部分加密的数据就是数字签名。 在签名完成后，把数字签名与昵称、权限等明文信息（通常由Json、Base64编码）一起作为Token，一并交给用户。小门系统对用户进行权限认证时，会使用大门系统的公钥、以及加密时相应对的解密算法对数字签名解密，如果解密后的内容刚好与明文部分吻合，便通过用户合法认证，然后在看明文数据，查看该用户的权限，从而决定是否放行。 有了数字签名系统后，我们只需要维护好大门的私钥，公开大门的公钥，这样，用户如果需要校验令牌是否过期，只需要在本地校验。 这就是完成了简化版的JWTJson Web Token。 4. JWT这是一个我服务器生成的JWT： 123eyJ0eXBlIjoiand0Iiwic2lnbkJ5Ijoic2hpcnRpbnkiLCJhbGciOiJSUzI1NiJ9.eyJqdGkiOiJqd3TllK_kuIBpZCIsInN1YiI6IuS4u-mimCIsImlhdCI6MTU3NDMxNjI5MSwiZXhwIjoxNTc0MzE4MDkxLCLov5nmmK9rZXkiOiLov5nmmK_lgLwifQ.LVioBqSRdKWq4Doc7JiNAmv3QjxlT94N0wptwoe7SZUPCLbcsGzT19ddUjygvz-zE8f0Nd9GU3wXCdbu2kYpRzlb2x6xwwO6KKYRFPKj6olr_HIKKEumUf4grHHVlWTDuu6FVjJXszMQ_LIleRSjoXqadDCWGiLEV3kjnJ5ybSs JWT按.分为3个部分：head、payload、signature 上面JWT的解析结果为： 123456789101112131415&#123; "header": &#123; "type": "jwt", "signBy": "shirtiny", "alg": "RS256" &#125;, "body": &#123; "jti": "jwt唯一id", "sub": "主题", "iat": 1574316291, "exp": 1574318091, "这是key": "这是值" &#125;, "signature": "LVioBqSRdKWq4Doc7JiNAmv3QjxlT94N0wptwoe7SZUPCLbcsGzT19ddUjygvz-zE8f0Nd9GU3wXCdbu2kYpRzlb2x6xwwO6KKYRFPKj6olr_HIKKEumUf4grHHVlWTDuu6FVjJXszMQ_LIleRSjoXqadDCWGiLEV3kjnJ5ybSs"&#125; 其中signature便是上文所说的数字签名，也是JWT解析时主要验证的部分。 用户请求时，可以在Http请求头携带Authorization字段，值为JWT字符串，这样服务器就无需存储用户信息，从而达成无状态服务，方便扩展。比如，JavaScript使用axios发送携带Authorization字段的请求： 12345678910axios.post('/shPri/createInvitation', &#123; title: title, content: content, &#125;, &#123; headers: &#123;'Authorization': jwt&#125; &#125;).then(res =&gt; &#123; console.log(res) &#125;).catch(err =&gt; &#123; console.log(error) &#125;) 那么，如果要存的话，JWT存哪呢？我们显然可以不用存在服务器上了，所以我们有两个选择： LocalStorage LocalStorage和服务器没有任何关系，JS可以随意的操作LocalStorage，JWT存在这里，会被轻松拿到，安全性不高。 Cookie 使用带有HttpOnly的cookie时，通过JavaScript无法访问，防范XSS（跨站脚本，会盗取cookie，应该尽量的过滤用户发布的信息，不让其发布敏感html），发送请求时会自动带上cookie。 JWT一旦被颁发，就无法撤回、一直合法、无法对其再做其他操作，所以一定要为JWT设置适当的过期时间。如果必须要实现对JWT的有效性管理，就避不开有状态服务。 JWT实现使用jjwt包即可，这里结合上文的RSA非对称加密，使用RSA算法签名JWT。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283package cn.shirtiny.community.SHcommunity.Utils.JWT;import ... @Slf4j//JWT工具类，暂时只实现了jwt的生成和解析public class JwtRsaHelper &#123; private PublicKey publicKey; private PrivateKey privateKey; //30分钟后过期 毫秒 private static final long expirationTime=1800_000; public JwtRsaHelper(String publicKeyBase64Str,String privateKeyBase64Str)&#123; RSAKey rsaKey = null; try &#123; rsaKey = new RSAKey(publicKeyBase64Str,privateKeyBase64Str); this.privateKey = rsaKey.getPrivateKey(); this.publicKey = rsaKey.getPublicKey(); &#125; catch (GeneralSecurityException e) &#123; e.printStackTrace(); log.error("jwtRsaHelper中的RsaKey密钥对恢复失败", e); &#125; &#125; //生成jwt 使用私钥签名 public String createJwt(Map&lt;String, Object&gt; claims) &#123; //注意把claims第一个设置 JwtBuilder builder = Jwts.builder() .setHeaderParam("type","jwt") .setHeaderParam("signBy","shirtiny") .setId("jwt唯一id") .setSubject("主题") .setIssuedAt(new Date()) .setExpiration(new Date(System.currentTimeMillis() + expirationTime)) .addClaims(claims) .signWith(SignatureAlgorithm.RS256, this.privateKey); return builder.compact(); &#125; //用户令牌 public String createJwt(User user) &#123; Map&lt;String, Object&gt; claims = new HashMap&lt;&gt;(); //这样user内的信息会作为一个map存入jwt，jwt解析取的时候，需要把user转为map claims.put("user",user); claims.put("userId",user.getUserId()); //注意把claims第一个设置 或使用addClaims JwtBuilder builder = Jwts.builder() .setHeaderParam("type","jwt") .setHeaderParam("signBy","shirtiny") .setId("Jwt唯一id") .setSubject(user.getUserName()) .setIssuedAt(new Date()) .setExpiration(new Date(System.currentTimeMillis() + expirationTime)) .addClaims(claims) .signWith(SignatureAlgorithm.RS256, this.privateKey); return builder.compact(); &#125; //解析jwt 返回值包含头、负荷、签名 public Jws&lt;Claims&gt; parseJwt(String jwt)&#123; return Jwts.parser(). setSigningKey(this.publicKey) .parseClaimsJws(jwt); &#125; //获得jwt的body 使用公钥验证签名 如果过期，会抛出ExpiredJwtException public Claims parseJwtBody(String jwt) &#123; return parseJwt(jwt) .getBody(); &#125; //获得jwt的header 使用公钥验证签名 public JwsHeader parseJwtHeader(String jwt) &#123; return parseJwt(jwt) .getHeader(); &#125; //获得jwt的签名部分 使用公钥验证签名 public String parseJwtSignature(String jwt) &#123; return parseJwt(jwt) .getSignature(); &#125;&#125; 配置类 1234567891011121314@Configurationpublic class JwtRsaConfig &#123; //jwt公钥 @Value("$&#123;Jwt_PublicKey_Base64Str&#125;") private String publicKeyBase64Str; //jwt私钥 @Value("$&#123;Jwt_PrivateKey_Base64Str&#125;") private String privateKeyBase64Str; @Bean public JwtRsaHelper generateJwtRsaHelper()&#123; return new JwtRsaHelper(publicKeyBase64Str,privateKeyBase64Str); &#125;&#125; 相关配置文件 1234#Jwt公钥 base64编码的字符串 太长，省略一部分Jwt_PublicKey_Base64Str=MIGfMA0GCSqGSIb3DQEBAQUAA...#Jwt私钥 base64编码的字符串 太长，省略一部分Jwt_PrivateKey_Base64Str=MIICdgIBADANBgkqhkiG... 如何使用，比如 123456789101112131415161718192021222324package cn.shirtiny.community.SHcommunity.Service.ServiceImpl;import ...@Servicepublic class JwtServiceImpl implements IjwtService &#123; @Autowired private JwtRsaHelper jwtRsaHelper; @Override public Map&lt;String, Object&gt; parseJwtByRequest(@NotNull HttpServletRequest request) &#123; Claims claims=null; String jwt = request.getHeader("Authorization"); if (jwt==null)&#123; return null; &#125; try &#123; claims = jwtRsaHelper.parseJwtBody(jwt); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; return claims; &#125;&#125; 5. Shiro与JWT的整合Shiro是基于Session做的认证和权限控制，现在要想修改为依赖JWT来做无状态服务，就不需要使用Session了。 在Shiro创建Subject时，不启用session 123456789101112package cn.shirtiny.community.SHcommunity.Shiro;import ...//关闭sessionpublic class NoSessionWebSubjectFactory extends DefaultWebSubjectFactory &#123; @Override public Subject createSubject(SubjectContext context) &#123; //不使用session context.setSessionCreationEnabled(false); return super.createSubject(context); &#125;&#125; 关闭Shiro的Session存储策略 1234567891011121314151617181920212223242526//不启用session的subject工厂 @Bean("noSessionWebSubjectFactory") public NoSessionWebSubjectFactory generateNoSessionWebSubjectFactory()&#123; return new NoSessionWebSubjectFactory(); &#125; //管理器 实例名为securityManager 注入上面的认证授权器shRealm实例 @Bean("securityManager") public SecurityManager generateSecurityManager(@Qualifier("shRealm") ShRealm shRealm ,@Qualifier("noSessionWebSubjectFactory") NoSessionWebSubjectFactory noSessionWebSubjectFactory) &#123; //管理器，接口的实现使用默认web管理器 DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager(); securityManager.setRealm(shRealm); /* * 关闭shiro自带的session，详情见文档 * http://shiro.apache.org/session-management.html#SessionManagement-StatelessApplications%28Sessionless%29 */ DefaultSubjectDAO subjectDAO = new DefaultSubjectDAO(); DefaultSessionStorageEvaluator defaultSessionStorageEvaluator = new DefaultSessionStorageEvaluator(); defaultSessionStorageEvaluator.setSessionStorageEnabled(false); subjectDAO.setSessionStorageEvaluator(defaultSessionStorageEvaluator); securityManager.setSubjectDAO(subjectDAO); //使用自定的无session工厂 securityManager.setSubjectFactory(noSessionWebSubjectFactory); return securityManager; &#125; 自定Shiro拦截器，根据自己的需求来，下面是一个简单实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package cn.shirtiny.community.SHcommunity.Shiro;import ...//自定义的shiro拦截过滤器//执行流程 preHandle -&gt; isAccessAllowed -&gt; isLoginAttempt -&gt; executeLogin@Componentpublic class ShFilter extends BasicHttpAuthenticationFilter &#123; @Autowired private IjwtService jwtService; //登录认证 授权 @Override protected boolean isAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue) &#123; //如果有登录意向 if (isLoginAttempt(request, response)) &#123; try &#123; //执行登录 登录成功后放行 return executeLogin(request, response); &#125; catch (LoginFailedException e) &#123; //登录出现异常 HttpServletResponse httpServletResponse = WebUtils.toHttp(response); //给一个登录失败错误码 httpServletResponse.setStatus(ShErrorCode.Login_Failed_Error.getCode()); return false; &#125; &#125;else &#123; //不放行 return false; &#125; &#125; //当访问被拒绝时 @Override protected boolean onAccessDenied(ServletRequest request, ServletResponse response) throws Exception &#123; return false; &#125; //是否要尝试登录 @Override protected boolean isLoginAttempt(ServletRequest request ,ServletResponse response) &#123; //请求头的Authorization有值时，表示想尝试登录 HttpServletRequest httpRequest = WebUtils.toHttp(request); String jwt = httpRequest.getHeader("Authorization"); return jwt != null &amp;&amp; !"".equals(jwt.trim());// return super.isLoginAttempt(request,response); &#125; //执行登录 @Override protected boolean executeLogin(ServletRequest request, ServletResponse response) throws LoginFailedException &#123; HttpServletRequest httpRequest = WebUtils.toHttp(request); //解析携带token Map&lt;String, Object&gt; calims = jwtService.parseJwtByRequest(httpRequest); //暂时处理 能解析出来，就登录成功 if (calims!=null)&#123; return true; &#125;else &#123; throw new LoginFailedException("登录失败，令牌无效"); &#125; &#125;&#125; 配置拦截器 1234567891011121314151617181920212223242526272829303132//过滤器工厂 实例名为shiroFilter 注入上面的管理器securityManager实例 @Bean("shiroFilter") public ShiroFilterFactoryBean generateFilterFactory(@Qualifier("securityManager") SecurityManager securityManager) &#123; ShiroFilterFactoryBean factoryBean = new ShiroFilterFactoryBean(); //设置管理器 factoryBean.setSecurityManager(securityManager); //设置登录地址 factoryBean.setLoginUrl("/loginPage"); //设置登录成功后的跳转地址 factoryBean.setSuccessUrl("/"); //设置未授权状态跳转的地址 factoryBean.setUnauthorizedUrl("/403"); // 添加自己的过滤器并且取名为ShFilter Map&lt;String, Filter&gt; filterMap = new HashMap&lt;&gt;(); filterMap.put("shFilter", new ShFilter()); factoryBean.setFilters(filterMap); LinkedHashMap&lt;String, String&gt; filterChainMap = new LinkedHashMap&lt;&gt;(); /*DefaultFilter: anon：无需认证（登录）可以访问 authc：必须认证才可以访问 user：如果使用RememberMe的功能可以直接访问 perms：该资源必须得到资源权限才可以访问 role：该资源必须得到角色权限才可以访问 shFilter：我自定的拦截器 */ filterChainMap.put("/login", "anon"); filterChainMap.put("/shPri/**", "shFilter"); //设置拦截规则 factoryBean.setFilterChainDefinitionMap(filterChainMap); return factoryBean; &#125; shiro整体配置文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140package cn.shirtiny.community.SHcommunity.Config;import at.pollux.thymeleaf.shiro.dialect.ShiroDialect;import cn.shirtiny.community.SHcommunity.Shiro.NoSessionWebSubjectFactory;import cn.shirtiny.community.SHcommunity.Shiro.ShFilter;import cn.shirtiny.community.SHcommunity.Shiro.ShPwdMatcher;import cn.shirtiny.community.SHcommunity.Shiro.ShRealm;import org.apache.shiro.mgt.DefaultSessionStorageEvaluator;import org.apache.shiro.mgt.DefaultSubjectDAO;import org.apache.shiro.mgt.SecurityManager;import org.apache.shiro.spring.LifecycleBeanPostProcessor;import org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor;import org.apache.shiro.spring.web.ShiroFilterFactoryBean;import org.apache.shiro.web.mgt.DefaultWebSecurityManager;import org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import javax.servlet.Filter;import java.util.HashMap;import java.util.LinkedHashMap;import java.util.Map;@Configurationpublic class ShiroConfig &#123; //自定义的shiro密码比较器 实例名为shPwdMatcher @Bean("shPwdMatcher") public ShPwdMatcher generateShPwdMatcher() &#123; return new ShPwdMatcher(); &#125; //认证和授权器 实例名为shRealm 注入上面的密码比较器shPwdMatcher实例 @Bean("shRealm") public ShRealm generateShRealm(@Qualifier("shPwdMatcher") ShPwdMatcher shPwdMatcher) &#123; ShRealm shRealm = new ShRealm(); //设置密码比较器 shRealm.setCredentialsMatcher(shPwdMatcher); return shRealm; &#125; //不启用session的自定subject工厂 @Bean("noSessionWebSubjectFactory") public NoSessionWebSubjectFactory generateNoSessionWebSubjectFactory()&#123; return new NoSessionWebSubjectFactory(); &#125; //管理器 实例名为securityManager 注入上面的认证授权器shRealm实例 @Bean("securityManager") public SecurityManager generateSecurityManager(@Qualifier("shRealm") ShRealm shRealm ,@Qualifier("noSessionWebSubjectFactory") NoSessionWebSubjectFactory noSessionWebSubjectFactory) &#123; //管理器，接口的实现使用默认web管理器 DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager(); securityManager.setRealm(shRealm); /* * 关闭shiro自带的session，详情见文档 * http://shiro.apache.org/session-management.html#SessionManagement-StatelessApplications%28Sessionless%29 */ DefaultSubjectDAO subjectDAO = new DefaultSubjectDAO(); DefaultSessionStorageEvaluator defaultSessionStorageEvaluator = new DefaultSessionStorageEvaluator(); defaultSessionStorageEvaluator.setSessionStorageEnabled(false); subjectDAO.setSessionStorageEvaluator(defaultSessionStorageEvaluator); securityManager.setSubjectDAO(subjectDAO); //使用自定的无session工厂 securityManager.setSubjectFactory(noSessionWebSubjectFactory); return securityManager; &#125; //过滤器工厂 实例名为shiroFilter 注入上面的管理器securityManager实例 @Bean("shiroFilter") public ShiroFilterFactoryBean generateFilterFactory(@Qualifier("securityManager") SecurityManager securityManager) &#123; ShiroFilterFactoryBean factoryBean = new ShiroFilterFactoryBean(); //设置管理器 factoryBean.setSecurityManager(securityManager); //设置登录地址 factoryBean.setLoginUrl("/loginPage"); //设置登录成功后的跳转地址 factoryBean.setSuccessUrl("/"); //设置未授权状态跳转的地址 factoryBean.setUnauthorizedUrl("/403"); // 添加自己的过滤器并且取名为ShFilter Map&lt;String, Filter&gt; filterMap = new HashMap&lt;&gt;(); filterMap.put("shFilter", new ShFilter()); factoryBean.setFilters(filterMap); LinkedHashMap&lt;String, String&gt; filterChainMap = new LinkedHashMap&lt;&gt;(); /*DefaultFilter: anon：无需认证（登录）可以访问 authc：必须认证才可以访问 user：如果使用RememberMe的功能可以直接访问 perms：该资源必须得到资源权限才可以访问 role：该资源必须得到角色权限才可以访问 */ filterChainMap.put("/login", "anon"); filterChainMap.put("/shPri/**", "shFilter"); //设置拦截规则 factoryBean.setFilterChainDefinitionMap(filterChainMap); return factoryBean; &#125; //处理shiro与spring的关联 //使用自定的管理器 配置授权参数源顾问 @Bean public AuthorizationAttributeSourceAdvisor generateAdvisor(@Qualifier("securityManager") SecurityManager securityManager) &#123; AuthorizationAttributeSourceAdvisor advisor = new AuthorizationAttributeSourceAdvisor(); advisor.setSecurityManager(securityManager); return advisor; &#125; //使用代理 @Bean public DefaultAdvisorAutoProxyCreator useProxy() &#123; // 强制使用cglib，防止重复代理和可能引起代理出错的问题 // https://zhuanlan.zhihu.com/p/29161098 DefaultAdvisorAutoProxyCreator proxyCreator = new DefaultAdvisorAutoProxyCreator(); proxyCreator.setProxyTargetClass(true); return proxyCreator; &#125;/* @Bean public LifecycleBeanPostProcessor lifecycleBeanPostProcessor() &#123; return new LifecycleBeanPostProcessor(); &#125;*/ /* //需要在shiro配置文件中增加一个方法，用于thymeleaf和shiro标签配合使用 @Bean public ShiroDialect getShiroDialect() &#123; return new ShiroDialect(); &#125;*/ /*shiro：hasPermission 作用：用于判断用户是否拥有这个权限，有则显示这个div，没有则不显示。 &lt;div shiro:hasPermission="user:add"&gt;进入用户添加功能：&lt;a href="add"&gt;用户添加&lt;/a&gt;&lt;br/&gt; &lt;/div&gt; */&#125;]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>JWT</tag>
        <tag>登录认证</tag>
        <tag>信息安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[H2数据库数据迁移]]></title>
    <url>%2F2019%2F11%2F08%2F%E5%85%B3%E4%BA%8EH2%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8Emysql%E4%B9%8B%E9%97%B4%E7%9A%84%E6%95%B0%E6%8D%AE%E8%BF%81%E7%A7%BB%2F</url>
    <content type="text"><![CDATA[记一次H2与MySQL之间的数据迁移最近在用Golang写爬虫，使用的ORM是Gorm，暂不正式支持嵌入式的H2数据库，所以就用mysql来存爬取到的数据。 由于原先数据是放在H2数据库里的，便产生了在H2和Mysql之间迁移数据的需求。 表结构之前是使用Flyway对H2数据库进行的版本管理，所以之间写的Sql保存了下来，H2与Mysql的Sql语法还是比较像的： H2 创建 user表 1234567891011121314151617181920212223242526create table USER( ID BIGINT auto_increment, NICKNAME VARCHAR(100) not null, PASSWORD VARCHAR(100), EMAIL VARCHAR(200) not null constraint USER_EMAIL_UINDEX unique, AVATARIMAGE VARCHAR(500), GITHUB_ID VARCHAR(500) constraint USER_GITHUB_ID_UINDEX unique, GMT_CREATE BIGINT not null, GMT_MODIFIED BIGINT not null, constraint USER_PK primary key (ID));comment on table USER is '论坛的用户表';comment on column USER.GMT_CREATE is '创建时间戳';comment on column USER.GMT_MODIFIED is '变更时间戳';create unique index USER_ID_UINDEX on USER (ID); Mysql创建user表 12345678910111213141516171819202122create table user( id bigint auto_increment, nickname varchar(100) not null, password varchar(100), email varchar(200) not null, avatarimage varchar(500), github_id varchar(500), gmt_create bigint not null comment '创建时间戳', gmt_modified bigint not null comment '变更时间戳', constraint user_pk primary key (id)) comment '论坛的用户表';create unique index user_id_uindex on user (id);create unique index user_email_uindex on user (email);create unique index user_github_id_uindex on user (github_id); H2增加一个字段 12alter table user add description varchar(20); mysql增加一个字段 12alter table USER add description varchar(20); H2删除字段 1alter table COMMENT drop column CITED_COMMENT_CONTENT; mysql删除字段 1alter table COMMENT drop column CITED_COMMENT_CONTENT; H2修改字段 1234alter table COMMENT alter column CITED_COMMENT_CONTENT VARCHAR(512);alter table SECTION alter column INVITATION_STAR_NUM rename to "Section_TOTAL_CANDY";comment on column SECTION."Section_TOTAL_CANDY" is '版块总糖数'; mysql修改字段 12alter table comment modify cited_comment_content varchar(512);alter table section change invitation_star_num section_total_candy bigint default 0 comment '版块总糖数'; IDEA可以使用ctrl+shift+u把字母批量的改为大写或小写。这样修改sql的目的是想让mysql接续H2的版本控制，大数据量的数据应使用其他方式。 数据表结构迁移完成后，数据的迁移就变得很简单。以前在Oracle和Mysql的数据迁移中，我使用的是Navicat，现在发现IDEA自带的数据库管理工具也挺好用的，IDEA的数据跨库迁移： 找到对应表，确认即可，注意错误信息。]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>H2</tag>
        <tag>flyway</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单websocket聊天室]]></title>
    <url>%2F2019%2F10%2F31%2Fwebsocket%E8%81%8A%E5%A4%A9%E5%AE%A4%2F</url>
    <content type="text"><![CDATA[快速完成聊天室核心功能学习和使用springBoot框架下的websocket，完成聊天室的核心功能 ws引导 Stomp文档 通过阅读文档，配合官方demo，快速的学习和使用websocket技术 服务端 基础版springBoot WebSocketMaven依赖12345&lt;!--WebSocket--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-websocket&lt;/artifactId&gt; &lt;/dependency&gt; 配置类123456789101112131415161718192021222324252627package cn.shirtiny.community.SHcommunity.Config;import org.springframework.context.annotation.Configuration;import org.springframework.messaging.simp.config.MessageBrokerRegistry;import org.springframework.web.socket.config.annotation.EnableWebSocketMessageBroker;import org.springframework.web.socket.config.annotation.StompEndpointRegistry;import org.springframework.web.socket.config.annotation.WebSocketMessageBrokerConfigurer;@Configuration//消息订阅器@EnableWebSocketMessageBrokerpublic class WebSocketConfig implements WebSocketMessageBrokerConfigurer &#123; @Override public void registerStompEndpoints(StompEndpointRegistry registry) &#123; //添加服务端接口 终端点 js连接: let socket=new SockJS('/websocket'); registry.addEndpoint("/websocket").withSockJS(); &#125; @Override public void configureMessageBroker(MessageBrokerRegistry registry) &#123; //允许客户端订阅主题/room registry.enableSimpleBroker("/room"); //注册 app的前缀/app registry.setApplicationDestinationPrefixes("/app"); &#125;&#125; Endpoint为客户端连接服务端websocket服务，服务端通过SimpleBroker控制客户端的订阅的主题、频道，客户端发送消息时，需要带ApplicationDestinationPrefixes中的前缀。 Controller1234567891011@Controllerpublic class WebSocketController &#123; //接收消息的接口路径，聊天室频道 @MessageMapping("/sendToRoom") //发送到 /room/chat 频道 @SendTo("/room/chat") public ShResultDTO&lt;String,Object&gt; retString(@RequestBody ChatMessageDTO message ) &#123; return new ShResultDTO&lt;&gt;(); &#125; @MessageMapping(&quot;/sendToRoom&quot;)，使用上类似于@RequestMapping，不过客户端发送消息时，需要带上ApplicationDestinationPrefixe前缀，如：/app/sendToRoom，使用的为ws协议，完整的写法为：ws://ip:port/app/sendToRoom。 @SendTo(&quot;/room/chat&quot;)会把返回结果广播到/room/chat频道 客户端 基础版sockjs-client + stomp-websocketMaven依赖12345678910&lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;sockjs-client&lt;/artifactId&gt; &lt;version&gt;1.0.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;stomp-websocket&lt;/artifactId&gt; &lt;version&gt;2.3.3&lt;/version&gt; &lt;/dependency&gt; springBoot可以用这种方式使用静态资源，前端页面引入方式： 12&lt;script src="/webjars/sockjs-client/sockjs.min.js"&gt;&lt;/script&gt;&lt;script src="/webjars/stomp-websocket/stomp.min.js"&gt;&lt;/script&gt; 建立连接1234567891011//连接socket connect: function () &#123; //建立socket连接 let socket = new SockJS('/websocket'); stompClient = Stomp.over(socket); //连接socket stompClient.connect(&#123;&#125;, function (frame) &#123; console.log("连接socket: /websocket"); console.log(frame); &#125;); &#125;, 断开连接12345678910111213//断开socket连接 disconnect: function () &#123; console.log(this.isConnected); if (stompClient !== null &amp;&amp; this.isConnected === true) &#123; stompClient.disconnect(() =&gt; &#123; console.log("断开socket连接"); &#125;); this.$notify.success(&#123; title: '√', message: '已断开连接' &#125;); &#125; &#125;, 订阅频道每次订阅都将生成一个客户端id，订阅后会持续接收服务端的广播，每次接收都会更新响应数据 12345678910111213//订阅频道 subscribeChatRoom: function () &#123; //订阅 /room/chat 频道，每次订阅频道广播数据时都会执行回调方法 this.chatSubscribe = stompClient.subscribe('/room/chat', retData =&gt; &#123; // console.log("频道: /room/chat，响应数据为："); // console.log(retData); //存储订阅频道发过来的数据 let res = JSON.parse(retData.body); console.log("你订阅的频道更新啦！！！！！~"); &#125;); console.log("订阅频道，接收到的对象："); console.log(this.chatSubscribe); &#125;, 取消订阅取消订阅需要使用之前此订阅对象的unsubscribe()方法 12345//取消订阅聊天室频道 unsubscribeChat: function () &#123; this.chatSubscribe.unsubscribe(); console.log("取消订阅"); &#125;, 发送消息需要带有指定前缀，header可以为空 1234//发送消息 sendMessage: function () &#123; stompClient.send("/app/sendToRoom", &#123;&#125;, "message"); &#125;, 案例我以我社区的聊天室为例，前端样式上使用了elmentUI的表格，然后进行了自定义： 目前仍在完善中。 前端Vue+Element123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262&lt;!DOCTYPE html&gt;&lt;html lang="en" xmlns:th="http://www.thymeleaf.org"&gt;&lt;script src="/webjars/sockjs-client/sockjs.min.js"&gt;&lt;/script&gt;&lt;script src="/webjars/stomp-websocket/stomp.min.js"&gt;&lt;/script&gt;&lt;el-row id="vue_el_tab" th:fragment="el_tab" class="img-rounded"&gt; &lt;el-tabs v-model="activeName" @tab-click="clickTab" type="border-card"&gt; &lt;el-tab-pane label="聊天室" name="first"&gt; &lt;el-row style="height: 400px"&gt; &lt;el-col :span="24"&gt; &lt;el-table :data="historyMessages" style="width: 100%" max-height="500" id="messageTable" &gt; &lt;!--暂时只支持游客--&gt; &lt;el-table-column label="消息记录 " min-width="280" show-overflow-tooltip&gt; &lt;div slot-scope="scope"&gt; &lt;el-row id="message_header"&gt; &lt;span v-if="scope.row.sender!=null" style="font-style: italic;color: #a185f7"&gt;&#123;&#123;scope.row.sender.nickName&#125;&#125;&lt;/span&gt; &lt;span v-else-if="scope.row.sender==null" style="font-style: italic;color: #a185f7"&gt;游客&#123;&#123;scope.row.senderId&#125;&#125;&lt;/span&gt; &lt;span class="float_right"&gt;&#123;&#123;fomateDate(scope.row.gmtCreated)&#125;&#125;&lt;/span&gt; &lt;/el-row&gt; &lt;el-row id="message_content"&gt; &lt;el-col :span="4"&gt; &lt;el-avatar icon="el-icon-user-solid"&gt;&lt;/el-avatar&gt; &lt;/el-col&gt; &lt;el-col :span="20"&gt; &lt;div style="display: block;"&gt;&#123;&#123;scope.row.chatMessageContent&#125;&#125;&lt;/div&gt; &lt;/el-col&gt; &lt;/el-row&gt; &lt;/div&gt; &lt;/el-table-column&gt; &lt;/el-table&gt; &lt;/el-col&gt; &lt;/el-row&gt; &lt;el-row&gt; &lt;el-col :span="24"&gt; &lt;el-input placeholder="请输入要发送的消息..." v-model="unsendChatMessage" clearable&gt; &lt;/el-input&gt; &lt;p&gt;&lt;/p&gt; &lt;/el-col&gt; &lt;/el-row&gt; &lt;el-row&gt; &lt;el-col :span="24"&gt; &lt;el-tooltip content="发送" placement="bottom" effect="light"&gt; &lt;el-button icon="el-icon-s-promotion" @click="sendMessage" circle&gt;&lt;/el-button&gt; &lt;/el-tooltip&gt; &lt;el-tooltip content="登出" placement="bottom" effect="light"&gt; &lt;el-button id="unSubBtn" icon="el-icon-close" type="danger" class="float_right" @click="unsubscribeChat" circle&gt;&lt;/el-button&gt; &lt;/el-tooltip&gt; &lt;el-tooltip content="登入" placement="bottom" effect="light"&gt; &lt;el-button id="subBtn" icon="el-icon-user-solid" type="success" class="float_right" @click="subscribeChatRoom" circle&gt;&lt;/el-button&gt; &lt;/el-tooltip&gt; &lt;/el-col&gt; &lt;/el-row&gt; &lt;/el-tab-pane&gt; &lt;el-tab-pane label="配置管理" name="second"&gt;配置管理&lt;/el-tab-pane&gt; &lt;el-tab-pane label="角色管理" name="third"&gt;角色管理&lt;/el-tab-pane&gt; &lt;el-tab-pane label="定时任务补偿" name="fourth"&gt;定时任务补偿&lt;/el-tab-pane&gt; &lt;/el-tabs&gt; &lt;/div&gt; &lt;style&gt; #vue_el_tab &#123; background-color: #fff; padding: 20px 20px 20px 20px; width: 400px; &#125; &lt;/style&gt; &lt;script&gt; const vue_el_tab = new Vue(&#123; el: "#vue_el_tab", data() &#123; return &#123; activeName: 'second', //聊天室正在输入的消息 unsendChatMessage: '', //聊天室历史消息 historyMessages: [], //聊天室订阅的对象 为空时为不订阅状态 chatSubscribe: null, //游客id touristID: '', //聊天室每个消息单元格的高度 cellHeight: 94, //标识是否让滚动条 自动跟进新消息 letScollAtFoot: true, &#125;; &#125;, computed: &#123; //游客用户名 touristName: function () &#123; return '游客' + this.touristID &#125; &#125;, methods: &#123; //切换tab时触发 clickTab(tab, event) &#123; console.log("点击tab"); console.log(tab.index); if (tab.index == 0) &#123; //订阅聊天室 this.subscribeChatRoom(); &#125; &#125;, //加载聊天室历史数据 loadChatHistoryDta() &#123; axios.get('/shApi/listChatRoomMessages').then(res =&gt; &#123; this.historyMessages = res.data.data.historyMessages; console.log(this.historyMessages); &#125;) &#125;, //订阅频道 subscribeChatRoom: function () &#123; //已订阅聊天室则不再订阅 if (this.chatSubscribe != null) &#123; return; &#125; //订阅 /room/chat 频道，每次订阅频道广播数据时都会执行回调方法 this.chatSubscribe = stompClient.subscribe('/room/chat', retData =&gt; &#123; // console.log("频道: /room/chat，响应数据为："); // console.log(retData); //存储订阅频道发过来的数据 let res = JSON.parse(retData.body); //更新历史消息 this.historyMessages = res.data.historyMessages; console.log("你订阅的频道更新啦！！！！！~"); &#125;, &#123;id: 'client1'&#125;); console.log("订阅频道，接收到的对象："); console.log(this.chatSubscribe); //订阅，加载聊天室历史数据 this.loadChatHistoryDta(); //提示 this.$notify.success(&#123; title: '√', message: '已订阅聊天室' &#125;); &#125;, //取消订阅聊天室频道 unsubscribeChat: function () &#123; if (this.chatSubscribe == null) &#123; this.$notify.info(&#123; title: '消息', message: '已经退出聊天室了' &#125;); return; &#125; this.chatSubscribe.unsubscribe(); console.log("取消订阅"); //把聊天室订阅对象置为null this.chatSubscribe = null; this.$notify.info(&#123; title: '消息', message: '已退出聊天室' &#125;); &#125;, //发送消息 sendMessage: function () &#123; //在已订阅时，才发送和清空输入框 if (this.chatSubscribe != null) &#123; stompClient.send("/app/sendToRoom", &#123;&#125;, JSON.stringify(&#123; chatMessageContent: this.unsendChatMessage, senderId: Number(this.touristID) &#125;)); //清空输入框 this.unsendChatMessage = ''; &#125; &#125;, //连接socket connect: function () &#123; //建立socket连接 let socket = new SockJS('/websocket'); stompClient = Stomp.over(socket); //连接socket stompClient.connect(&#123;&#125;, function (frame) &#123; console.log("连接socket: /websocket"); console.log(frame); &#125;); &#125;, //断开socket连接 disconnect: function () &#123; console.log(this.isConnected); if (stompClient !== null &amp;&amp; this.isConnected === true) &#123; stompClient.disconnect(() =&gt; &#123; console.log("断开socket连接"); &#125;); this.$notify.success(&#123; title: '√', message: '已断开连接' &#125;); &#125; &#125;, //随机生成一个游客id，从后台获取数据 getTouristID() &#123; axios.get('/shApi/newChatRoomSenderId').then(res =&gt; &#123; console.log("获取游客id"); console.log(res); this.touristID = res.data.data.touristID; &#125;) &#125;, //日期格式化 fomateDate: function (dateStr) &#123; var date = Number(dateStr); date = new Date(date).toLocaleString(); return date.split(" ")[1]; &#125;, //判断滚动条是否在底部 scrollAtFoot: function () &#123; let elTable = $(`#messageTable .el-table__body-wrapper`)[0]; let clientHeight = elTable.clientHeight; let scrollHeight = elTable.scrollHeight; let scrollTop = $('#messageTable .el-table__body-wrapper').scrollTop(); console.log("clientHeight的值为：" + clientHeight + "；scrollHeight为" + scrollHeight + "；scrollTop为" + scrollTop); //当滚动条在底部时 if (scrollHeight - scrollTop === clientHeight) &#123; return true &#125; &#125;, //移动滚动条到底部 moveScroll: function () &#123; //注意，需要在数据更新完成，并且页面渲染完成后才做这件事 $('#messageTable .el-table__body-wrapper').scrollTop((this.historyMessages.length) * this.cellHeight); &#125; &#125;, //vue创建后 created: function () &#123; //连接socket this.connect(); //获取游客id this.getTouristID() &#125;, updated: function () &#123; //如果订阅了频道，并且打开了滚动条跟进 if (this.chatSubscribe != null &amp;&amp; this.letScollAtFoot === true) &#123; // 把滚条移动到最底部 this.moveScroll(); &#125; &#125; &#125;) &lt;/script&gt;&lt;/html&gt; 在聊天室业务中，我们需要在新消息收到后，将滚动条下拉，以便显示新消息。如果使用传统或自定义的组件，这个没有任何问题。 注意，需要在页面渲染完成后再操作滚动条 这里我选用了el-table组件，但其并未对此有相关说明。这里我只能选中el-table的元素进行dom操作： 12//选中el-table的滚动条元素let elTable = $(`#messageTable .el-table__body-wrapper`); 1234567891011121314151617 //判断滚动条是否在底部 scrollAtFoot: function () &#123; let elTable = $(`#messageTable .el-table__body-wrapper`)[0]; let clientHeight = elTable.clientHeight; let scrollHeight = elTable.scrollHeight; let scrollTop = $('#messageTable .el-table__body-wrapper').scrollTop(); console.log("clientHeight的值为：" + clientHeight + "；scrollHeight为" + scrollHeight + "；scrollTop为" + scrollTop); //当滚动条在底部时 if (scrollHeight - scrollTop === clientHeight) &#123; return true &#125; &#125;,//移动滚动条到底部 moveScroll: function () &#123; //注意，需要在数据更新完成，并且页面渲染完成后才做这件事 $('#messageTable .el-table__body-wrapper').scrollTop((this.historyMessages.length) * this.cellHeight); &#125; 后端springBoot仍在完善中。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788package cn.shirtiny.community.SHcommunity.Controller;import ...@Controllerpublic class WebSocketController &#123; @Autowired private IchatHistoryService chatHistoryService; @Autowired private IchatMessageService chatMessageService; //接收消息的接口路径，聊天室频道 @MessageMapping("/sendToRoom") //发送到 /room/chat 频道 @SendTo("/room/chat") public ShResultDTO&lt;String,Object&gt; retString(@RequestBody ChatMessageDTO message ) &#123; //聊天室记录的固定id Long historyId=0L; //发送者id 游客模式 senderId=message.getSenderId(); //接收者id //暂无 //将消息存入数据库 chatMessageService.addChatMessage(message.getChatMessageContent(), historyId, senderId, null); //从数据库中查询此聊天室的消息，广播给该频道 return tolistChatRoomMessages(); &#125; //创建聊天室的聊天记录表 @PostMapping(value = "/shApi/createChatRoomTable") @ResponseBody public ShResultDTO&lt;String,Object&gt; toCreateChatRoomTable()&#123; ChatHistory chatHistory=new ChatHistory(); chatHistory.setChatHistoryId(0L); chatHistory.setChatHistoryName("shChatRoom"); chatHistory.setGmtCreated(System.currentTimeMillis()); chatHistory.setGmtModified(chatHistory.getGmtCreated()); boolean flag = chatHistoryService.addOneChatHistory(chatHistory); return flag ? new ShResultDTO&lt;&gt;(200,"聊天室创建成功") : new ShResultDTO&lt;&gt;(501,"聊天室创建失败，该聊天室已存在"); &#125; //查询聊天室的聊天记录 @GetMapping(value = "/shApi/listChatRoomMessages") @ResponseBody public ShResultDTO&lt;String,Object&gt; tolistChatRoomMessages()&#123; List&lt;ChatMessageDTO&gt; chatMessageDTOs = chatMessageService.selectMessagesByHistoryId(0L); Map&lt;String,Object&gt; map=new HashMap&lt;&gt;(); map.put("historyMessages",chatMessageDTOs); return new ShResultDTO&lt;&gt;(200,"聊天室记录查询完成",map,null); &#125; //清空聊天室的聊天记录 @GetMapping(value = "/shApi/cleanChatRoomMessages") @ResponseBody public ShResultDTO&lt;String,Object&gt; toCleanChatRoomMessages()&#123; chatMessageService.deleteMessagesByhistoryId(0L); return new ShResultDTO&lt;&gt;(200,"聊天室记录已清空"); &#125; //生成一个聊天室游客id @GetMapping(value = "/shApi/newChatRoomSenderId") @ResponseBody public ShResultDTO&lt;String,Object&gt; toNewChatRoomTouristId(HttpServletRequest request)&#123; Map&lt;String,Object&gt; map=new HashMap&lt;&gt;(); Random random=new Random(); int touristIDNumber= random.nextInt(999); //转成字符串，加上时间戳 String touristID=""+System.currentTimeMillis()+touristIDNumber; System.out.println("生成的游客id为："+touristID); map.put("touristID",touristID); //存入session request.getSession().setAttribute("touristID",touristID); return new ShResultDTO&lt;&gt;(200,"生成一个游客id",map,null); &#125;&#125; 表结构ChatHistory 12345678910111213141516171819202122232425package cn.shirtiny.community.SHcommunity.Model;import com.baomidou.mybatisplus.annotation.*;import lombok.Data;//聊天记录、频道@Data@TableName("chat_history")public class ChatHistory &#123; //主键 @TableId(value = "chat_history_id",type = IdType.AUTO) Long chatHistoryId; //聊天记录的名称，唯一 @TableField(value = "chat_history_name",insertStrategy = FieldStrategy.NOT_EMPTY) String chatHistoryName; //聊天创建时间 @TableField(value = "gmt_created",insertStrategy = FieldStrategy.NOT_NULL) Long gmtCreated; //更新时间 @TableField(value = "gmt_modified",insertStrategy = FieldStrategy.NOT_NULL) Long gmtModified; //消息条数 @TableField(value = "message_num",insertStrategy = FieldStrategy.DEFAULT) Long messageNum;&#125; ChatMessage 12345678910111213141516171819202122232425262728package cn.shirtiny.community.SHcommunity.Model;import com.baomidou.mybatisplus.annotation.*;import lombok.Data;//聊天消息@Data@TableName("chat_message")public class ChatMessage &#123; //主键 @TableId(value = "chat_message_id",type = IdType.AUTO) Long chatMessageId; //记录此消息的 聊天记录的id @TableField(value = "chat_history_id",insertStrategy = FieldStrategy.NOT_NULL) Long chatHistoryId; //消息内容 @TableField(value = "chat_message_content",insertStrategy = FieldStrategy.NOT_EMPTY) String chatMessageContent; //创建时间 @TableField(value = "gmt_created",insertStrategy = FieldStrategy.NOT_NULL) Long gmtCreated; //发送者id，可以为空 @TableField(value = "sender_id") Long senderId; //接收者id，可以为空 @TableField(value = "recipient_id") Long recipientId;&#125; DTO对象123456789101112131415161718192021package cn.shirtiny.community.SHcommunity.DTO;import cn.shirtiny.community.SHcommunity.Model.ChatMessage;import lombok.Data;import java.util.List;@Datapublic class ChatHistoryDTO &#123; //主键 Long chatHistoryId; //聊天记录的名称 String chatHistoryName; //聊天创建时间 Long gmtCreated; //更新时间 Long gmtModified; //消息条数 Long messageNum; //记录的消息列表,不在数据库中 List&lt;ChatMessage&gt; chatMessages;&#125; 123456789101112131415161718192021222324package cn.shirtiny.community.SHcommunity.DTO;import lombok.Data;@Datapublic class ChatMessageDTO &#123; //主键 Long chatMessageId; //记录此消息的 聊天记录的id Long chatHistoryId; //消息内容 String chatMessageContent; //创建时间 Long gmtCreated; //发送者id Long senderId; //接收者id Long recipientId; //发送者 UserDTO sender; //接收者 UserDTO recipient;&#125;]]></content>
      <categories>
        <category>开发经验</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>springBoot</tag>
        <tag>socket</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面包屑足迹]]></title>
    <url>%2F2019%2F10%2F25%2F%E9%9D%A2%E5%8C%85%E5%B1%91%E8%B6%B3%E8%BF%B9%2F</url>
    <content type="text"><![CDATA[面包屑导航、足迹的实现 相当于一个路径导航，也可以记录用户的访问历史，常常需要这样一种效果。在我写类似的导航逻辑时，遇到一些问题，在此记录。 导航样式样式原本是想使用element的面包屑导航，如图所示的组件： 123456&lt;el-breadcrumb separator-class="el-icon-arrow-right"&gt; &lt;el-breadcrumb-item :to="&#123; path: '/' &#125;"&gt;首页&lt;/el-breadcrumb-item&gt; &lt;el-breadcrumb-item&gt;活动管理&lt;/el-breadcrumb-item&gt; &lt;el-breadcrumb-item&gt;活动列表&lt;/el-breadcrumb-item&gt; &lt;el-breadcrumb-item&gt;活动详情&lt;/el-breadcrumb-item&gt;&lt;/el-breadcrumb&gt; 后来改了下，并没有使用它的功能，相当于使用普通的div和li： 1234567891011121314151617181920&lt;div id="vue_el_breadcrumb" th:fragment="el_breadcrumb" class="img-rounded "&gt; &lt;!-- 分割线--&gt; &lt;el-divider&gt;&lt;/el-divider&gt; &lt;el-breadcrumb separator="&gt;"&gt; &lt;el-breadcrumb-item&gt;&lt;span class="el-icon-location-information"&gt;&lt;/span&gt;&lt;/el-breadcrumb-item&gt; &lt;el-breadcrumb-item v-for="page in breadcrumb"&gt;&lt;a :href="page.path"&gt;&#123;&#123;page.title&#125;&#125;&lt;/a&gt;&lt;/el-breadcrumb-item&gt; &lt;/el-breadcrumb&gt; &lt;!-- 分割线--&gt; &lt;el-divider&gt;&lt;/el-divider&gt;&lt;/div&gt;&lt;style&gt; #vue_el_breadcrumb &#123; background-color: aliceblue; padding-left: 20px; &#125;&lt;/style&gt; 业务逻辑由于想使用Vue的v-for指令进行动态的遍历，所以需要一个数组，起名为breadcrumb。 原先打算将这个数组存入sessionStorage，在每次切换页面的时候读取、截取这个数组： javaScript1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;script&gt; const vue_el_breadcrumb2 = new Vue(&#123; el: "#vue_el_breadcrumb2", data: &#123; //面包屑数组 breadcrumb: [], //存储当前页信息的对象 curPage:&#123; title:'', path:'' &#125; &#125;, created:function () &#123; //获取当前页信息，并保存 this.curPage.title=document.title; this.curPage.path=window.location.pathname; //读取数组 let breadcrumb= JSON.parse(sessionStorage.getItem("breadcrumb")); //新建一个过渡数组 let newArray=[]; //表示当前页是否已经存在于数组中 let isExist=false; //当获取到的数组不为空时 if (breadcrumb!=null)&#123; //遍历数组 for (let index in breadcrumb)&#123; //把数组中的元素存入过渡数组中 newArray.push(breadcrumb[Number(index)]); //验证当前页是否已存在 if (breadcrumb[Number(index)].path==this.curPage.path)&#123; //覆盖原数组 breadcrumb=newArray; isExist=true; break; &#125; &#125; //为空则使用当前值 &#125;else&#123; breadcrumb=this.breadcrumb; &#125; //不存在时，将当前页添加入数组 if (!isExist)&#123; breadcrumb.push(this.curPage) &#125; //存入sessionStorage sessionStorage.setItem("breadcrumb",JSON.stringify(breadcrumb)); //存入vue data 以遍历 this.breadcrumb=breadcrumb; &#125; &#125;)&lt;/script&gt; 但这样做只解决了重复问题、截取的问题，还有两个Bug，一个是排序，一个是误存，因此，当用户直接访问详情页，然后再访问主页时，就会出现这种情况： Java因此，针对这两项，我做了改善，这是java后端版本的代码，方便查看效果： Controller 1234567891011121314151617181920212223242526272829/**面包屑导航 辅助 * @param curPage 要存储的pageDTO对象 接收json格式 ，如： * &#123; * "title":"标题1", * "path":"路径1" * &#125; * @param request 用于读取session * @return 返回处理后的数组 */ @PostMapping("/shApi/breadcrumbHelper") @ResponseBody public ShResultDTO&lt;String, Object&gt; getBreadcrumbArray( @RequestBody PageDTO curPage, HttpServletRequest request) &#123; //读取session中的数组 PageDTO[] breadcrumb = (PageDTO[]) request.getSession().getAttribute("breadcrumb"); //处理和截取数组 breadcrumb = jsHelperService.cutBreadcrumbArray(breadcrumb, curPage); //把处理后的数组，存入session request.getSession().setAttribute("breadcrumb", breadcrumb); //封装结果 Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put("breadcrumb", breadcrumb); return new ShResultDTO&lt;&gt;(200, "面包屑数组已处理", map, null); &#125; Service 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990package cn.shirtiny.community.SHcommunity.Service.ServiceImpl;import ...@Servicepublic class JsHelperServiceImpl implements IjsHelperService &#123; //创建页码数组 @Override public long[] createPageNumArray(Long curPage, Long pages) &#123; long pageNum = curPage - 3; ShArrayQueue queue = new ShArrayQueue(7); for (int i = 0; i &lt; queue.getMaxSize(); i++) &#123; if (pageNum &gt; 0 &amp;&amp; pageNum &lt;= pages) &#123; queue.add(pageNum); &#125; pageNum++; &#125; return queue.toArray(); &#125; //处理和截取面包屑数组 @Override public PageDTO[] cutBreadcrumbArray(PageDTO[] breadcrumb, PageDTO curPage) &#123; //新建栈 Stack&lt;PageDTO&gt; pageStack = new Stack&lt;&gt;(); //标识是否page已经存在 boolean isExsit = false; //若session中能取到值 if (breadcrumb != null &amp;&amp; breadcrumb.length != 0) &#123; //遍历数组 for (PageDTO pageDTO : breadcrumb) &#123; //只要当前元素path的长度比curPage的path长度小或相等,元素就入栈 if (pageDTO.getPath().split("/").length &lt;= curPage.getPath().split("/").length) &#123; pageStack.push(pageDTO); &#125; //根据路径，比较page与要存入的page相同时 if (curPage.getPath().equals(pageDTO.getPath())) &#123; //相同则表示curPage已经存在，不需要存入curPage，停止继续入栈，舍弃数组以后的元素 isExsit = true; //退出数组遍历 break; &#125; &#125; &#125; else &#123; //如果在session中取不到值 //只要当前的访问页不是主页 if (!curPage.getPath().equals("/")) &#123; //存入一个主页 PageDTO homePage = new PageDTO("主页", "/"); pageStack.push(homePage); &#125; &#125; //在数组中不存在curPage时，存入curPage if (!isExsit) &#123; pageStack.push(curPage); &#125; //排序 常规写法// Comparator&lt;PageDTO&gt; c=new ShPathComparator();// pageStack.sort(c); /* //lambda表达式写法 pageStack.sort( (page1,page2)-&gt;&#123; String[] split1 = page1.getPath().split("/"); String[] split2 = page2.getPath().split("/"); return split1.length-split2.length; &#125; ); */ //或者 pageStack.sort( Comparator.comparingInt(page -&gt; page.getPath().split("/").length) ); //把已入栈元素转为数组，用于覆盖原数组，此处利用toArray()带参数的方法 return pageStack.toArray(new PageDTO[0]); &#125;&#125; 其中，Comparator比较器为 1234567891011//路径比较器public class ShPathComparator implements Comparator&lt;PageDTO&gt; &#123; @Override public int compare(PageDTO page1, PageDTO page2) &#123; String[] split1 = page1.getPath().split("/"); String[] split2 = page2.getPath().split("/"); return split1.length-split2.length; &#125;&#125; 这里对路径path的排序，是通过比较split(“/“)的长度来完成的，正在考虑其他方法。出于某种原因，我并没有采用将导航集合给定的做法。 结果分析 Test_1 ①访问主页： ②访问详情页 ③返回主页 Test_2 ①直接访问详情页 ②再访问主页 在直接访问详情页时，会显示主页、详情页，这里是我刻意的处理，现在还没有对页面标识、排序的思路，暂且这么处理。]]></content>
      <categories>
        <category>开发经验</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>js</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js的数据精度问题]]></title>
    <url>%2F2019%2F10%2F17%2Fjs%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B2%BE%E5%BA%A6%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[前后端数值传递中的 js数值精度损失问题 问题图示：原数值 后端传递的值为1176037389258023221： 接收值js接收到的值为：1176037389258023200 产生原因： JavaScript的Number类型能表示并进行精确算术运算的安全整数范围为：正负2^53^-1，16位数 所以对于后台的long类型数据，在数值过大时，就会出现精度损失。 解决方案： 由于接收时的数据就是损失状态，所以不好在js中直接处理，当然，也有一些方式能够解决这个问题。比如jison，通过它可以对要接收的数据的重新定义json parser。不过，这种情况一般都会交给后端解决，让传递的值转为字符串，这样就不会有精度损失的问题。 后端(java)解决方式示例： ①使用@JsonSerialize注解，作用于实例域的Get方法，在数据输出时将其转为字符串，如： 123456789101112131415package cn.shirtiny.community.SHcommunity.DTO;import ...@Datapublic class InvitationDTO &#123; //输出时转字符串 @JsonSerialize(using = ToStringSerializer.class)//作用于属性的get方法 private long invitationId;//主键id //输出时转字符串 @JsonSerialize(using = ToStringSerializer.class) private long authorId; //作者id @JsonSerialize(using = ToStringSerializer.class) private long gmtCreate;//作者的注册时间&#125; ②直接将DTO对象关于Long类型的属性，设为String类型，在与数据库交互时，进行类型转换： 12345678910package cn.shirtiny.community.SHcommunity.DTO;import ...@Datapublic class InvitationDTO &#123; private String invitationId;//主键id private String authorId; //作者id private String gmtCreate;//作者的注册时间&#125; 注：如果需要字符串类型的uuid，可以使用以下方式，在mapper里写 1234&gt; // 返回String类型的UUID&gt; @Select("SELECT UUID_SHORT()")&gt; String getShortStrUUid();&gt;]]></content>
      <categories>
        <category>开发经验</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
        <tag>long</tag>
        <tag>json</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker容器项目部署]]></title>
    <url>%2F2019%2F10%2F10%2FDocker%E5%AE%B9%E5%99%A8%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%2F</url>
    <content type="text"><![CDATA[【挖坑】使用Docker部署Vue、Go、java项目，Ubuntu18.04不经意看到Docker这个大鲸鱼： 突然好奇它怎么用的，这些技术像动物世界一样。 我在这篇文章记录了自己在Windows、Ubuntu18.04下的Docker安装和使用的过程，顺带记录了Vue项目的Docker部署、Go语言web项目的Docker部署、Nginx反向代理配置、Https，还有Mysql、Redis等部署操作。 安装DockerWindows 专业版、企业版 Docker安装需要windows专业版pro或者 企业版并且需要某个版本以上，具体哪个版本看官网说明， 这个一键安装的方式，我就不说了，因为上个月硬盘挂掉，系统到现在还是盗版的win10，版本还是比较旧的。 家庭版 windows家庭版home 不能直接安装，需要安装Docker ToolBox，照着官方文档下载安装即可，文档单词量不大，很容易懂的，而且只需要下载，然后点下一步就完了。 其中确认系统是否启用虚拟化，是在任务管理器的性能栏里看： 工具箱好像是使用Oracle VM VirtualBox虚拟机软件来跑Docker的，高版本windows的Docker是用Hypervisor。 把Docker ToolBox装好后，运行Docker Quickstart Terminal就行了（需要管理员运行），等它把需要的东西装完，它的快捷方式应该在桌面上，当出现以下画面时，表示已经准备完成，可以使用了： 使用的是Linux的命令，会看到它的ip。 windows下linux命令行推荐： 12345putty wscpwin10 wsl 一个可以在线使用Docker的网站，也可以不用装Docker 1http://play-with-docker.com/ Nginx-alpine一个最小Nginx运行镜像 配置端口映射并运行 1docker run -p 2019:80 nginx:alpine 直接运行 1docker run nginx:alpine 查看运行结果 12http://docker Ip:2019#安装方式的不同，有的也可以在本地http://localhost:2019 bash可交互方式运行 12345docker run -it nginx:alpine sh#linux命令ls -alspwdexit nginx主页root所在目录 1/usr/share/nginx/html 镜像构建与上传构建Vue项目的Docker镜像 cd到Vue项目的文件夹 1npm run build 会生成一个dist文件夹 把dist文件夹放入docker文件夹（自定，存放Dockerfile的文件夹） 打开命令行时，默认是在你安装时选择的Docker ToolBox的安装目录，比如我装在d盘 12pwd#/d/Docker Toolbox 在这个目录建一个Docker文件夹，然后把dist文件夹拷贝到里面 在Docker文件夹下新建一个名为DockerFile的文件，内容如下： 12345FROM nginx:alpineCOPY ./nginx.conf /etc/nginx/conf.d/default.confCOPY ./dist /usr/share/nginx/html 再新建nginx.conf的文件，内容为： 12345678910server &#123; listen 80; set $wwww_data /usr/share/nginx/html; location / &#123; root $wwww_data; index index.html; &#125;&#125; 构建Docker镜像，镜像名只能小写，docker build 会执行Dockerfile文件，-t会给镜像起个名字 12#先cd到刚刚建的Docker文件夹docker build -t shvideo-vue:v0.0.1 ./ 运行镜像 12#映射端口，然后运行docker run -p 2020:80 shvideo:v0.0.1 12#直接运行docker run shvideo:v0.0.1 运行结果 12http://docker Ip:2020#安装方式的不同，有的也可以在本地http://localhost:2020 实用命令 查看运行的容器 12docker psdocker ps -a 停止容器 1234docker stop 容器ID或容器名参数 -t：关闭容器的限时，如果超时未能关闭则用kill强制关闭，默认值10s，这个时间用于容器的自己保存状态docker stop -t=60 容器ID或容器名docker kill 容器ID或容器名 :直接关闭容器 上传Vue项目的Docker镜像 把镜像上传到云空间，以便公网访问 我这里用的阿里云的容器镜像服务，去阿里云找一下就有了，注册就能用。 12345地域：香港命名空间 shirtinycn仓库名称 shvideo-vue代码源：本地仓库在访问凭证栏设置固定密码 Docker Hub/阿里容器登录 12docker login --username=shirtiny registry.cn-hongkong.aliyuncs.com然后输你的密码 重新构建镜像，这次是会存到云空间的 12#还是要cd到刚刚那个docker文件夹 看看这个./docker build -t registry.cn-hongkong.aliyuncs.com/shirtinycn/shvideo-vue:v1.0.0 ./ 推到云空间 1docker push registry.cn-hongkong.aliyuncs.com/shirtinycn/shvideo-vue:v1.0.0 GO项目的Docker镜像 cd 到go项目中，新建Dockerfile、Nginx.conf 编辑Dockerfile为： 12345678910111213141516171819202122232425262728293031323334353637383940414243From golang:1.12 as build#把当前所有目录都放入指定文件夹，包括项目shVideoGoADD ./ /usr/local/GoProject/shVideoGo#工作目录，指定所有的run都在此目录执行WORKDIR /usr/local/GoProject/shVideoGo#环境变量，这里最好写内网ipENV REDIS_ADDR="1.2.3.4:6379"#ENV REDIS_PW=""ENV REDIS_DB="0"ENV MysqlDSN="root:123456@tcp(1.2.3.42)/mydb?charset=utf8&amp;parseTime=True&amp;loc=Local"ENV GIN_MODE="release"ENV PORT=3000#Go的代理ENV GOPROXY="https://goproxy.io"#编译成可以在linux运行的版本（Golang交叉编译） - o 会指定build后的名字RUN CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -o shvideogo#第二段构建FROM alpine:3.7#阿里的镜像RUN echo "http://mirrors.aliyun.com/alpine/v3.7/main/" &gt; /etc/apk/repositories &amp;&amp; \ apk update &amp;&amp; \ apk add ca-certificates &amp;&amp; \ echo "hosts: files dns" &gt; /etc/nsswitch.conf &amp;&amp; \ mkdir -p /www/confWORKDIR /www#从第一段构建中拷贝编译好的可执行文件COPY --from=build /usr/local/GoProject/shVideoGo/shvideogo /usr/bin/shvideogoADD ./conf /www/conf#给它可执行权限，/usr/bin是linux默认放环境变量的地方RUN chmod +x /usr/bin/shvideogo#运行ENTRYPOINT ["shvideogo"] docker容器的所在位置 1docker info | greo Docker 12#更新一下包依赖go mod tidy 构建镜像 1docker build --no-cache -t registry.cn-hongkong.aliyuncs.com/shirtinycn/shvideo-go:v7.0.0 ./ 把镜像推到云空间 推到云空间，会自动创建名为shvideo-go的仓库 1docker push registry.cn-hongkong.aliyuncs.com/shirtinycn/shvideo-go:v7.0.0 其他方式 实在不行，自己编译一个linux的go程序，放到服务器上，emm能用，233。 本地编译，可以看：GO交叉编译 docker windows用起来很不方便，可以选择用远程工具连接（因为是虚拟机上的） 1ip启动时会有，默认用户名是docker，密码是tcuser Java项目的Docker镜像 安装Git 12345sudo apt-get updatesudo apt-get install gitgit config --global user.name "你的用户名，例如github的账号"git config --global user.email "你的邮箱，例如github中的邮件地址"git config --list jdk 123456789101112#可以使用wget下载 #也可以ssh上传scp C:\Users\sh\Downloads\jdk-8u231-linux-x64.tar.gz root@1.2.3.4:/usr/local#解压和重命名文件夹为jdk#配置环境变量vim /etc/profile#添加export JAVA_HOME=/usr/local/jdkexport PATH=$JAVA_HOME/bin:$PATHexport CLASSPATH=.$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar#使环境变量生效source /etc/profile maven 12345678910#下载压缩包sudo wget http://mirror.bit.edu.cn/apache/maven/maven-3/3.6.3/binaries/apache-maven-3.6.3-bin.tar.gz#解压 #重命名文件夹为maven#配置环境变量vim /etc/profile#添加export MAVEN_HOME=/usr/local/mavenexport PATH=$&#123;MAVEN_HOME&#125;/bin:$PATH#使环境变量生效source /etc/profile 把项目从Github上clone下来，使用mvn构建即可 1mvn clean compile package 找到mvn打好的jar包，项目目录下的target文件夹内，新建Dockerfile无后缀: 12345678910111213#基础容器FROM java:8LABEL author="Shirtiny"#把jar包加入容器，放在根目录，命名为test.jarADD test-0.0.1-SNAPSHOT.jar /test.jar#声明8888端口EXPOSE 8888#容器启动时运行ENTRYPOINT ["java","-jar","/community.jar"] 构建镜像 1docker build -t registry.cn-hongkong.aliyuncs.com/shirtinycn/shcommunity:v15 ./ 登陆阿里镜像仓库 12sudo docker login --username=xxxx registry.cn-hongkong.aliyuncs.com#输入密码 推送镜像 1docker push registry.cn-hongkong.aliyuncs.com/shirtinycn/shcommunity:v15 Ubuntu服务器上Docker的安装使用ubuntu 18.04 据说和Docker有莫名的亲密度 日常第一步: 12#获取更新sudo apt-get update 安装Docker，谷歌搜 ubuntu 18.04 install Docker 有个DigitalOcean网站的步骤比较好，能保证Docker版本 1sudo sudo apt install apt-transport-https ca-certificates curl software-properties-common 12#认证Docker证书curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add - 1sudo add-apt-repository "deb [arch=amd64] https://download.docker.com/linux/ubuntu bionic stable" 1sudo apt update 1apt-cache policy docker-ce 安装 1sudo apt install docker-ce 检查运行状态 1sudo systemctl status docker 启动docker 1service docker start 启动Docker管理进程 1docker start compassionate_valhard portainer.io管理工具portainer.io是一个特权容器，可以管理其他的Docker容器，不过需要授权。 安装国内下载比较慢，服务器在国内的话，请使用国内镜像源： 新建文件或编辑 /etc/docker/daemon.json 1vi /etc/docker/daemon.json 写入内容： 1234567&#123; "registry-mirrors": [ "https://dockerhub.azk8s.cn", "https://reg-mirror.qiniu.com", "https://registry.docker-cn.com" ]&#125; 重启Docker 1sudo systemctl restart docker 运行portainer.io 1234#挂载卷，用于保存portainer.io的配置数据docker volume create portainer_data#授权并运行docker run -d -p 9000:9000 -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer 访问服务器的9000端口即可，记得防火墙开放，我的是阿里云的服务器： 1234#所有ip均可访问此端口9000/90000.0.0.0/0#指定ip：1.2.3.4可访问此端口9000/90001.2.3.4/32 portainer.io的使用运行vue项目 创建管理用户后，连接本地Docker，那个local，点进去： 先如图所示创建登录你镜像空间的信息： 12registry.cn-hongkong.aliyuncs.comshirtiny 然后进入Stacks，然后新建stack： 12345678version: '2'services: nginx_shvideo_vue: image: registry.cn-hongkong.aliyuncs.com/shirtinycn/shvideo-vue:v1.0.0 restart: always ports: - 8000:80 如图配置了一个Nginx，是yaml格式，点deploy即可。 现在就已经可以直接访问vue项目了，在8000端口，记得开放端口。 运行Go后台项目123456789101112131415161718version: '2'services: api: image: registry.cn-hongkong.aliyuncs.com/shirtinycn/shvideo-go:v6.0.0 restart: always environment: #golang MYSQL_DSN MYSQL_DSN: "root:123456@tcp(1.2.3.4)/mydb?charset=utf8&amp;parseTime=True&amp;loc=Local" #容器有自己的环境，容器的localhost不是主机的localhost，这里填内网ip地址，阿里会给个私网ip，理论上应该用内网ip。。可我有时候要换成公网ip才能用 REDIS_ADDR: "1.2.3.4:6379" #REDIS_PW: 没设密码 REDIS_DB: "0" SESSION_SECRET: "224895477" GIN_MODE: "release" LOG_LEVEL: "debug" ports: - 3000:3000 运行Java后台项目12345678version: '2'services: shcommunity-java: image: registry.cn-hongkong.aliyuncs.com/shirtinycn/shcommunity:v12 restart: always ports: - 8888:8888 宿主机Nginx反向代理 我们需要对这些项目进行请求的分发，所以我们主机还需要一个Nginx做反向代理 12345678910#主机安装Nginxsudo apt install nginx#修改nginx的配置文件#cd /etc/nginx/sites-enabled，这个目录有一个默认配置文件，对照这个配置文件写#主配置文件在/etc/nginx/ngin.conf，它引入了/etc/nginx/sites-enabled/*vi /etc/nginx/sites-enabled/shvideo.conf#检查文件上下文格式是否写错sudo nginx -t #重启nginxsudo service nginx restart Nginx配置文件shvideo.conf内容为： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657server &#123; listen 80; server_name video.shirtiny.cn; #server_name 1.2.3.4; #vue项目位置，video.shirtiny.cn/，会映射到本地8000端口 location / &#123; proxy_set_header x-Real-IP $remote_addr; proxy_set_header x-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://127.0.0.1:8000; &#125; #后台api，video.shirtiny.cn/api路径，映射到本地3000端口 location /api &#123; proxy_set_header x-Real-IP $remote_addr; proxy_set_header x-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://127.0.0.1:3000; &#125;&#125;server &#123; listen 80; server_name mysql.shirtiny.cn; #server_name 1.2.3.4; #mysql位置，mysql.shirtiny.cn根路径/，会映射到本地3306端口 location / &#123; proxy_set_header x-Real-IP $remote_addr; proxy_set_header x-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://127.0.0.1:3306; &#125;&#125;server &#123; listen 80; server_name docker.shirtiny.cn; #server_name 1.2.3.4; #docker管理工具位置，docker.shirtiny.cn根路径/，会映射到本地端口 location / &#123; proxy_set_header x-Real-IP $remote_addr; proxy_set_header x-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://127.0.0.1:9000; &#125;&#125;server &#123; listen 80; server_name redis.shirtiny.cn; #server_name 1.2.3.4; #docker管理工具位置，redis.shirtiny.cn根路径/，会映射到本地端口 location / &#123; proxy_set_header x-Real-IP $remote_addr; proxy_set_header x-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://127.0.0.1:6379; &#125;&#125; 配置java项目的https链接 https链接需要SSL证书，在腾讯云或者阿里云等域名供应商处可以申请和购买，也可以到Let&#39;s Encrypt申请，相关教程，不过这个教程我是没试过的，我是跟着供应商的教程走的：腾讯云SSL安装、阿里云SSL安装 首先是springBoot项目配置https，springBoot默认集成的服务器是tomcat。把下载好的证书解压，复制证书的tomcat目录下的.jks文件，如果你没有在申请证书时设置密码的话，还会有一个包含密码的.txt文件。 然后将.jks文件复制到springBoot项目的resources目录下： 在项目的配置文件application.properties或yml添加： 123456#SSL证书路径 一定要加上classpath:server.ssl.key-store=classpath:community.shirtiny.cn.jks#SSL证书密码（没设密码，会在keystorePass.txt中给出）server.ssl.key-store-password=123456 XX your pwd#证书类型server.ssl.key-store-type=JKS 然后是配置宿主机Nginx的https，在nginx安装目录建一个自定文件夹cert，用来保存证书解压后的nginx目录下的证书文件，共.crt和.key两个文件。配置nginx的配置文件，这里继续对上文的/etc/nginx/sites-enabled/shvideo.conf添加： 123456789101112131415161718192021222324252627282930313233#社区网站 server &#123; #https端口为443 listen 443 ssl http2;#listen 443 ssl 等于 listen 443 ;加 ssl on; server_name community.shirtiny.cn; #server_name 1.2.3.4; #证书文件名称，相对路径 ssl_certificate cert/1_community.shirtiny.cn_bundle.crt; #私钥文件名称 ssl_certificate_key cert/2_community.shirtiny.cn.key; ssl_session_timeout 5m; #请按照以下协议配置 ssl_protocols TLSv1 TLSv1.1 TLSv1.2; #请按照以下套件配置，配置加密套件，写法遵循 openssl 标准。 ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE; ssl_prefer_server_ciphers on; # / 会映射到本地8888端口 注意这里应该填https location / &#123; proxy_set_header x-Real-IP $remote_addr; proxy_set_header x-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass https://127.0.0.1:8888; &#125; &#125;#http自动重定向到https server &#123; #http端口为80 listen 80; #填写绑定证书的域名 server_name community.shirtiny.cn; #把http的域名请求转成https rewrite ^(.*)$ https://$host$1 permanent; &#125; mysql到Volumes选项，开一个Docker的卷，映射到主机文件目录，用于存储数据库数据，就叫mysql_data好了 123456789101112version: '2'services: docker_mysql: image: mysql:5.6 restart: always environment: MYSQL_ROOT_PASSWORD: 123456 volumes: - mysql_data:/var/lib/mysql/data ports: - 3306:3306 mysql在linux下大小写敏感的问题 12345678910#由于容器内没有编辑器，把配置文件拷贝到宿主机编辑docker cp mysql:/etc/mysql/mysql.conf.d/mysqld.cnf /usr/local#vim mysqld.cnf 增加：lower_case_table_names=1#拷贝回容器 覆盖docker cp /usr/local/mysqld.cnf mysql:/etc/mysql/mysql.conf.d/#重启mysqldocker restart mysql#查看是否修改成功show variables like 'lower%' 通常也会出现1071 (42000) 错误 123#执行sql查询set global innodb_large_prefix=on;set global innodb_file_format=Barracuda; redis依然是开个Docker的卷，名为redis_data 12345678910version: '2'services: docker_redis: image: redis restart: always volumes: - redis_data:/data ports: - 6379:6379 elasticSearch需要2G内存 基础 123456789101112version: '2'services: docker_Es: image: elasticsearch:7.4.2 restart: always ports: - 9200:9200 networks: - somenetwork environment: - discovery.type=single-node 推荐 123#需要2g内存docker network create somenetworkdocker run -d --name elasticsearch --net somenetwork -p 9200:9200 -p 9300:9300 -e "discovery.type=single-node" elasticsearch:7.4.2 123456789101112131415#测试Get http://ip:9200/#增 使用post可以省略id，系统自动生成 #格式类似http://ip:9200/database/table/id http://ip:9200/index/type/id 带上json数据 es版本7以后去除了type的概念，不在支持一个index内多个typePut http://ip:9200/shsipder/user/2#删除Delete http://ip:9200/shsipder/user/2#修改 覆盖式Put http://ip:9200/shsipder/user/2#全查 显示pretty=yrue 每页大小size=100Get http://ip:9200/shsipder/user/_search#条件 age:(&lt;30)Get http://ip:9200/shsipder/user/_search?q=shirtiny#查看表结构Get http://ip:9200/shsipder/_mapping 最后服务器停机，像阿里那种释放cpu、内存、保留硬盘，重启后IP可能会更改、有时需要手动启动docker，mysql等服务会随着Docker启动，只是portainer需要再次手动启动，管理进程也不会自动启动，手动启动的命令如下： 1234#docker容器管理工具 docker run -d -p 9000:9000 -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer#docker管理进程docker start compassionate_valhard 想开机自启的话，写个脚本，配置一下，即可。ubuntu 18.04 的自启配置如下： docker和portainer的自启脚本 1234#fn.service fn是自定服务名touch fn.servicemv ./fn.service /etc/systemd/system &amp;&amp; cd /etc/systemd/systemvi fn.service /etc/systemd/system/fn.service内容 12345678[Unit]After=network.target # tell systemd when script should run[Service]ExecStart=/usr/local/start-portainer.sh[Install]WantedBy=default.target 123456touch start-portainer.sh # new file name fn.sh, you want to start it on booting.mv start-portainer.sh /usr/localchmod 744 /usr/local/start-portainer.sh # 744 means current_user:7(rwx) + current_group:4(r) + other:4(r)systemctl daemon-reload # reload systemd configuration, scan unit changesystemctl enable fn.servicesystemctl start fn.service # pay attention, generally, sudo is neccssary. /usr/local/start-portainer.sh内容 12345#!/bin/sh -e#启动dockersudo service docker start#启动portainerdocker run -d -p 9000:9000 -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer SH社区的更新脚本 运行需要携带tag参数，比如v14 12345678910111213141516171819202122232425#!/bin/sh -e#$1为第一个参数 版本号 比如v12#更新代码库git pull#maven打包mvn clean compile package#拷贝dockerfilecd target/cp ../Dockerfile ./#构建镜像docker build -t registry.cn-hongkong.aliyuncs.com/shirtinycn/shcommunity:$1 ./#登陆阿里云sudo docker login --username=shirtiny registry.cn-hongkong.aliyuncs.com#推送镜像docker push registry.cn-hongkong.aliyuncs.com/shirtinycn/shcommunity:$1#展示镜像列表docker images#停止上一个版本的容器docker stop shcommunity#删除上一个版本的容器docker rm shcommunity#运行镜像docker run -d --restart=always --name shcommunity -p 8888:8888 registry.cn-hongkong.aliyuncs.com/shirtinycn/shcommunity:$1#展示当前运行的容器docker ps 1chmod +x update.sh 123./update.sh#或source update.sh 题外话： nmap可进行端口扫描等，在ubuntu安装很简单: sudo apt-get install nmap]]></content>
      <categories>
        <category>闲谈</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>linux</tag>
        <tag>ubuntu</tag>
        <tag>Vue</tag>
        <tag>Go</tag>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Editor.md、UFile文件上传、回显]]></title>
    <url>%2F2019%2F10%2F09%2FEditorMd%E3%80%81uFile%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E3%80%81%E5%9B%9E%E6%98%BE%2F</url>
    <content type="text"><![CDATA[Editor.md配合UFile图片上传、回显Editor.md是一个开源的Markdown在线编辑器，可作为富文本编辑器使用，UFile是Ucloud对象云存储的服务。 1. Editor.md官网： 引入下载在Github的源码，然后在Html中引入; 12&lt;link rel="stylesheet" href="/editor.md/css/editormd.min.css"/&gt;&lt;script src="/editor.md/editormd.js"&gt;&lt;/script&gt; Markdown编辑器初始化编辑器，可输入内容 1234&lt;div id="editor" class="sh_MdEditor"&gt; &lt;textarea style="display:none;" name="content" id="content" placeholder="在此输入文章内容..."&gt; &lt;/textarea&gt;&lt;/div&gt; 1234567891011121314151617181920212223242526&lt;!--初始化编辑器--&gt;&lt;script type="text/javascript"&gt; $(function () &#123; var editor = editormd("editor", &#123; width: "100%", height: "100%", // markdown: "xxxx", // dynamic set Markdown text path: "/editormd/lib/", // Autoload modules mode, codemirror, marked... dependents libs path delay: 0, codeFold: true, htmlDecode: true, emoji: true, //图片上传 imageUpload: true, imageFormats: ["jpg", "jpeg", "gif", "png", "bmp", "webp"], imageUploadURL: "/imageUpload", // Upload url crossDomainUpload: false, // Enable/disable Cross-domain upload uploadCallbackURL: "", placeholder: '在此输入文章内容，使用markdown语法...', description: "Markdown 文本编辑", lang: &#123; // Language data, you can custom your language. description: "Markdown编辑器&lt;br/&gt;Markdown editor." &#125; &#125;); &#125;);&lt;/script&gt; Markdown解析对Markdown内容进行解析，显示成html，注意，需要额外引入： 12&lt;script src="/editormd/lib/marked.min.js"&gt;&lt;/script&gt;&lt;script src="/editormd/lib/prettify.min.js"&gt;&lt;/script&gt; 1234&lt;!--md解析器 --&gt;&lt;div id="md_viewer" class="sh_MdViewer"&gt;&lt;textarea style="display:none;" th:text="$&#123;invitationDetail.content&#125;"&gt;&lt;/textarea&gt;&lt;/div&gt; 12345678910&lt;script&gt;$(function () &#123; //md解析器 var md_viewer = editormd.markdownToHTML("md_viewer", &#123; // markdown : "[TOC]\n### Hello world!\n## Heading 2", // Also, you can dynamic set Markdown text htmlDecode: true // Enable / disable HTML tag encode. // htmlDecode : "style,script,iframe", // Note: If enabled, you should filter some dangerous HTML tags for website security.&#125;);&#125;);&lt;/script&gt; 图片上传前端配置图片上传需要在初始化md编辑器的js里设置： 123456//图片上传imageUpload: true,//启用图片上传imageFormats: ["jpg", "jpeg", "gif", "png", "bmp", "webp"],//文件格式限制imageUploadURL: "/imageUpload", // 上传地址crossDomainUpload: false, // 是否启用跨域上传uploadCallbackURL: "", //上传完成后的回调地址 表单编辑器上传图片，使用的是&lt;ifram&gt;里的form表单，如图： 只是普通的上传文件，然后对文件进行格式限制，传递文件的参数名为：editormd-file-input Json Data编辑器需要服务器返回Json数据，以此获得上传结果、图片回显地址。 12345&#123; success : 1, // 0 表示上传失败，1 表示上传成功 message : "上传成功或上传失败及错误信息等。", url : "回显需要的图片地址" // 上传成功时才返回&#125; 图片上传Controller通过前端传递过来的参数、需要的返回值，便可以写出一个临时的Controller： 1234567891011121314151617181920212223242526272829package cn.shirtiny.community.SHcommunity.Controller;import ...@Controllerpublic class ImageController &#123; //暂无service //imageService //md编辑器的图片上传表单的name参数值（放在.properties文件中，Md_Editor_imageFile_name=editormd-image-file） @Value("$&#123;Md_Editor_imageFile_name&#125;") private String Md_Editor_imageFile_name; //md图片上传以及回显 @RequestMapping(value = "/imageUpload") @ResponseBody public Md_ImageUpResultDTO uploadImage(HttpServletRequest request)&#123; //转换request MultipartHttpServletRequest multipartRequest= (MultipartHttpServletRequest) request; String downloadUrl=""; //需要md图片表单提交的文件name MultipartFile file = multipartRequest.getFile(Md_Editor_imageFile_name); //调用上传服务 //downloadUrl = imageService.upload(); return new Md_ImageUpResultDTO(1,"上传成功!",downloadUrl); &#125;&#125; 其中，Md_ImageUpResultDTO是服务器上传完成后，返回信息的封装 12345678910111213141516171819package cn.shirtiny.community.SHcommunity.DTO;import lombok.Data;@Datapublic class Md_ImageUpResultDTO &#123; //表示是否上传成功 int success; //提示 String message; //图片地址 String url; public Md_ImageUpResultDTO(int success, String message, String url) &#123; this.success = success; this.message = message; this.url = url; &#125;&#125; 2. UFile使用UFile作为存储上传文件的云空间，因为有20G免费空间。 UFile SDKGithub地址，这里用java版的 Maven引入 12345&lt;dependency&gt; &lt;groupId&gt;cn.ucloud.ufile&lt;/groupId&gt; &lt;artifactId&gt;ufile-client-java&lt;/artifactId&gt; &lt;version&gt;2.2.1&lt;/version&gt;&lt;/dependency&gt; 配置信息公钥、密钥在令牌管理里生成 为了方便修改，将这些固定信息放在xx.properties文件里 1234567891011121314151617181920#md编辑器的图片上传表单的name参数值，由插件表单决定的固定值Md_Editor_imageFile_name=editormd-image-file#是否允许图片上传服务修改文件的名字ImageUploadService_isAllownRename=true#ucloud对象存储 java JDK https://github.com/ucloud/ufile-sdk-java#ucloud对象存储，令牌SHtoken，https://console.ucloud.cn/ufile/tokenucloud_uFile_SHtoken_PublicKey=123456ucloud_uFile_SHtoken_PrivateKey=123456#命名空间的名字ucloud_uFile_bucket_name=shirtinycn#命名空间bucket所在的地区编码,地区编码列表 https://docs.ucloud.cn/api/summary/regionlist.htmlucloud_uFile_bucket_region=cn-gd#域名后缀ufileos.comucloud_uFile_bucket_proxySuffix=ufileos.com#临时下载地址的过期时间,315360000 --&gt; 10 * 365 * 24 * 60 * 60s = 10年ucloud_uFile_downloadURL_expiresDuration=315360000 文件上传Service 接口： 12345678910package cn.shirtiny.community.SHcommunity.Service;import java.io.InputStream;public interface ImageService &#123; //图片文件上传 String upload(InputStream inputStream, String mimeType, boolean allownRename, String clientFileName); //生成随机文件名 String createRandomName(String clientFileName);&#125; 实现类： 授权以及配置 1234// 对象相关API的授权器 ObjectAuthorization OBJECT_AUTHORIZER = new UfileObjectLocalAuthorization(myPublicKey, myPrivateKey); // 对象操作需要ObjectConfig来配置您的地区和域名后缀 ObjectConfig config = new ObjectConfig(region, proxySuffix); 执行上传 123456789101112131415161718192021222324252627PutObjectResultBean response; &#123; try &#123; response = UfileClient.object(OBJECT_AUTHORIZER, config) //可以使用文件的方式，此上传方法有很多同类型的方法 .putObject(inputStream, mimeType) .nameAs(serverFileName) //我命名空间的名字 .toBucket(bucketName) /** * 是否上传校验MD5, Default = true */ // .withVerifyMd5(false) /** * 指定progress callback的间隔, Default = 每秒回调 */ // .withProgressConfig(ProgressConfig.callbackWithPercent(10)) /** * 配置进度监听 */ .setOnProgressListener(new OnProgressListener() &#123; @Override public void onProgress(long bytesWritten, long contentLength) &#123; //已上传/总长度 System.out.println(bytesWritten + "/" + contentLength + "进度：" + (bytesWritten * 100) / contentLength + "%"); &#125; &#125;).execute(); 响应以及回显文件地址 123456789//上传完成后，查看response，然后获得刚刚上传图片的临时地址 //上传成功RetCode是0，错误时的response：&#123;"ResponseCode":400,"RetCode":-30010,"ErrMsg":"bucket not exist","X-SessionId":"0e9df91b-5d69-4e9b-bfeb-5d9b8c182869"&#125; if (response.getRetCode() == 0) &#123; //获取刚刚上传的文件地址，设置过期时间 downloadUrl = UfileClient.object(OBJECT_AUTHORIZER, config) .getDownloadUrlFromPrivateBucket(serverFileName, bucketName, expiresDuration) .createUrl(); return downloadUrl;//出错时，throw new Md_ImageUploadFailedException(e.getMessage()); 全局异常处理 1234567891011121314package cn.shirtiny.community.SHcommunity.Advice;import ...@ControllerAdvice//结合@ExceptionHandler用于全局异常的处理public class myControllerAdvice &#123; @ExceptionHandler(Md_ImageUploadFailedException.class) @ResponseBody public Md_ImageUpResultDTO uploadFileErr(Throwable e)&#123; System.out.println("文件上传失败"); //返回图片上传的失败结果，以及错误信息 return new Md_ImageUpResultDTO(0,e.getMessage(),null); &#125;&#125; Md_ImageUploadFailedException是自定义的异常。 3. 后端完整代码Controller1234567891011121314151617181920212223242526272829303132333435363738394041package cn.shirtiny.community.SHcommunity.Controller;import ...@Controllerpublic class ImageController &#123; @Autowired private ImageService imageService; //md编辑器的图片上传表单的name参数值 @Value("$&#123;Md_Editor_imageFile_name&#125;") private String Md_Editor_imageFile_name; //是否允许服务修改上传到服务器后的文件名 @Value("$&#123;ImageUploadService_isAllownRename&#125;") private boolean ImageUploadService_isAllownRename; //md图片上传以及回显 @RequestMapping(value = "/imageUpload") @ResponseBody public Md_ImageUpResultDTO uploadImage(HttpServletRequest request)&#123; //转换request MultipartHttpServletRequest multipartRequest= (MultipartHttpServletRequest) request; String downloadUrl=""; try &#123; //需要md图片表单提交的文件name MultipartFile file = multipartRequest.getFile(Md_Editor_imageFile_name); if (file != null) &#123; InputStream inputStream = file.getInputStream(); String contentType = file.getContentType(); String filename = file.getOriginalFilename(); //调用上传服务 downloadUrl = imageService.upload(inputStream, contentType, ImageUploadService_isAllownRename, filename); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return new Md_ImageUpResultDTO(1,"上传成功!",downloadUrl); &#125;&#125; Service123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116package cn.shirtiny.community.SHcommunity.Service.ServiceImpl;import ...@Servicepublic class ImageServiceImpl implements ImageService &#123; //公钥 @Value("$&#123;ucloud_uFile_SHtoken_PublicKey&#125;") private String myPublicKey; //私钥 @Value("$&#123;ucloud_uFile_SHtoken_PrivateKey&#125;") private String myPrivateKey; //bucket地域 @Value("$&#123;ucloud_uFile_bucket_region&#125;") private String region; //域名后缀 @Value("$&#123;ucloud_uFile_bucket_proxySuffix&#125;") private String proxySuffix; //名字 @Value("$&#123;ucloud_uFile_bucket_name&#125;") private String bucketName; //临时下载地址的过期时间 // 2 * 60秒 --&gt; 2分钟后过期，315360000 --&gt; 10 * 365 * 24 * 60 * 60 = 10年 @Value("$&#123;ucloud_uFile_downloadURL_expiresDuration&#125;") private int expiresDuration; /**上传文件 * @param inputStream 文件的流 * @param mimeType 文件的ContentType * @param allownRename 是否需要、允许修改文件上传到服务器后的名字 * @param clientFileName 初始文件名 * @return downLoadUrl 返回刚刚上传文件的临时地址 */ @Override public String upload(InputStream inputStream, String mimeType, boolean allownRename, String clientFileName) &#123; //文件上传到服务器后的名字 String serverFileName = clientFileName; //临时下载地址 String downloadUrl = ""; //当允许重命名文件时，命名文件 if (allownRename) &#123; System.out.println("暂时先不重命名，到时候看一下id生成工具"+"emm百度开源的那个雪花算法的uidGenerator要用到数据库"); //暂时用以前自己写的,传到服务器后的文件名 serverFileName=createRandomName(clientFileName); &#125; // 对象相关API的授权器 ObjectAuthorization OBJECT_AUTHORIZER = new UfileObjectLocalAuthorization(myPublicKey, myPrivateKey); // 对象操作需要ObjectConfig来配置您的地区和域名后缀 ObjectConfig config = new ObjectConfig(region, proxySuffix); //待上传文件 //File file = new File("your file path"); PutObjectResultBean response; &#123; try &#123; response = UfileClient.object(OBJECT_AUTHORIZER, config) //可以使用文件的方式 .putObject(inputStream, mimeType) .nameAs(serverFileName) //我命名空间的名字 .toBucket(bucketName) /** * 是否上传校验MD5, Default = true */ // .withVerifyMd5(false) /** * 指定progress callback的间隔, Default = 每秒回调 */ // .withProgressConfig(ProgressConfig.callbackWithPercent(10)) /** * 配置进度监听 */ .setOnProgressListener(new OnProgressListener() &#123; @Override public void onProgress(long bytesWritten, long contentLength) &#123; //已上传/总长度 System.out.println(bytesWritten + "/" + contentLength + "进度：" + (bytesWritten * 100) / contentLength + "%"); &#125; &#125;).execute(); //上传完成后，查看response，然后获得刚刚上传图片的临时地址 //上传成功RetCode是0，错误时的response：&#123;"ResponseCode":400,"RetCode":-30010,"ErrMsg":"bucket not exist","X-SessionId":"0e9df91b-5d69-4e9b-bfeb-5d9b8c182869"&#125; if (response.getRetCode() == 0) &#123; //获取刚刚上传的文件地址，设置过期时间 downloadUrl = UfileClient.object(OBJECT_AUTHORIZER, config) .getDownloadUrlFromPrivateBucket(serverFileName, bucketName, expiresDuration) .createUrl(); return downloadUrl; &#125; &#125; catch (UfileClientException | UfileServerException e) &#123; throw new Md_ImageUploadFailedException(e.getMessage()); &#125; &#125; return downloadUrl; &#125; @Override public String createRandomName(String clientFileName) &#123; //拿到文件后缀名 String suffix = clientFileName.substring(clientFileName.lastIndexOf(".")); //根据当前日期，伪建一个文件夹 String directory = new SimpleDateFormat("yyyy-MM-dd").format(new Date()); //生成新的文件名 //时间戳 long currentTimeMillis = System.currentTimeMillis(); //随机数 Random random = new Random(); int randomInt = random.nextInt(999); //%X 获得数字，把它转为16进制，大写字母 //%04X 增加的04，意思是，转化后的字符串占4个字符，不够用0填充 String fileId=currentTimeMillis+String.format("%04X",randomInt); //组合为传到服务器后的文件名 return directory+"_"+fileId+suffix; &#125;&#125; 4. Editor.md 拓展Md编辑器内容提交、显示，VueJs+Element组合的简单使用。 提交编辑的内容 前端 12345678910111213141516171819202122&lt;div class="col-xs-12 col-sm-9 row_left" id="vue_Editor"&gt; &lt;!-- 编辑文章标题 --&gt; &lt;div class="input-group input-group-lg margin_top"&gt; &lt;span class="input-group-addon" id="sizing-addon1"&gt;title&lt;/span&gt; &lt;input v-model="md_title" class=" form-control" type="text" placeholder="在此输入标题..." aria-describedby="sizing-addon1" name="title"&gt; &lt;/div&gt; &lt;hr/&gt; &lt;!--编辑文章内容--&gt; &lt;h2&gt;&lt;label for="content"&gt;Content&lt;/label&gt;&lt;/h2&gt; &lt;!--md编辑器--&gt; &lt;div id="editor" class="sh_MdEditor"&gt; &lt;textarea style="display:none;" name="content" id="content" placeholder="在此输入文章内容..."&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;!--空文本错误警告--&gt; &lt;!--提交按钮 --&gt; &lt;button type="button" class="btn btn-success btn-lg float_right" @click="submitMd"&gt;发布&lt;/button&gt; &lt;/div&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;!--md编辑--&gt;&lt;script type="text/javascript"&gt; $(function () &#123; const vue_Editor = new Vue(&#123; el: "#vue_Editor", data:&#123; md_title:"", fileUploadErr:false &#125;, methods: &#123; submitMd: function () &#123; //获得编辑区Markdown源码 var md_content=editor.getMarkdown(); console.log('输出title：\n'+vue_Editor.md_title); console.log('输出content：\n'+md_content); //提交数据给后台 axios.post('/createInvitation',&#123; title:vue_Editor.md_title, content:md_content, isAxios:true &#125;).then(function (response) &#123; //成功提交的情况 if (response.data.code==200)&#123; //通知 vue_Editor.$notify(&#123; title: 'OK~', message: response.data.message+"，即将跳转...", type: 'success' &#125;); //2秒后调到最后一页 setTimeout(function () &#123; window.location.href="/?curPage=999999" &#125;,2000); &#125;else if(response.data.code==400)&#123; vue_Editor.$notify.error(&#123; title: 'No~', message: response.data.message &#125;); &#125; &#125;).catch(function (error) &#123; this.$alert(error, '服务器出错', &#123; confirmButtonText: '确定' &#125;); console.log(error) &#125;) &#125; &#125; &#125;); var editor = editormd("editor", &#123; width: "100%", height: "100%", // markdown: "xxxx", // dynamic set Markdown text path: "/editormd/lib/", // Autoload modules mode, codemirror, marked... dependents libs path delay: 0, codeFold: true, htmlDecode: true, emoji: true, //图片上传 imageUpload: true, imageFormats: ["jpg", "jpeg", "gif", "png", "bmp", "webp"], imageUploadURL: "/imageUpload", // Upload url crossDomainUpload: false, // Enable/disable Cross-domain upload uploadCallbackURL: "", placeholder: '在此输入文章内容，使用markdown语法...', description: "Markdown 文本编辑", lang: &#123; // Language data, you can custom your language. description: "Markdown编辑器&lt;br/&gt;Markdown editor." &#125; &#125;); &#125;);&lt;/script&gt; 后端 Controller1234567891011121314151617181920@Controllerpublic class InvitationController &#123; @Autowired private IinvitationService invitationService; @PostMapping(value = "/createInvitation") @ResponseBody public ShResultDTO createInvitation(@RequestBody Invitation invitation, Model model, HttpServletRequest request)&#123; Long userId=((User)request.getSession().getAttribute("user")).getId(); invitation.setAuthorId(userId); boolean flag = invitationService.addInvitation(invitation); if(flag)&#123; return new ShResultDTO&lt;String&gt;(200,"提交成功了哦~"); &#125;else &#123; return new ShResultDTO&lt;String&gt;(400,"标题或内容不能为空，并且字数不能大于20和400"); &#125; &#125; 其中ShResultDTO为返回信息的封装 12345678910111213141516171819202122232425package cn.shirtiny.community.SHcommunity.DTO;import lombok.Data;@Datapublic class ShResultDTO&lt;T&gt; &#123; //状态码 private Integer code; //信息 private String message; //数据 private T data; //错误 String error; public ShResultDTO(Integer code, String message) &#123; this.code = code; this.message = message; &#125; public ShResultDTO(String message, String error) &#123; this.message = message; this.error = error; &#125;&#125; Service接口省略… 1234567891011121314151617181920212223242526272829@Service@Transactionalpublic class InvitationService implements IinvitationService &#123; @Autowired private InvitationMapper invitationMapper; //增加帖子 @Override public boolean addInvitation(Invitation invitation) &#123; if (invitation == null) &#123; return false; &#125; boolean titleIsEmpty = StringUtils.isEmpty(invitation.getTitle()); boolean contentIsEmpty = StringUtils.isEmpty(invitation.getContent()); //判断标题或内容是不是空、标题或内容长度是否超限 if (titleIsEmpty || contentIsEmpty || invitation.getTitle().length() &gt; 20 || invitation.getContent().length() &gt; 2000) &#123; return false; &#125; else &#123; invitation.setGmtCreated(System.currentTimeMillis()); invitation.setGmtModified(invitation.getGmtCreated()); try &#123; invitationMapper.insert(invitation);//插入数据库 return true; &#125; catch (Exception e) &#123; throw new CreateInvitationErrException(e.toString(),4502); &#125; &#125; &#125; 其中CreateInvitationErrExceptio为自定义异常类 全局异常处理12345678910@ControllerAdvice//结合@ExceptionHandler用于全局异常的处理public class myControllerAdvice &#123; @ExceptionHandler(CreateInvitationErrException.class) @ResponseBody public ShResultDTO createInvitationErr(Throwable e)&#123; System.out.println("帖子提交失败，数据库的异常，在应该是InvitationService里抛出"); return new ShResultDTO(4502,e.getMessage()); &#125;&#125; 在Vue对象中对Markdown的解析123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!--md查看器--&gt;&lt;div id="md_viewer" class="sh_MdViewer"&gt; &lt;textarea style="display:none;"&gt;&lt;/textarea&gt;&lt;/div&gt;&lt;!--vueJs--&gt;&lt;script&gt;const vue_invitationDetail_paper = new Vue(&#123; el: "#vue_invitationDetail_paper", data: &#123; //不能用数字，js精度不够 invitationId: '', //帖子对象 invitationDetail: &#123;&#125;, //评论数组 comments:[], user: &#123;&#125;, //未发送的评论内容 commentContent: '', &#125;, created: function () &#123; //获取帖子id this.getInvitationIdFromUrl(); console.log("拿到的帖子id为：" + this.invitationId); //调用api，初始化数据 axios.get('/shApi/invitationDetail/' + this.invitationId).then(res =&gt; &#123; console.log("获取到的数据："); this.invitationDetail = res.data.data.invitationDetail; this.user = res.data.data.user; this.comments=res.data.data.invitationDetail.comments; //帖子内容 let content = res.data.data.invitationDetail.content; console.log("帖子内容" + content); //把帖子内容解析为markdown editormd.markdownToHTML("md_viewer", &#123; markdown: content, //这里动态的设置md内容 htmlDecode: true // Enable / disable HTML tag encode. &#125;); &#125;); &#125; &#125;) &lt;/script&gt;]]></content>
      <tags>
        <tag>uCloud</tag>
        <tag>云空间</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue CLI]]></title>
    <url>%2F2019%2F10%2F06%2FVue3%2F</url>
    <content type="text"><![CDATA[Vue CLI踩坑记录① 安装相关Vue CLI 安装见：官网 cd 到合适的文件夹 1234#安装vue脚手架3npm install -g @vue/cli#安装vue脚手架2的模版 （这样就可以在3里用2的方式创建了）npm i @vue/cli-init -g 版本检查 1vue --version 有时因为权限的原因，没有成功自动配置环境变量，如果出现Vue指令不识别的情况，到node的npm安装目录，找到vue.cmd文件，把它所在的目录配置到环境变量里就可以了。 我的路径： 1C:\Users\Administrator\AppData\Roaming\npm 创建相关cd 到需要的文件夹，创建项目 1234#3的方式vue create 你的项目名#2的方式vue init webpack 项目名 然后上下移动选择框，空格勾选，回车确认 推荐的选择为： 12345678910111213#3 这是mac的推荐选择。vue-routervuexbabelsasseslint#2Runtime-onlyvue-routereslint Standardunit tests n #单元测试e2e tests n #端到端测试 使用selenium等自动操作浏览器自动化测试等use npm 开发相关 引入element的组件方式 1vue add element 引入.vue组件的方式 12345678910&lt;script&gt;import NavBar from './components/NavBar.vue'export default &#123; name: 'app', components: &#123; NavBar &#125;&#125;&lt;/script&gt; 使用.vue组件的方式 12345&lt;template&gt; &lt;div id="app"&gt; &lt;NavBar /&gt; &lt;/div&gt;&lt;/template&gt; 路由 配置router.js 12345678910111213141516171819202122import Vue from 'vue'import Router from 'vue-router'import Home from './views/Home.vue'// import Upload from './views/Upload.vue'Vue.use(Router)export default new Router(&#123; routes: [ &#123; path: '/', name: 'home', component: Home &#125;, //懒加载 &#123; path: '/upload', name: 'upload', component: () =&gt; import('./views/Upload.vue') &#125; ]&#125;) 使用 element组件使用router属性即可，会自动把index属性的值作为路径 显示 1&lt;router-view&gt;&lt;/router-view&gt; devServer代理设置，用于处理跨域请求 配置vue.config.js（没有就在项目根目录创建一个） 12345678910111213141516module.exports = &#123; devServer: &#123; proxy: &#123; '^/api': &#123; target: 'http://localhost:3000', ws: true, changeOrigin: true &#125;, '^/test': &#123; target: 'http://localhost:8888', ws: true, changeOrigin: true &#125; &#125; &#125; &#125; ^/api表示以api开头的所有请求 axios请求的封装接口 随便建个js文件 12345678910111213141516import axios from 'axios'// 视频列表const listVideos = () =&gt; axios.get('/api/video/listVideos').then(res =&gt; res.data)// 视频详情const detailVideo = id =&gt; axios.get(`/api/video/showVideo/$&#123;id&#125;`).then(res =&gt; res.data)// 视频投稿const createVideo = form =&gt; axios.post('/api/video/createVideo', form).then(res =&gt; res.data)//测试const testC = () =&gt; axios.post('/test/c').then(res =&gt; res.data)export &#123; listVideos, detailVideo, createVideo, testC&#125; 对应get无参、有参，post有参 引入封装的axios请求接口，以及使用 Get 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;template&gt; &lt;el-container&gt; &lt;el-aside&gt; &lt;Aside /&gt; &lt;/el-aside&gt; &lt;el-main&gt; &lt;div class=&quot;home&quot;&gt; &lt;h1&gt;首页&lt;/h1&gt; &lt;img alt=&quot;Vue logo&quot; src=&quot;../assets/logo.png&quot; /&gt; &lt;button v-on:click=&quot;listVideos()&quot;&gt;视频列表&lt;/button&gt; &lt;br /&gt; &lt;button v-on:click=&quot;detailVideo()&quot;&gt;视频详情&lt;/button&gt; &lt;br /&gt; &#123;&#123;videos&#125;&#125;, &lt;br /&gt; &#123;&#123;video&#125;&#125; &lt;/div&gt; &lt;/el-main&gt; &lt;/el-container&gt;&lt;/template&gt;&lt;script&gt;// @ 一个 别名 表示 /srcimport HelloWorld from &quot;@/components/HelloWorld.vue&quot;;import NavBar from &quot;@/components/NavBar.vue&quot;;import Aside from &quot;@/components/Aside.vue&quot;;import * as API from &quot;@/api/video/videoAPI.js&quot;;export default &#123; name: &quot;home&quot;, data() &#123; return &#123; videos: [], video: &#123;&#125; &#125;; &#125;, components: &#123; HelloWorld, NavBar, Aside &#125;, methods: &#123; listVideos: function() &#123; console.log(&quot;调用了listVideos方法&quot;); API.listVideos().then(res =&gt; &#123; this.videos = res.data; &#125;); &#125;, detailVideo: function() &#123; console.log(&quot;调用了detailVideo方法&quot;); API.detailVideo(2).then(res =&gt; &#123; this.video = res.data; &#125;); &#125; &#125;&#125;;&lt;/script&gt; Post 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;template&gt; &lt;el-container&gt; &lt;el-aside&gt; &lt;Aside /&gt; &lt;/el-aside&gt; &lt;el-main&gt; &lt;div class="upload"&gt; &lt;h1&gt;投稿&lt;/h1&gt; &lt;el-form ref="form" :model="form" label-width="100px" class="demo-ruleForm" &gt; &lt;el-form-item label="视频标题" prop="video_title"&gt; &lt;el-input v-model="form.video_title"&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label="视频简介" prop="video_info"&gt; &lt;el-input type="textarea" v-model="form.video_info"&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item&gt; &lt;el-button type="primary" @click="uploadV(ruleForm)"&gt;确认投稿&lt;/el-button&gt; &lt;el-button @click="resetForm('ruleForm')"&gt;重置&lt;/el-button&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;/div&gt; &lt;/el-main&gt; &lt;/el-container&gt;&lt;/template&gt;&lt;script&gt;import Aside from "@/components/Aside.vue";import * as API from "@/api/video/videoAPI.js";export default &#123; name: "upload", data() &#123; return &#123; form: &#123; video_title: "", video_info: "" &#125; &#125; &#125;, components: &#123; Aside &#125;, methods: &#123; uploadV: function()&#123; console.log("创建视频") API.createVideo(this.form).then((res=&gt;&#123; console.log(res) &#125;)) &#125; &#125;&#125;;&lt;/script&gt; 自定义css的引入 123&lt;style&gt;@import 'assets/css/shVideo.css';&lt;/style&gt;]]></content>
      <categories>
        <category>学习经验</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GO!]]></title>
    <url>%2F2019%2F10%2F02%2FGO!%2F</url>
    <content type="text"><![CDATA[Java看累了？玩会儿Go吧！It‘s Go！Go的吉祥物： 是不是很沙雕[#233]，有趣的灵魂，爱了爱了。en，Go大概是2010年的新兴语言，和其他老前辈们比还是个小孩子。 Why Go? Go语言Golang，与c一样是一种静态强类型语言，和java一样有垃圾回收机制Gc，支持低消耗的并发，与Docker亲和力极高（因为Docker是Go写的嘛），Go的web程序能在Docker中占用极小的内存。这些都是听别人说的，在逐渐深入的学习中，慢慢总结吧。 Let’s Go!从helloworld开始？ No!! Go的底层原理复杂，但是语法易懂。我们不必从abc开始学习，从开源项目入手，慢慢的去熟悉它，看不懂的地方再去查阅资料。既然学了这么长时间的JavaWeb，我们来看一下Go的Web是什么样的流程呢？ 项目结构这是一个Go的Web开源项目，使用了Gin这个框架，是MVC模式，结构如图所示：它的入口是main.go，这使我们联想到了springBoot，我们只需要在命令行输入go run main.go便可运行这个项目，它会运行在一个端口上。使用PostMan向它的一个接口发送 Post方式的请求，会发生什么事呢？ Server 首先进入了server包下的router.go 123456789// 路由 v1 := r.Group("/api/v1") &#123; //测试 v1.GET("test", api.TestVideo) //增加一个视频 v1.POST("addVideo", api.AddVideo) &#125; 显然，它设置了一个类似于requestMapping的路径，然后指定了这个路径调用的”方法“。 Api 然后，它根据请求路径，调用了api包下的AddVideo 123456789101112131415161718192021222324//所在的包package api//导入包import ( "singo/service" "github.com/gin-gonic/gin")//AddVideo 增加一个视频的方法 c是参数？func AddVideo(c *gin.Context) &#123; //拿到service对象 var service service.CreateVideoService //绑定service error := c.ShouldBind(&amp;service) if error != nil &#123; //service绑定失败 c.JSON(500, ErrorResponse(error)) &#125; else &#123; //调用创建视频的service的create方法 result :=传 result := service.Create(c) c.JSON(200, result) &#125;&#125; 注意，这个注释是我加的，只是一个不懂Go的java使用者的胡猜，并不准确。 然后可以看到，它又调用了一个和service有关的方法，所以我们想，这个api对应Controller，而且前面也说了是MVC模式，所以Service应该也能明白。 1c.JSON(200, result) Controller在返回数据时，使用了c的方法，这个方法应该是返回了Json，而这个c应该是github.com/gin-gonic/gin包下的，Gin是Web框架，所以这个c可能是框架封装好的。 Service 接下来，我们看Controller调用的service里是什么 12345678910111213141516171819202122232425262728293031323334353637383940package serviceimport ( "singo/model" "singo/serializer" "github.com/gin-gonic/gin")// CreateVideoService 创建视频的服务结构体（有点像类）type CreateVideoService struct &#123; VideoID int `form:"video_id" json:"video_id"` VideoTitle string `form:"video_title" json:"video_title" binding:"required"` VideoInfo string `form:"video_info" json:"video_info"`&#125;// Create 创建视频函数func (service *CreateVideoService) Create(c *gin.Context) serializer.Response &#123; //绑定参数，模型:service.xx video := model.Video&#123; VideoID: service.VideoID, VideoTitle: service.VideoTitle, VideoInfo: service.VideoInfo, &#125; //操作数据库，把错误返回 error := model.DB.Create(&amp;video).Error if error != nil &#123; return serializer.Response&#123; Code: 500, Msg: "数据库操作失败", //返回错误信息 Error: error.Error(), &#125; &#125; return serializer.Response&#123; //返回序列化的video，需要调用video的序列化器 Data: serializer.BuildVideo(video), &#125;&#125; 代码想想应该能明白。 1model.DB.Create(&amp;video) 这个方法操作了数据库，这个应该是框架的封装。不过我找到了配置数据库的这段代码： 123456789101112131415161718192021222324252627282930package modelimport ( "singo/util" "time" "github.com/jinzhu/gorm" "github.com/jinzhu/gorm/dialects/mysql")// DB 数据库链接单例var DB *gorm.DB// Database 在中间件中初始化mysql链接func Database(connString string) &#123; db, err := gorm.Open("mysql", connString) db.LogMode(true) // Error if err != nil &#123; util.Log().Panic("连接数据库不成功", err) &#125; //设置连接池 //空闲 db.DB().SetMaxIdleConns(50) //打开 db.DB().SetMaxOpenConns(100) //超时 db.DB().SetConnMaxLifetime(time.Second * 30) DB = db migration()&#125; Model 再次检查Service 应该都看到了这一块代码: 12345video := model.Video&#123; VideoID: service.VideoID, VideoTitle: service.VideoTitle, VideoInfo: service.VideoInfo,&#125; 这里对Video模型和service的Video的参数进行了绑定，Video模型Model代码如下： 12345678910111213package modelimport "github.com/jinzhu/gorm"// "golang.org/x/crypto/bcrypt"// Video 视频模型type Video struct &#123; gorm.Model VideoID int VideoTitle string VideoInfo string&#125; Serializer 最后一个封装，我们在看一遍Service的代码 12345678910//操作数据库，把错误返回 error := model.DB.Create(&amp;video).Error if error != nil &#123; return serializer.Response&#123; Code: 500, Msg: "数据库操作失败", //返回错误信息 Error: error.Error(), &#125; &#125; 我们看一下serializer.Response做了什么： 1234567891011package serializerimport "github.com/gin-gonic/gin"// Response 基础序列化器type Response struct &#123; Code int `json:"code"` Data interface&#123;&#125; `json:"data,omitempty"` Msg string `json:"msg"` Error string `json:"error,omitempty"`&#125; 显然，这是对服务器返回结果的通用序列化封装。 还有一个专门对Video结果序列化的封装 1234return serializer.Response&#123; //返回序列化的video，需要调用video的序列化器 Data: serializer.BuildVideo(video), &#125; serializer.BuildVideo()： 12345678910111213141516171819package serializerimport "singo/model"//Video 视频序列化器结构体type Video struct &#123; VideoID int `json:"video_id"` VideoTitle string `json:"video_title"` VideoInfo string `json:"video_info"`&#125;//BuildVideo 序列化视频func BuildVideo(video model.Video) Video &#123; return Video&#123; VideoID: video.VideoID, VideoTitle: video.VideoTitle, VideoInfo: video.VideoInfo, &#125;&#125; 返回结果 code和msg好像不大对，不过我们成功的向数据库中插入了一条数据，也算是走通了吧。 GORM文档 努力更新中… 基本增删改查第二天睡醒 ？？肥皂君？ 好吧，顺便再把其他几个简单接口看了。增 这个接口我们已经看过了 1POST http://localhost:3000/api/video/createVideo 请求 12345&#123; "video_id":8, "video_title":"8这是新的标题", "video_info":"8这是新的信息"&#125; 响应 123456789&#123; "code": 200, "data": &#123; "video_id": 8, "video_title": "8这是新的标题", "video_info": "8这是新的信息" &#125;, "msg": "视频保存成功"&#125; 为什么不截图？e，图床宕机了，emmm 查One1GET http://localhost:3000/api/video/showVideo/1 响应 123456789&#123; "code": 200, "data": &#123; "video_id": 1, "video_title": "第一个视频标题", "video_info": "第一个go后台" &#125;, "msg": "找到了该视频"&#125; server 12//展示一个视频的详情/:idvideoAPI.GET("showVideo/:id", api.ShowVideo) api 注意id由c.Param(&quot;id&quot;)传入service的函数 12345678910111213//ShowVideo 展示视频的详情func ShowVideo(c *gin.Context) &#123; //service service := service.ShowVideoService&#123;&#125; //绑定(可以不绑定，因为结构体为空，绑定的话必须传个json过来，不过这个是get请求没有body) error := c.ShouldBind(&amp;service) if error != nil &#123; c.JSON(500, ErrorResponse(error)) &#125; else &#123; result := service.Show(c.Param("id")) c.JSON(200, result) &#125;&#125; service 注意这里ShowVideoService的结构体为空，model.DB.Find(&amp;video, id)是根据id查询video表 123456789101112131415161718192021222324252627282930package serviceimport ( "singo/model" "singo/serializer")//ShowVideoService 结构体 注意这个结构体为空type ShowVideoService struct &#123;&#125;//Show show函数有个string类型的idfunc (service *ShowVideoService) Show(id string) serializer.Response &#123; var video model.Video error := model.DB.Find(&amp;video, id).Error //若出错 if error != nil &#123; return serializer.Response&#123; Code: 404, Msg: "未找到指定id的视频", Error: error.Error(), &#125; &#125; //成功则返回数据 return serializer.Response&#123; Code: 200, Msg: "找到了该视频", Data: serializer.BuildVideo(video), &#125;&#125; 查List1GET http://localhost:3000/api/video/listVideos 响应 123456789101112131415161718192021222324252627282930313233343536&#123; "code": 200, "data": [ &#123; "video_id": 1, "video_title": "第一个视频标题", "video_info": "第一个go后台" &#125;, &#123; "video_id": 1, "video_title": "第一个视频标题", "video_info": "第一个go后台" &#125;, &#123; "video_id": 3, "video_title": "第3个视频标题", "video_info": "第3个go后台" &#125;, &#123; "video_id": 4, "video_title": "这是新的标题", "video_info": "这是新的信息" &#125;, &#123; "video_id": 4, "video_title": "第4个视频标题", "video_info": "第3个go后台" &#125;, &#123; "video_id": 8, "video_title": "8这是新的标题", "video_info": "8这是新的信息" &#125; ], "msg": "查询列表完成"&#125; server 12//展示所有视频的列表videoAPI.GET("listVideos", api.ListVideos) api 注意Get请求是无需ShouldBind的 123456789101112//ListVideos 展示所有视频的列表func ListVideos(c *gin.Context) &#123; //service service := service.ListVideosService&#123;&#125; error := c.ShouldBind(&amp;service) if error != nil &#123; c.JSON(500, "服务器出错") &#125; else &#123; result := service.List() c.JSON(200, result) &#125;&#125; service model.DB.Find(&amp;videos)查询videos表中全部数据，特别要注意这里对Videos的序列化处理，看serializer部分 12345678910111213141516171819202122232425262728package serviceimport ( "singo/model" "singo/serializer")//ListVideosService 结构体 注意这个结构体为空type ListVideosService struct &#123;&#125;//List 显示视频列表func (service *ListVideosService) List() serializer.Response &#123; var videos []model.Video error := model.DB.Find(&amp;videos).Error if error != nil &#123; return serializer.Response&#123; Code: 500, Msg: "查找视频时出错，可能是数据库错误", Error: error.Error(), &#125; &#125; return serializer.Response&#123; Code: 200, Msg: "查询列表完成", Data: serializer.BuildVideos(videos), &#125;&#125; serializer BuildVideos进行了一个for循环，将输入的Video数组，输出成序列化的Json 12345678910111213141516171819202122232425262728package serializerimport "singo/model"//Video 视频序列化器结构体type Video struct &#123; VideoID int `json:"video_id"` VideoTitle string `json:"video_title"` VideoInfo string `json:"video_info"`&#125;//BuildVideo 序列化视频func BuildVideo(video model.Video) Video &#123; return Video&#123; VideoID: video.VideoID, VideoTitle: video.VideoTitle, VideoInfo: video.VideoInfo, &#125;&#125;//BuildVideos 序列化视频列表func BuildVideos(items []model.Video) (videos []Video) &#123; for _, item := range items &#123; video := BuildVideo(item) videos = append(videos, video) &#125; return videos&#125; 删1DELETE localhost:3000/api/video/deleteVideo/7 响应 1234&#123; "code": 200, "msg": "删除成功"&#125; server 12//删除一个视频videoAPI.DELETE("deleteVideo/:id", api.DeleteVideo) api 注意这里不用shoudbind，否则必须携带json数据 12345678//DeleteVideo 删除一个视频func DeleteVideo(c *gin.Context) &#123; //sercice service := service.DeleteVideoService&#123;&#125; //结构体为空，不需要接json参数，不用shoudbind result := service.Delete(c.Param("id")) c.JSON(200, result)&#125; service 先查询，然后直接将查询到的数据作为参数，执行删除 1234567891011121314151617181920212223242526272829303132333435363738package serviceimport ( "singo/model" "singo/serializer")// DeleteVideoService 创建视频的服务结构体（有点像类）type DeleteVideoService struct &#123;&#125;// Delete 创建视频函数func (service *DeleteVideoService) Delete(id string) serializer.Response &#123; var video model.Video //先查询该视频是否存在 error := model.DB.First(&amp;video, id).Error //若出错 if error != nil &#123; return serializer.Response&#123; Code: 404, Msg: "未找到指定id的视频", Error: error.Error(), &#125; &#125; //存在则执行删除 error = model.DB.Delete(&amp;video).Error if error != nil &#123; return serializer.Response&#123; Code: 500, Msg: "删除失败", Error: error.Error(), &#125; &#125; return serializer.Response&#123; Code: 200, Msg: "删除成功", &#125;&#125; 改1PUT http://localhost:3000/api/video/updateVideo/4 请求 12345&#123; "video_id":4, "video_title":"这是新的标题", "video_info":"这是新的信息"&#125; 响应 123456789&#123; "code": 200, "data": &#123; "video_id": 4, "video_title": "这是新的标题", "video_info": "这是新的信息" &#125;, "msg": "视频保存成功"&#125; server 12//更改一个视频videoAPI.PUT("updateVideo/:id", api.UpdateVideo) api 注意，这里既使用了ShouldBind绑定，又使用c.Param(&quot;id&quot;)向service.Update()传递了id的值 12345678910111213//UpdateVideo 更新一个视频func UpdateVideo(c *gin.Context) &#123; //service service := service.UpdateVideoService&#123;&#125; //绑定 error := c.ShouldBind(&amp;service) if error != nil &#123; c.JSON(500, ErrorResponse(error)) &#125; else &#123; result := service.Update(c.Param("id")) c.JSON(200, result) &#125;&#125; service 首先是结构体，先使用传递过来的id查询了要修改的video信息，然后把service在ShouldBind获得的信息，传给了video，最后保存video 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package serviceimport ( "singo/model" "singo/serializer")// UpdateVideoService 创建视频的服务结构体（有点像类）type UpdateVideoService struct &#123; VideoID int `form:"video_id" json:"video_id"` VideoTitle string `form:"video_title" json:"video_title" binding:"required"` VideoInfo string `form:"video_info" json:"video_info"`&#125;// Update 修改更新视频函数func (service *UpdateVideoService) Update(id string) serializer.Response &#123; //绑定参数，模型:service.xx video := model.Video&#123;&#125; //先查询数据库，找到对应user，把错误返回 error := model.DB.First(&amp;video, id).Error if error != nil &#123; return serializer.Response&#123; Code: 500, Msg: "数据库中未能找到对应视频", //返回错误信息 Error: error.Error(), &#125; &#125; //修改，把service通过c绑定，接收到的json数据，赋给model video.VideoID = service.VideoID video.VideoTitle = service.VideoTitle video.VideoInfo = service.VideoInfo //把video保存到数据库 error = model.DB.Save(&amp;video).Error if error != nil &#123; return serializer.Response&#123; Code: 500, Msg: "视频保存失败", //返回错误信息 Error: error.Error(), &#125; &#125; return serializer.Response&#123; //返回序列化的video，需要调用video的序列化器 Data: serializer.BuildVideo(video), Code: 200, Msg: "视频保存成功", &#125;&#125; 是不是觉得这些代码太过简单？当然，因为其实是我写的，233。]]></content>
      <categories>
        <category>闲谈</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>Gin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[八种排序算法]]></title>
    <url>%2F2019%2F09%2F22%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[数据结构与算法排序Sort 其中： 一轮结束后能够确定一个元素的最终位置的排序方法有是 简单选择排序、快速排序、冒泡排序、堆排序。 1. 冒泡排序BubbleSort冒泡排序思路： 每次遍历数组，都会比较相邻元素的大小，如果满足条件，就把两个元素交换位置。 这样，每遍历一遍数组，都会把最大或最小的元素放在数组尾部，就像气泡上浮一样。 显然，如果有m个数，则最多要遍历m-1次。 优化： 在一轮遍历中，我们无需再比较最后一个数，所以每轮遍历要比较m-1次而在一轮遍历中，我们还无需再比较前几轮遍历产生的“尾泡”如果遍历n轮，就会产生n个“尾泡”，所以，在此轮遍历中只需要比较m-1-n次如果在某轮遍历中，发现遍历的数组依然有序，这时可以不再进行下轮遍历我们只需要加一个，标志数组是否发生过交换的变量，根据变量判断数组是否已经有序 实现很简单，如： 123456789101112131415161718192021222324252627282930313233343536373839404142434445package Sort;import java.util.Arrays;public class BubbleSorting &#123; //冒泡排序方法 public int[] bubbleSort(int[] array) &#123; int temp; //标识此次排序是否发生改变 boolean isChanged = false; //开始排序 for (int n = 0; n &lt; array.length - 1; n++) &#123; //把最大的数浮动到末尾，i循环到array.length-1即可，因为i为倒数第二时，会比较array[i]和array[i+1]， //此时倒数第一的数已经比较过了，也防止数组越界 for (int i = 0; i &lt; array.length - 1 - n; i++) &#123; //开始本次冒泡前，把isChanged置为false //如果前面的数比后面的数大，交换位置 if (array[i] &gt; array[i + 1]) &#123; temp = array[i]; array[i] = array[i + 1]; array[i + 1] = temp; //位置发生变化，把isChanged置为true isChanged = true; &#125; &#125; //for检查一遍数组后，发现isChanged的值未变化 if (!isChanged)&#123; //退出循环 break; &#125;else &#123; //把isChanged改回来 isChanged=false; &#125; System.out.println(Arrays.toString(array)); &#125; return array; &#125;&#125;class BubbleSortingTest &#123; public static void main(String[] args) &#123; int[] arr = &#123;5, 7, 4, 6, 3, 1, 2, 9, 8&#125;; BubbleSorting bubbleSorting = new BubbleSorting(); int[] sorted = bubbleSorting.bubbleSort(arr); &#125;&#125; 2. 快速排序QuickSort快速排序采用了分而治之的思想： 通过一个基准数pivot来把整个数组分成两部分，一部分全大于pivot，一部分全小于pivot，然后把pivot放在这两部分中间，这样就找到了pivot的正确位置。 然后再对每个部分再次进行同样的分割，通常使用递归来实现，一直到不能再分割为止。 这样分割完成后，就得到一个有序的数列。 这里，我们通过两个指针来对数组array进行分割：取数组最后一个数为基准数pivot，其下标为pivotIndex设一个快指针quickP，它会遍历数组从左端到pivot之前的所有数，不包括pivot设一个慢指针slowP，它只在快指针发现当前数小于基准数时移动1次，慢指针从数组左端-1开始。慢指针slowP移动后，会把array[slowP]与array[quickP]交换当快指针quickP遍历完成后，交换array[slowP+1]与array[pivotIndex]，这样就把pivot放在了正确的位置。可以看这个视频，能够方便理解：图解快速排序，也可以直接看代码，我注释很多 java实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081package Sort;import java.util.Arrays;public class QuickSorting &#123; //快指针，始终移动 int quickP = 0; //慢指针，当快指针满足条件时移动 int slowP; //基准数、中间点 int pivot; //基准数所在位置 int pivotIndex; //temp交换的中间变量 int temp; /** * 用于分割数组 * * @param array 待分割数组 * @param left 数组左端点 * @param right 数组右端点 */ public int partition(int[] array, int left, int right) &#123; //慢指针初始位置是左端点的前一个点 slowP = left - 1; //设数组最后一个数为基准数 pivot = array[right]; pivotIndex = right; //在数组头到基准数之间遍历 for (quickP = left; quickP &lt; pivotIndex; quickP++) &#123; //若发现当前数比基准数小 if (array[quickP] &lt; pivot) &#123; //慢指针后移 slowP += 1; //把快指针的数与慢指针的数交换位置 temp = array[quickP]; array[quickP] = array[slowP]; array[slowP] = temp; &#125; &#125; //退出循环后，交换slowP+1和基准数，这样通过slowP+1把数组分为了两部分 temp = array[slowP + 1]; array[slowP + 1] = array[pivotIndex]; array[pivotIndex] = temp; return slowP + 1; //于是数组分成的两部分为：[left,slowP+1-1]、[slowP+1+1,right] &#125; /** *递归分割来完成排序 * @param array 待分割数组 * @param left 数组左端点 * @param right 数组右端点 */ public void quickSort(int[] array, int left, int right) &#123; //不停分割数组，直到最后分成的数组左端点=右端点 if (left &gt;= right) &#123; return; &#125; //接收分割完成后的中点下标，中点不再参与分割和排序 pivotIndex = partition(array, left, right); //左边的数组：[left,pivotIndex-1] quickSort(array, left, pivotIndex - 1); //右边的数组：[pivotIndex+1,right] quickSort(array, pivotIndex + 1, right); &#125;&#125;//测试class QuickSortingTest &#123; public static void main(String[] args) &#123; int[] array = &#123;0, 7, 4, 6, 3, 1, 2, 9, 8, 5&#125;; QuickSorting quickSorting = new QuickSorting(); quickSorting.quickSort(array, 0, array.length - 1); System.out.println(Arrays.toString(array)); &#125;&#125; 3. 选择排序SelectionSort选择排序每轮遍历数组，会把数组中的最值放在数组头部或尾部，即每轮都会找到一个最小的数或最大的数。 显然，选择排序与冒泡排序思路类似，都是每轮遍历找到一个最值，只是交换的方式有区别。我们只需关注这一点即可：冒泡排序是依次比较，把符合条件的两个相邻元素交换位置，这样把最值交换到末尾选择排序，是假定一个数是最值，然后依次与数组中的数据比较，让满足条件的数替换这个假定的数，一轮遍历完成后，再让它与当前数组尾或头部的数交换 很简单，不需要细说。 java实现 如： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package Sort;import java.util.Arrays;public class SelectSorting &#123; //一轮遍历中的最小值 private int minValue; //最小值的下标 private int minIndex; //交换位置时，需要的中间量 private int temp; //标识最小数是否发生改变、 private boolean minIsChanged=false; public int[] SelectSort(int[] array) &#123; //遍历n轮 for (int n = 0; n &lt; array.length; n++) &#123; //取当前轮次的数组第一个数为最小数，并记录其下标 minIndex = n; minValue = array[minIndex]; //一轮中的遍历，i从当前轮次数组的第二个数开始 for (int i = n + 1; i &lt; array.length ; i++) &#123; //若数组中有比minValue还小的数，把它赋给minValue，并记录下标，然后标识出最小值已经改变 if (array[i] &lt; minValue) &#123; minIndex = i; minValue = array[minIndex]; minIsChanged=true; &#125; &#125; //一轮遍历完毕，将得到的最小数与当前轮数组的第一个数交换位置 //若最小值没有变化，即minIsChanged为false时，不需要交换 if (minIsChanged)&#123; temp = array[minIndex]; array[minIndex] = array[n]; array[n] = temp; &#125; &#125; //排序完成后打印数组 System.out.println(Arrays.toString(array)); return array; &#125;&#125;class SelectSortingTest&#123; public static void main(String[] args) &#123; int[] array=&#123;5, 7, 4, 6, 3, 1, 2, 9, 8&#125;; SelectSorting selectSorting=new SelectSorting(); selectSorting.SelectSort(array); &#125;&#125; 4. 插入排序InsertionSort插入排序把数组分为两个部分，一部分视为有序，初始只有一个元素；另一部分是无序，包含其他的数组元素 在每轮遍历时，取出无序部分的数，经过比较后插入到有序部分中，使有序部分仍然有序。随着每轮的遍历，无序部分的数被插入到有序部分中，最终，只剩下一个有序的数组。 主要的难点在于如何找到有序部分的插入位置，并将有序的一部分数后移，先看第一种实现： java实现① 1234567891011121314151617181920212223242526public int[] insertSort(int[] array) &#123; //从array[0]到array[n]是有序部分 //从array[n+1]到末尾，是无序部分 for (int n = 0; n &lt; array.length-1; n++) &#123; //取出一个无序部分头部的数，注意，此时该位置的数据可以视为“空” disOrderNum = array[n + 1]; //遍历有序部分进行比较和执行插入 for (int i = 0; i &lt; n + 1; i++) &#123; //若取出的无序数比某个有序数小，把它放在这个有序数的前面 if (disOrderNum &lt; array[i]) &#123; //把有序部分最末尾的数后移1位 （相当与，此时把有序的末尾，放在无序的头部） array[n + 1] = array[n]; //把i以后的有序数后移1位 for (int j = n; j &gt; i; j--) &#123; array[j] = array[j - 1]; &#125; //插入无序数 array[i] = disOrderNum; //进入下一轮循环 break; &#125; &#125; &#125; System.out.println(Arrays.toString(array)); return array; &#125; 这里使用3个for循环嵌套，显然，是非常耗费性能的。我们对有序数后移这部分，进行优化： 我们可以在比较大小时，就把有序数后移 java实现② 1234567891011121314151617181920212223242526//优化 public int[] insertSort2(int[] array) &#123; //从array[0]到array[n]是有序部分 //从array[n+1]到末尾，是无序部分 for (int n = 0; n &lt; array.length - 1; n++) &#123; //取出一个无序部分头部的数，注意，此时该位置的数据可以视为“空” disOrderNum = array[n + 1]; //遍历有序部分进行比较和执行插入 int index; //指针，从有序部分尾部开始遍历，此时n+1的位置是可以被有序部分利用的空间，可以视为有序部分末尾 index = n + 1; while (true) &#123; //当index到达有序部分头部，或待插入数找到合适位置时 if (index == 0 || disOrderNum &gt; array[index - 1]) &#123; //从后向前遍历，与下一个值比较，插入到当前位置 array[index] = disOrderNum; break; &#125; //把有序数的位置后移 array[index] = array[index - 1]; index--; &#125; &#125; System.out.println(Arrays.toString(array)); return array; &#125; 5. 希尔排序ShellSort希尔排序是插入排序的一个更高效的改进版本，又称缩小增量排序 排序流程示意图： 它事先以一个可变增量对数据分组，然后在对每组进行插入排序。 第一次分组：增量为arrary.length/2 第二次分组：增量为arrary.length/4 第n次分组：增量为arrary.length/2n 这里增量可以看作两个数下标的差值，直到增量为1时，此时只有一组数据，不再分组。 tips： 增量可以自定，只要保证增量能递减，并且最后的值是1就可以。 所以为了避免分组后的数据仍然有序的最坏情况，我们可以使用： Hibbard增量序列：第n个增量值=2的n次方-1 或者Sedgewick增量序列，可以处理上万的数据。 这是比较简单的算法，我们只需要在分组后使用插入排序即可： 图解，对照代码来理解，ABC为3个分组： java实现 12345678910111213141516171819202122232425262728//排序1 public void shellSort1(int[] array) &#123; //用于改变增量的for循环 for (int gap = array.length / 2; gap &gt;= 1; gap = gap / 2) &#123; //n从0开始，array[n+gap]是第n个分组的第二个元素，即第一个待插入元素，插入到array[n]那一部分中 for (int i = gap; i &lt; array.length; i++) &#123; //所以这里i初始=0+gap意为第1个分组的第2个元素，随着i的增加，i就=1+gap、2+gap....n+gap，会遍历所有分组的第一个元素以后的所有元素。 // 所以这个for循环是为了拿到所有待插入元素 int j = i; //存储待插入元素，array[j]表示各个分组待插入到有序部分的元素 int temp = array[j]; //使用j来倒序遍历各个分组的有序部分 while (true) &#123; //当待插入数大于前一个数时，找到插入的位置，插入后，退出循环 if (j - gap &lt; 0 || temp &gt; array[j - gap]) &#123; array[j] = temp; break; &#125; //没找到位置时，将分组中的数后移 array[j] = array[j - gap]; //j以gap为间隔，以此来遍历分组 j -= gap; &#125; &#125; &#125;// System.out.println(Arrays.toString(array)); &#125; 另外一种思路： 这是增量gap的for循环： 1for (int gap = array.length / 2; gap &gt;= 1; gap = gap / 2) &#123;&#125; 会得到gap个分组 123//比如array[1]和array[1+gap]、array[1+2*gap]是一组的//比如array[2]和array[2+gap]、array[2+2*gap]是另外组的for (int i = 0; i &lt; gap; i++)&#123;&#125; 遍历每个分组 1for (int j = i + gap; j &lt; array.length; j = j + gap) &#123;&#125; 完整代码 123456789101112131415161718192021222324252627282930313233343536public void shellSort(int[] array) &#123; //用于改变增量的for循环 for (int gap = array.length / 2; gap &gt;= 1; gap = gap / 2) &#123; //使用增量对数据分组，显然有gap个需要处理的组，这是遍历出每组的for循环 //比如array[1]和array[1+gap]、array[1+2*gap]是一组的 //比如array[2]和array[2+gap]、array[2+2*gap]是另外组的 for (int i = 0; i &lt; gap; i++) &#123; //对当前所在的组进行插入排序，我们这里先采用交换的方式 //显然，如果把j每轮递增的值设为gap，那么就可以用array[j]来表示当前分组中数 for (int j = i + gap; j &lt; array.length; j = j + gap) &#123; //临时保存当前值 int temp = array[j]; //指针，初始值为当前数的前一个数的位置，递减 int preIndex = j - gap; //下面的代码会把array[preIndex]和array[j]交换 while (true)&#123; if (preIndex&lt;0)&#123; break; &#125; if (array[preIndex]&lt;temp)&#123; break; &#125; //把当前指向的值赋给后一位 array[preIndex+gap]=array[preIndex]; //指针前移，只会移动1次 preIndex=preIndex-gap; &#125; //当退出循环时，preIndex会在一开始的array[preIndex]之前 array[preIndex+gap]=temp; &#125; &#125; &#125;// System.out.println(Arrays.toString(array)); &#125; 6. 归并排序Mergesort归并排序的核心思想是： 把两个有序数组(实际上，这两个有序数组其实是整个数组的一部分)，通过第三个temp数组，合并为新的有序数组。 而如何获得这两个有序数组呢？ 将待排的无序数组不停拆分，直到不可再拆，这样就得到一个个只包含1个元素的数组，我们可以把它视为有序数组。 显然，归并排序也使用了分而治之的思想。 归并的图解： 具体实现：先看两个有序数组的合并①设两个指针i与j来遍历各自的数组部分，下图用绿色和红色来表示两个部分，它们的初始位置都在各自部分的头部。依次比较i与j对应的值，把较小的一方放入一个temp临时数组，当指针指向的值已经被放入temp后，对应指针后移，temp的指针也后移，以此类推：②当绿色或者红色部分有一方的数已经全放入了temp，那么把另一部分的数一次性全放入temp中，如此，这两部分的数就已经全放入到temp中了，最后，把temp中的数再复制回去，覆盖掉，这样就结束了本次合并，得到了一个有序数组。拆分阶段较为简单，只需要直到每次要拆分的数组的左端点left和右端点right，就可以得到中间点pivot，这样会得到[left,pivot]和[pivot+1,right]这两部分数组，然后把对应数组再次拆分即可 代码实现1 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970package Sort;import java.util.Arrays;public class MergeSorting &#123; public void merge1(int[] array, int[] temp, int left, int pivot, int right) &#123; //temp的指针 int t=0; //这样原数组就分为两个有序部分，[left,pivot],[pivot+1,right] //指向前部分的头部 int leftP1 = left; //指向后部分的头部 int leftP2 = pivot + 1; //直到有一部分的指针已经走到尾部 while (leftP1 &lt;= pivot &amp;&amp; leftP2 &lt;= right) &#123; //若前部分的指针，所在位置的值比另外一个指针的小，把对应值存到temp数组中， // 然后前部分的指针和temp的指针后移 if (array[leftP1] &lt;= array[leftP2]) &#123; temp[t] = array[leftP1]; leftP1++; t++; //否则就是后部分的指针的值小 &#125; else &#123; temp[t] = array[leftP2]; leftP2++; t++; &#125; &#125; //把后部分指针的剩余数，全放入temp while (leftP1 &lt;= pivot) &#123; temp[t] = array[leftP1]; t++; leftP1++; &#125; //把前部分指针的剩余数，全放入temp while (leftP2 &lt;= right) &#123; temp[t] = array[leftP2]; t++; leftP2++; &#125; //把temp的值导入array t=0; for (int leftP=left;leftP&lt;=right;leftP++)&#123; array[leftP]=temp[t]; t++; &#125; &#125; public void mergeSort(int[] array, int[] temp, int left, int right) &#123; //当left&lt;right的时候就一直拆分 if (left &lt; right) &#123; int pivot = (left + right) / 2; mergeSort(array, temp, left, pivot); mergeSort(array, temp, pivot+1, right); merge(array,temp,left,pivot,right); &#125; &#125;&#125;class MergeSortingTest &#123; public static void main(String[] args) &#123; MergeSorting mergeSorting = new MergeSorting(); int[] array = &#123;5, 7, 4, 6, 3, 1, 2, 9, 8, 0&#125;; int[] temp = new int[array.length]; mergeSorting.mergeSort(array, temp, 0, array.length-1); System.out.println(Arrays.toString(array)); &#125;&#125; 上个代码中，使用了temp作为临时数组，最后每次归并又把temp写回了array，我们可以调整一下思路，能不能把要合并的两部分作为新数组，然后直接与array进行交换呢？ 这样似乎并不能优化什么，不过我觉得这样好理解一些。 代码实现2 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354 public void merge2(int[] array, int left, int pivot, int right) &#123; //这样就得到了pivot的左右两部分 int[] arrayLeft = Arrays.copyOfRange(array, left, pivot + 1); int[] arrayRight = Arrays.copyOfRange(array, pivot + 1, right + 1); //这两个数组的指针 int leftP = 0; int rightP = 0; //原数组的指针arrayP int arrayP = left; //当两数组有任何一个走到头时 while (leftP &lt; arrayLeft.length &amp;&amp; rightP &lt; arrayRight.length) &#123; //把两数组比较后的较小数，放入原数组，较小数的数组指针后移，原数组指针后移 if (arrayLeft[leftP] &lt;= arrayRight[rightP]) &#123; array[arrayP] = arrayLeft[leftP]; leftP++; arrayP++; &#125; else &#123; array[arrayP] = arrayRight[rightP]; rightP++; arrayP++; &#125; &#125; //如果左部分还有数据 while (leftP &lt; arrayLeft.length) &#123; array[arrayP] = arrayLeft[leftP]; leftP++; arrayP++; &#125; //如果右部分还有数据 while (rightP &lt; arrayRight.length) &#123; array[arrayP] = arrayRight[rightP]; rightP++; arrayP++; &#125; &#125; public void mergeSort2(int[] array,int left,int right)&#123; if (left&lt;right)&#123; int pivot=(left+right)/2; mergeSort2(array,left,pivot); mergeSort2(array,pivot+1,right); merge2(array,left,pivot,right); &#125; &#125;class MergeSortingTest &#123; public static void main(String[] args) &#123; MergeSorting mergeSorting = new MergeSorting(); int[] array = &#123;5, 7, 4, 6, 3, 1, 2, 9, 8&#125;; mergeSorting.mergeSort2(array, 0,array.length - 1); System.out.println(Arrays.toString(array)); &#125;&#125; 其中，合并部分还可以这样写： 12345678910111213141516171819202122232425262728293031public void merge2_1(int[] array, int left, int pivot, int right) &#123; //这样就得到了pivot的左右两部分 int[] arrayLeft = Arrays.copyOfRange(array, left, pivot + 1); int[] arrayRight = Arrays.copyOfRange(array, pivot + 1, right + 1); //这两个数组的指针 int leftP = 0; int rightP = 0; //原数组的指针arrayP int arrayP; //遍历原数组的同时 for (arrayP=left;arrayP&lt;=right;arrayP++)&#123; if (rightP==arrayRight.length)&#123; array[arrayP] = arrayLeft[leftP]; leftP++; continue; &#125; if (leftP==arrayLeft.length)&#123; array[arrayP] = arrayRight[rightP]; rightP++; continue; &#125; if (arrayLeft[leftP] &lt;= arrayRight[rightP]) &#123; array[arrayP] = arrayLeft[leftP]; leftP++; &#125; else &#123; array[arrayP] = arrayRight[rightP]; rightP++; &#125; &#125; &#125; 7. 基数排序RadixSort基数排序是分配式的，它额外使用多个数组来存放对象，当数据量较大时，就会占用较高的内存。 核心思想： 借助10个数组(也可称为桶)，分别把待排数据的个位、十位、百位….排成有序，直到最高位排完，最终便得到1个有序数组 流程： 第一轮按照对象的个位数值，分配给对应数组，比如12分配给2号数组，200分配给0号数组，分配完毕后，将数组里的数据再依次覆盖进原数组中。 第二轮和上一轮类似，这次是按照十位数值 第三轮按照百位数值 直到最高位数排完为止。 我们可以使用一个二维数组表示这10个数组，不过要知道，实际上java是没有二维数组的，java的二维数组是由一维数组组成的。设待排数组为array，使用int[10][array.length]表示10个数组（桶）那么如何知道我们需要进行多少轮呢，这与原数组的最大数的位数有关先对原数组进行一轮遍历，找到最大的数，假设是123，(123+&quot;&quot;).length这样就可以巧妙的拿到一个数字的位数当然，你也可以像我代码中那样，设一个布尔值的标识，使它在原数组的数据全被分入一个桶中时变化，从而停止循环。如何拿到当前数的当前位的值可以这样：int cur=(value / (n * 10)) % 10;从而拿到value个位十位…的值，n初始为1，每轮分配后变为原来的10倍。如何表示表示这10个数组（桶）、及其指针桶是按照数据的个位、十位、百位…的值(设为cur)来分配数据的，这正是设计10个桶的原因，所以cur对应为桶的下标我们用一个二维数组来表示这10个桶：int[][] buckets = new int[10][];使用一个一维数组表示这10个桶的指针：int[] bucketPs = {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1};，下标刚好对应这10个桶，10个指针的初始值是-1，表示桶中没有数据那么，bucketPs[cur]是第cur号桶的指针，buckets[cur][bucketPs[cur]]就能表示当前数据应该存入的桶及其指针位置✭如何保证上次排序后的结果在下轮分配排序时仍然有序？在把桶内数据写回原数组时，我们应该从头部开始，按照当时放入桶的顺序，对桶遍历，如果从尾部倒序遍历，就会逆序上次的排序结果。可以将桶的指针的值通过temp临时保存，然后让桶指针从头开始，遍历到temp，结束一轮写回后，记得把桶指针置为初始状态。也可以使用栈，利用栈把桶内数据再次逆序输出。你也可以直接做个for循环，从0遍历到桶指针。 java实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091package Sort;import java.util.Arrays;public class RadixSorting &#123; //10行数组 int[][] buckets = new int[10][]; //每个数组的指针，用一个一维数组来表示，10个指针初始均为-1，下标刚好对应桶的序号 int[] bucketPs = &#123;-1, -1, -1, -1, -1, -1, -1, -1, -1, -1&#125;; //原数组指针 int arrayP; //变量n，用于控制位数切换，通过 (对象/n*10)%10 来拿到当前位的值，初始n为1，最大为 int n; //标识是否已经排完了最高位，初始为false boolean flag; //排序方法 public void radixSort(int[] array) &#123; if (array == null) &#123; System.out.println("待排数组不能为空"); return; &#125; //初始化这10个数组 for (int i = 0; i &lt; 10; i++) &#123; buckets[i] = new int[array.length]; &#125; int n = 1; //标识是否已经排完了最高位，初始为false boolean flag = false; while (true) &#123; //n递增 n=n*10; //遍历原数组 for (int value : array) &#123; //得到当前数，当前位的值，index在我的文档里是cur int index = (value / (n * 10)) % 10; //放到值对应的数组里,第index号桶，第index号桶的指针自增 buckets[index][++bucketPs[index]] = value; //当发现把待排数全部都放入了一个桶中，也就是这个桶的指针为待排数组的长度-1时，这表示最高位的数已经被排完或者不用再排了 if (bucketPs[index]==array.length-1) flag=true; &#125; //如果发现已经排完，则退出循环 if (flag) break; //分配完成后，把桶里的数覆盖回原数组，注意要让桶指针从头部到尾的顺序输出，否则会使上一次的排序逆序 //重置原数组的指针 arrayP = 0; int tempP; //从0号桶开始，一个个遍历这10个桶,buckets.length直接写成10也没问题 for (int i = 0; i &lt; buckets.length; i++) &#123; //记录当前桶指针的位置 tempP = bucketPs[i]; //把桶指针置为头部 bucketPs[i] = 0; //开始循环 while (arrayP &lt; array.length) &#123; //当当前桶的指针小于0时，或者大于循环前的位置时，退出当前桶的循环，换到下一个桶 if (bucketPs[i] &lt; 0 || bucketPs[i] &gt; tempP) &#123; //此时当前桶的指针为-1，刚好为初始状态// bucketPs[i] = -1; break; &#125; //把当前桶的数一一拿出，赋给原数组 array[arrayP] = buckets[i][bucketPs[i]]; //把已经被取出的数据置为0方便debug buckets[i][bucketPs[i]] = 0; //桶指针后移 bucketPs[i]++; //原数组指针后移 arrayP++; &#125; &#125; //一轮分配完成，重置桶的指针 bucketPs = new int[]&#123;-1, -1, -1, -1, -1, -1, -1, -1, -1, -1&#125;; System.out.println(); &#125; &#125;&#125;//测试class RarixSortingTest &#123; public static void main(String[] args) &#123; int[] array = &#123;1, 131, 2342, 312, 4987, 525, 6453, 732, 89&#125;; RadixSorting radixSorting = new RadixSorting(); radixSorting.radixSort(array); System.out.println(Arrays.toString(array)); &#125;&#125; 输出结果 123[1, 89, 131, 312, 525, 732, 2342, 4987, 6453]Process finished with exit code 0 8.堆排序Heapsort堆排序需要堆这种数据结构， 堆的概念由于我之前的文章并没有讲到树和堆的数据结构，所以在这里说一下主要的概念： 二叉树大家应该都知道，而堆和树关系密切，堆需要满足以下两个条件： 满足完全二叉树 每个父结点都大于或都小于子结点 什么是完全二叉树看下几个图就明白了： 这个是完全二叉树： 这个也是完全二叉树： 这个不是完全二叉树： 堆的两种分类注意父结点与子结点值之间的关系： 大顶堆（大根堆） 小顶堆（小根堆） 构建堆在这之前，要说明一下堆的数组存储 堆的数组存储 堆的数组存储就是树的数组存储，从父结点的位置0开始，依次为结点编号，从左到右，从上到下，然后将树用数组的形式表示即可，每个数组元素对应该位置编号的节点，如上图所示，array[8]==45，array[0]==10。 设index为从0开始的位置编号，对应数组下标，则一个index为i的节点，它与父结点、子结点的关系，将满足以下条件： 父结点：parentNode=(i-1)/2 左子结点：childNodeLeft=2i+1 右子结点：childNodeRight=2i+2 堆化逻辑 将一个无序二叉树，转为大顶堆或小顶堆的过程叫做堆化(heapify) 依次将两个子结点和父结点进行比较，每次比较，都选出一个较大的结点，与父结点交换位置，便可以找出最大的结点作为新的父结点。对每个子树都做这种处理后，就可以形成一个大顶堆；反之选较小的节点，便会形成小顶堆 对一个节点所在的子树做heapify的时候，必须保证此节点的所有子树都已经是堆，一般从二叉树的倒数第二层开始做heapify，从最后一个非叶子节点开始，具体为： 123456//数组形式存储的树int[] treeArray=&#123;4,10,3,5,1,2...&#125;;//拿到最后一个节点的下标int lastNodeIndex = treeArray.length-1;//找到最后一个节点的父结点 从此节点开始向上堆化即可int lastParentIndex=(lastNodeIndex-1)/2; 堆化的代码实现仔细看注释 java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586package Sort;import java.util.Arrays;public class HeapSorting &#123; /** * 交换两个结点的位置 * * @param treeArray 一个数组 * @param index 数组位置1 * @param maxIndex 数组位置2 */ public void swap(int[] treeArray, int index, int maxIndex) &#123; //临时变量 int temp = treeArray[index]; treeArray[index] = treeArray[maxIndex]; treeArray[maxIndex] = temp; &#125; /** * 堆化核心方法 堆化子树 大顶堆 对一个节点做heapify的时候，必须保证它的所有子树都已经是堆。 * @param treeArray 数组形式的树 * @param index 从index号位开始堆化 */ public void heapify(int[] treeArray, int index) &#123; //递归出口 以及简单校验 if (index &lt; 0 || treeArray == null || index &gt;= treeArray.length) &#123; return; &#125; //当前节点的左子结点 int indexLeft = 2 * index + 1; //当前节点的右子节点 int indexRight = 2 * index + 2; //假设传入的当前节点（父结点）是最大的 int maxIndex = index; //两次比较都在数组不越界的情况下运行 //比较左子结点和父结点的值 if (indexLeft &lt; treeArray.length &amp;&amp; treeArray[indexLeft] &gt; treeArray[maxIndex]) &#123; //如果左子结点的值比较大，替换最大结点 maxIndex = indexLeft; &#125; //比较右子结点和父结点的值 if (indexRight &lt; treeArray.length &amp;&amp; treeArray[indexRight] &gt; treeArray[maxIndex]) &#123; //如果右子结点的值比较大，替换最大结点 maxIndex = indexRight; &#125; //经过这两次比较后，maxIndex会成为真正的最大 //交换最大的节点与父结点的位置 如果最大节点依然是初始的index 就不交换 if (maxIndex!=index)&#123; swap(treeArray, index, maxIndex); //注意这里的递归 注意这里index是maxIndex 因为交换后，maxIndex位置的子结点会发生改变 这会破坏子结点所在子树的堆特性。 heapify(treeArray, maxIndex); &#125; &#125; /** * 堆化 堆化一颗无序树 大顶堆 * @param treeArray 数组形式的树 */ public void buildHeap(int[] treeArray) &#123; //拿到最后一个节点的下标 int lastNodeIndex = treeArray.length - 1; //找到最后一个节点的父结点 从此节点开始向上堆化即可 int lastParentIndex = (lastNodeIndex - 1) / 2; //开始堆化 对每个非叶子节点所在的子树进行堆化 for (int i=lastParentIndex;i&gt;=0;i--)&#123; //调用堆化子树的方法 heapify(treeArray,i); &#125; &#125;&#125;//堆化测试class HeapSortingTest &#123; public static void main(String[] args) &#123; int[] treeArray = &#123;2, 5, 3, 1, 10, 4&#125;; HeapSorting heapSorting = new HeapSorting(); heapSorting.buildHeap(treeArray); System.out.println(Arrays.toString(treeArray)); &#125;&#125; 排序在弄明白了堆化之后，堆排序就会变得非常之简单。 堆排序的做法是： 将堆的根节点与最后一个结点交换位置，这样最后一个节点就是堆的最值，随后把最后一个结点剔除堆，然后再对被打乱的堆进行一次堆化，如此循环，依次被剔除堆的结点就会排成一个有序的队列。 如何表示结点被剔除了堆呢？我们可以每轮循环时移出堆中要被剔除的元素，但有个更好的方法：使用一个常数n表示堆中结点的总数，而n恰好决定了每轮堆化最后一个非叶子节点，我们只需要每轮让n-1，就能做出剔除最后一个节点的效果，这样做完后，不需要额外的空间，就能完成堆排序。由于第一次堆化后已经是一个堆了，所以把第一次堆化单独进行，然后循环对每轮的二叉树根结点，调用heapify方法即可，该方法会堆化传入index的结点的子树，并且递归堆化被上一次堆化影响的子树。 堆排序代码实现注意，增加了参数n来表示节点数量，变动了原来的一些堆化代码 java完整代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108package Sort;import java.util.Arrays;public class HeapSorting &#123; /** * 交换两个结点的位置 * * @param treeArray 一个数组 * @param index1 数组位置1 * @param index2 数组位置2 */ public void swap(int[] treeArray, int index1, int index2) &#123; //临时变量 int temp = treeArray[index1]; treeArray[index1] = treeArray[index2]; treeArray[index2] = temp; &#125; /** * 堆化核心方法 堆化子树 大顶堆 对一个节点做heapify的时候，必须保证它的所有子树都已经是堆。 * * @param treeArray 数组形式的树 * @param index 从index号位开始堆化 * @param n 堆中结点数 */ public void heapify(int[] treeArray, int index, int n) &#123; //递归出口 以及简单校验 if (index &lt; 0 || treeArray == null || index &gt;= n) &#123; return; &#125; //当前节点的左子结点 int indexLeft = 2 * index + 1; //当前节点的右子节点 int indexRight = 2 * index + 2; //假设传入的当前节点（父结点）是最大的 int maxIndex = index; //两次比较都在数组不越界的情况下运行 //比较左子结点和父结点的值 if (indexLeft &lt; n &amp;&amp; treeArray[indexLeft] &gt; treeArray[maxIndex]) &#123; //如果左子结点的值比较大，替换最大结点 maxIndex = indexLeft; &#125; //比较右子结点和父结点的值 if (indexRight &lt; n &amp;&amp; treeArray[indexRight] &gt; treeArray[maxIndex]) &#123; //如果右子结点的值比较大，替换最大结点 maxIndex = indexRight; &#125; //经过这两次比较后，maxIndex会成为真正的最大 //交换最大的节点与父结点的位置 如果最大节点依然是初始的index 就不交换 if (maxIndex != index) &#123; swap(treeArray, index, maxIndex); //注意这里的递归 注意这里index是maxIndex 因为交换后，maxIndex位置的子结点会发生改变 这会破坏子结点所在子树的堆特性。 heapify(treeArray, maxIndex, n); &#125; &#125; /** * 堆化 堆化一颗无序树 大顶堆 * * @param treeArray 数组形式的树 * @param n 堆中结点数 */ public void buildHeap(int[] treeArray, int n) &#123; //拿到最后一个节点的下标 int lastNodeIndex = n - 1; //找到最后一个节点的父结点 从此节点开始向上堆化即可 int lastParentIndex = (lastNodeIndex - 1) / 2; //开始堆化 对每个非叶子节点所在的子树进行堆化 for (int i = lastParentIndex; i &gt;= 0; i--) &#123; //调用堆化子树的方法 heapify(treeArray, i, n); &#125; &#125; /** * 堆排序 * * @param treeArray 数组形式的树 */ public void HeapSort(int[] treeArray) &#123; //n的初始值为堆的节点总数 int n = treeArray.length; //对无序数组堆化 buildHeap(treeArray, n); //堆排序 lastNodeIndex为最后一个节点的下标 递减 for (int lastNodeIndex = n - 1; lastNodeIndex &gt; 0; lastNodeIndex--) &#123; //交换堆中第一个结点和最后一个结点 swap(treeArray, 0, lastNodeIndex); //每轮从根节点进行子树堆化即可 此时每轮模拟的结点数 刚好等于lastNodeIndex heapify(treeArray, 0, lastNodeIndex); &#125; &#125;&#125;//堆排序测试class HeapSortingTest &#123; public static void main(String[] args) &#123; int[] treeArray = &#123;0, 7, 4, 6, 3, 1, 2, 9, 8, 5&#125;; HeapSorting heapSorting = new HeapSorting(); heapSorting.HeapSort(treeArray); System.out.println(Arrays.toString(treeArray)); &#125;&#125; 输出 1234D:\java\bin\java.exe "-javaagent:D:\idea\IntelliJ IDEA [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]Process finished with exit code 0 写在最后堆排序到此便总结完成~！ 可喜可贺，断断续续的写了很长时间。虽然现在回过头来看，当时代码写得很不成熟，不过也能看到一些进步，回顾完这些数据结构和常见算法后，便能开始leetCode无尽地域刷题之旅了。到时候也会更新leetCode的内容。 反思 正好在这时，看到一个比较引发思考的文章，这是我在学习Go语言时看到的，原文：https://www.imooc.com/article/19963 二分查找，这是一个看似简单实则很难的问题，因为需要考虑的事情很多，一段二分查找的代码大概率的就会出现层出不穷的bug： D.Knuth：Although the basic idea of binary search is comparatively straightforward, the details can be surprisingly tricky 即使二分查找的思想相对来说很直接简单，但具体实现起来有特别多的注意点。 比如，据说Java库里面的二分查找，曾经有一个埋藏了10年才被修复的bug： 当时java库二分查找的源码 123456789101112131415public static int binarySearch(int[] a, int key) &#123; int low = 0; int high = a.length - 1; while (low &lt;= high) &#123; int mid = (low + high) / 2; int midVal = a[mid]; if (midVal &lt; key) low = mid + 1; else if (midVal &gt; key) high = mid - 1; else return mid;// key found &#125; return -(low + 1);// key not found. &#125; int mid = (low + high) / 2;中，low + high 是会溢出的 修复后的写法： int mid = (low + high) &gt;&gt;&gt; 1; 三个&gt;表示无符号位移的意思。 这样或许也可行 mid = low + (high - low) / 2 写二分算法时，应该多考虑以下几点： ccmouse： 差1错误。我们的左端点应该是当前可能区间的最小范围，那么右端点是最大范围呢，还是最大范围+1呢。我们取了中间值之后，在缩小区间时，有没有保持左右端点的这个假设的一致性呢？ 死循环。我们做的是整数运算，整除2了之后，对于奇数和偶数的行为还不一样，很有可能有些情况下我们并没有减小取值范围，而形成死循环。 退出条件。到底什么时候我们才觉得我们找不到呢？ 请让自己的代码出现尽量少的bug吧]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[递归、迷宫回溯、八皇后]]></title>
    <url>%2F2019%2F09%2F18%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E9%80%92%E5%BD%92%2F</url>
    <content type="text"><![CDATA[数据结构与算法递归Recursion、迷宫回溯、八皇后问题、排列组合 对于递归大家应该都不陌生了，我们直接看递归的应用。 迷宫回溯给定一个二维数组，用1表示墙壁，0表示道路，当使用者指定入口和出口时，程序可以从入口走出迷宫。 如这个二维数组： 1234561 1 1 1 11 1 0 0 10 0 0 1 11 0 0 0 11 0 1 1 11 0 1 1 1 因为要求比较低，所以实现起来比较简单： java实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166package Recursion;import java.io.*;public class Maze &#123; //用二维数组表示迷宫地图，约定1为墙壁，0为通路，2为足迹，3为重复走过的点 int[][] mazeMap; //出口坐标 int goalI; int goalJ; //以文件方式构造地图数组,这样好设计地图 public Maze(File mapFile) throws IOException &#123; loadMapFile(mapFile); &#125; //读取地图文件中的二维数组 public void loadMapFile(File mapFile) throws IOException &#123; /* * 拿到文件中二维数组的行数列数 * */ Reader reader = new FileReader(mapFile); BufferedReader bufferedReader = new BufferedReader(reader); //查看数组行数 int rowI = 0; //数组列数 int rowJ = 0; //文件每行数据 String line; while ((line = bufferedReader.readLine()) != null) &#123; //得到数组行数 rowI++; //每行以两个空格分割 String[] splits = line.split(" &#123;2&#125;"); //得到列数 rowJ = splits.length; &#125; System.out.println("该地图的二维数组行数：" + rowI); System.out.println("该地图的二维数组列数：" + rowJ); //初始化对应行列的数组 mazeMap = new int[rowI][rowJ]; System.out.println("地图数组初始化完成"); /* * 载入文件中的数组数据 * */ //关闭流 bufferedReader.close(); //新建流 reader = new FileReader(mapFile); bufferedReader = new BufferedReader(reader); //开始读取每行数据 //数组第i行 int i = 0; while (i &lt; rowI) &#123; //读取每行数据 line = bufferedReader.readLine(); //以两个空格分割 String[] splits = line.split(" &#123;2&#125;"); //处理当前行的数据 for (int j = 0; j &lt; splits.length; j++) &#123; //[打印]每行数据，不换行 System.out.print(splits[j] + "\t"); //把当前值转为int，然后赋给二维数组 mazeMap[i][j] = Integer.parseInt(splits[j]); &#125; //行数自增 i++; //[打印]每行打印后换行 System.out.println(); &#125; System.out.println("地图数组数据载入完成！"); &#125; //读取稀疏数组文件 /* * 暂时不需要，地图文件大的话可以转成稀疏数组存放 * */ //打印数组 public void show()&#123; //打印数组 for (int[] valuex : mazeMap) &#123; for (int valuey : valuex) &#123; System.out.print(valuey + "\t"); &#125; System.out.println(); &#125; &#125; //自动寻找迷宫路线，指定一个入口的坐标(x,y)，再指定一个出口的坐标(goalI,goalJ) public void autoFind(int x, int y, int goalI, int goalJ) &#123; if (mazeMap == null) &#123; System.out.println("地图无数据，请先初始化"); &#125; else &#123; //判断输入值是否越界，是否有效 if (x &gt;= mazeMap[0].length || y &gt;= mazeMap.length || mazeMap[y][x] == 1) &#123; System.out.println("该位置不在地图内，或者该位置不能做为入口"); &#125; else &#123; //指定出口坐标 this.goalI = goalI; this.goalJ = goalJ; //开始寻路 System.out.println("开始寻路"); startFind(x, y); //打印数组 show(); &#125; &#125; &#125; //递归寻路 public boolean startFind(int x, int y) &#123; //若到达出口 if (x == goalI &amp;&amp; y == goalJ) &#123; System.out.println("找到出口"); return true; &#125; //若能走通 if (mazeMap[y][x] == 0) &#123; mazeMap[y][x] = 2; System.out.println("找到一个点"); show(); //接着向上走 if (startFind(x, y - 1)) &#123; return true; //向右走 &#125; else if (startFind(x + 1, y)) &#123; return true; //向下走 &#125; else if (startFind(x, y + 1)) &#123; return true; //向左走 &#125; else if (startFind(x - 1, y)) &#123; return true; &#125; else &#123; //都走不通 System.out.println(" "); return false; &#125; &#125;else if (mazeMap[y][x] == 2)&#123; System.out.println("回溯"); mazeMap[y][x] = 3; show(); return false; &#125;else &#123; System.out.println("碰到墙"); return false; &#125; &#125;&#125;class mapTest &#123; public static void main(String[] args) throws IOException &#123; //源文件 File mapFile = new File("D:\\aria2\\mazeMap.data"); Maze maze = new Maze(mapFile); //起始坐标(0,2)，终点坐标(1,5) maze.autoFind(0, 2, 1, 5); &#125;&#125; 输出结果 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136该地图的二维数组行数：6该地图的二维数组列数：5地图数组初始化完成1 1 1 1 1 1 1 0 0 1 0 0 0 1 1 1 0 0 0 1 1 0 1 1 1 1 0 1 1 1 地图数组数据载入完成！开始寻路找到一个点1 1 1 1 1 1 1 0 0 1 2 0 0 1 1 1 0 0 0 1 1 0 1 1 1 1 0 1 1 1 碰到墙找到一个点1 1 1 1 1 1 1 0 0 1 2 2 0 1 1 1 0 0 0 1 1 0 1 1 1 1 0 1 1 1 碰到墙找到一个点1 1 1 1 1 1 1 0 0 1 2 2 2 1 1 1 0 0 0 1 1 0 1 1 1 1 0 1 1 1 找到一个点1 1 1 1 1 1 1 2 0 1 2 2 2 1 1 1 0 0 0 1 1 0 1 1 1 1 0 1 1 1 碰到墙找到一个点1 1 1 1 1 1 1 2 2 1 2 2 2 1 1 1 0 0 0 1 1 0 1 1 1 1 0 1 1 1 碰到墙碰到墙碰到墙回溯1 1 1 1 1 1 1 3 2 1 2 2 2 1 1 1 0 0 0 1 1 0 1 1 1 1 0 1 1 1 回溯1 1 1 1 1 1 1 3 2 1 2 2 3 1 1 1 0 0 0 1 1 0 1 1 1 1 0 1 1 1 碰到墙 碰到墙找到一个点1 1 1 1 1 1 1 3 2 1 2 2 3 1 1 1 0 2 0 1 1 0 1 1 1 1 0 1 1 1 碰到墙找到一个点1 1 1 1 1 1 1 3 2 1 2 2 3 1 1 1 0 2 2 1 1 0 1 1 1 1 0 1 1 1 碰到墙碰到墙碰到墙回溯1 1 1 1 1 1 1 3 2 1 2 2 3 1 1 1 0 3 2 1 1 0 1 1 1 1 0 1 1 1 碰到墙找到一个点1 1 1 1 1 1 1 3 2 1 2 2 3 1 1 1 2 3 2 1 1 0 1 1 1 1 0 1 1 1 回溯1 1 1 1 1 1 1 3 2 1 2 3 3 1 1 1 2 3 2 1 1 0 1 1 1 1 0 1 1 1 碰到墙找到一个点1 1 1 1 1 1 1 3 2 1 2 3 3 1 1 1 2 3 2 1 1 2 1 1 1 1 0 1 1 1 回溯1 1 1 1 1 1 1 3 2 1 2 3 3 1 1 1 3 3 2 1 1 2 1 1 1 1 0 1 1 1 碰到墙找到出口1 1 1 1 1 1 1 3 2 1 2 3 3 1 1 1 3 3 2 1 1 2 1 1 1 1 0 1 1 1 Process finished with exit code 0 八皇后Eight queens百度百科： 在8×8格的国际象棋上摆放八个皇后，使其不能互相攻击，即任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法。 针对这个问题，我们可以把棋盘简化成一个普通数组， 把棋盘行数对应为数组下标即可，而不必使用二维数组来表示棋盘，如： 123array[8]=&#123;0, 6, 3, 5, 7, 1, 4, 2&#125;//分别对应棋子从第1行到第8行的位置//每行的值在0~7之间 判断是否在同一列 只需判断与之前已有的值是否相同，设当前行号为n，之前行号为pastN，若在同一列，则有： 1array[n] == array[pastN] 判断是否在同一斜线 只需判断行号之间的差值，与对应行棋子所在位置的差值，是否相同，需要用绝对值来判断： 12//Math.abs(a)返回a的绝对值Math.abs( array[n] - array[pastN] )==Math.abs( n - pastN) 判断是否在同一行 显然一维数组不可能有同一行，所以无需判断 java实现先看一个比较简单的java实现，以后我们再对它进行优化： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394package Recursion;import java.util.Arrays;public class EightQueens &#123; //初始化一个数组 private int[] array = new int[8]; //对有效结果进行计数 private int count = 0; //使用n表示棋盘的第n+1行，初始为0，表示棋盘第1行，即array[n] /** * 往棋盘中放入皇后（给数组赋值） * @param n 表示当前行号，范围从0到7 */ public void addQueen(int n) &#123; //当n==8时，说明一个8*8的棋盘每行都放了，此时是要放第9个了 if (n == 8) &#123; count++; System.out.println("第" + count + "次的棋子已经放完："+showArrayString()); return; &#125; //在当前行放棋子，从0号位放到7号位 for (int i = 0; i &lt; array.length; i++) &#123; //放入棋子 array[n] = i; //每放一个，判断棋子的位置与放过的棋子是否冲突 //若不冲突 if (check(n)) &#123; //用递归，换到下一行做重复的事情 addQueen(n + 1); &#125; //没进入递归，就说明该棋子位置冲突，不用做什么，继续for循环改变棋子位置即可 &#125; &#125; //判断是否冲突的方法 public boolean check(int n) &#123; //遍历棋盘的每一行 for (int pastN = 0; pastN &lt; n; pastN++) &#123; //若与当前行的棋子在同列或同一斜线 if (isSameColumn(n, pastN) || isSameSlant(n, pastN)) &#123; return false; &#125; &#125; //循环完毕后能执行到这里，说明不与以前的棋子在同列同斜线 return true; &#125; /** * 判断是否在同一列 * * @param n 表示当前行 * @param pastN 表示n之前的任意行 */ public boolean isSameColumn(int n, int pastN) &#123; return array[n] == array[pastN]; &#125; //判断是否在同一行 /*这个无需判断，因为肯定不在同一行*/ //判断是否在同一斜线，使用绝对值 public boolean isSameSlant(int n, int pastN) &#123; return Math.abs(array[n] - array[pastN]) == Math.abs(n - pastN); &#125; //返回数组的字符串 public String showArrayString() &#123; return Arrays.toString(array); &#125; //展示数组 public void show()&#123; System.out.println(showArrayString()); &#125;&#125;class eightQueenTest &#123; public static void main(String[] args) &#123; EightQueens eightQueens = new EightQueens(); eightQueens.addQueen(0); &#125;&#125; 输出结果 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394第1次的棋子已经放完：[0, 4, 7, 5, 2, 6, 1, 3]第2次的棋子已经放完：[0, 5, 7, 2, 6, 3, 1, 4]第3次的棋子已经放完：[0, 6, 3, 5, 7, 1, 4, 2]第4次的棋子已经放完：[0, 6, 4, 7, 1, 3, 5, 2]第5次的棋子已经放完：[1, 3, 5, 7, 2, 0, 6, 4]第6次的棋子已经放完：[1, 4, 6, 0, 2, 7, 5, 3]第7次的棋子已经放完：[1, 4, 6, 3, 0, 7, 5, 2]第8次的棋子已经放完：[1, 5, 0, 6, 3, 7, 2, 4]第9次的棋子已经放完：[1, 5, 7, 2, 0, 3, 6, 4]第10次的棋子已经放完：[1, 6, 2, 5, 7, 4, 0, 3]第11次的棋子已经放完：[1, 6, 4, 7, 0, 3, 5, 2]第12次的棋子已经放完：[1, 7, 5, 0, 2, 4, 6, 3]第13次的棋子已经放完：[2, 0, 6, 4, 7, 1, 3, 5]第14次的棋子已经放完：[2, 4, 1, 7, 0, 6, 3, 5]第15次的棋子已经放完：[2, 4, 1, 7, 5, 3, 6, 0]第16次的棋子已经放完：[2, 4, 6, 0, 3, 1, 7, 5]第17次的棋子已经放完：[2, 4, 7, 3, 0, 6, 1, 5]第18次的棋子已经放完：[2, 5, 1, 4, 7, 0, 6, 3]第19次的棋子已经放完：[2, 5, 1, 6, 0, 3, 7, 4]第20次的棋子已经放完：[2, 5, 1, 6, 4, 0, 7, 3]第21次的棋子已经放完：[2, 5, 3, 0, 7, 4, 6, 1]第22次的棋子已经放完：[2, 5, 3, 1, 7, 4, 6, 0]第23次的棋子已经放完：[2, 5, 7, 0, 3, 6, 4, 1]第24次的棋子已经放完：[2, 5, 7, 0, 4, 6, 1, 3]第25次的棋子已经放完：[2, 5, 7, 1, 3, 0, 6, 4]第26次的棋子已经放完：[2, 6, 1, 7, 4, 0, 3, 5]第27次的棋子已经放完：[2, 6, 1, 7, 5, 3, 0, 4]第28次的棋子已经放完：[2, 7, 3, 6, 0, 5, 1, 4]第29次的棋子已经放完：[3, 0, 4, 7, 1, 6, 2, 5]第30次的棋子已经放完：[3, 0, 4, 7, 5, 2, 6, 1]第31次的棋子已经放完：[3, 1, 4, 7, 5, 0, 2, 6]第32次的棋子已经放完：[3, 1, 6, 2, 5, 7, 0, 4]第33次的棋子已经放完：[3, 1, 6, 2, 5, 7, 4, 0]第34次的棋子已经放完：[3, 1, 6, 4, 0, 7, 5, 2]第35次的棋子已经放完：[3, 1, 7, 4, 6, 0, 2, 5]第36次的棋子已经放完：[3, 1, 7, 5, 0, 2, 4, 6]第37次的棋子已经放完：[3, 5, 0, 4, 1, 7, 2, 6]第38次的棋子已经放完：[3, 5, 7, 1, 6, 0, 2, 4]第39次的棋子已经放完：[3, 5, 7, 2, 0, 6, 4, 1]第40次的棋子已经放完：[3, 6, 0, 7, 4, 1, 5, 2]第41次的棋子已经放完：[3, 6, 2, 7, 1, 4, 0, 5]第42次的棋子已经放完：[3, 6, 4, 1, 5, 0, 2, 7]第43次的棋子已经放完：[3, 6, 4, 2, 0, 5, 7, 1]第44次的棋子已经放完：[3, 7, 0, 2, 5, 1, 6, 4]第45次的棋子已经放完：[3, 7, 0, 4, 6, 1, 5, 2]第46次的棋子已经放完：[3, 7, 4, 2, 0, 6, 1, 5]第47次的棋子已经放完：[4, 0, 3, 5, 7, 1, 6, 2]第48次的棋子已经放完：[4, 0, 7, 3, 1, 6, 2, 5]第49次的棋子已经放完：[4, 0, 7, 5, 2, 6, 1, 3]第50次的棋子已经放完：[4, 1, 3, 5, 7, 2, 0, 6]第51次的棋子已经放完：[4, 1, 3, 6, 2, 7, 5, 0]第52次的棋子已经放完：[4, 1, 5, 0, 6, 3, 7, 2]第53次的棋子已经放完：[4, 1, 7, 0, 3, 6, 2, 5]第54次的棋子已经放完：[4, 2, 0, 5, 7, 1, 3, 6]第55次的棋子已经放完：[4, 2, 0, 6, 1, 7, 5, 3]第56次的棋子已经放完：[4, 2, 7, 3, 6, 0, 5, 1]第57次的棋子已经放完：[4, 6, 0, 2, 7, 5, 3, 1]第58次的棋子已经放完：[4, 6, 0, 3, 1, 7, 5, 2]第59次的棋子已经放完：[4, 6, 1, 3, 7, 0, 2, 5]第60次的棋子已经放完：[4, 6, 1, 5, 2, 0, 3, 7]第61次的棋子已经放完：[4, 6, 1, 5, 2, 0, 7, 3]第62次的棋子已经放完：[4, 6, 3, 0, 2, 7, 5, 1]第63次的棋子已经放完：[4, 7, 3, 0, 2, 5, 1, 6]第64次的棋子已经放完：[4, 7, 3, 0, 6, 1, 5, 2]第65次的棋子已经放完：[5, 0, 4, 1, 7, 2, 6, 3]第66次的棋子已经放完：[5, 1, 6, 0, 2, 4, 7, 3]第67次的棋子已经放完：[5, 1, 6, 0, 3, 7, 4, 2]第68次的棋子已经放完：[5, 2, 0, 6, 4, 7, 1, 3]第69次的棋子已经放完：[5, 2, 0, 7, 3, 1, 6, 4]第70次的棋子已经放完：[5, 2, 0, 7, 4, 1, 3, 6]第71次的棋子已经放完：[5, 2, 4, 6, 0, 3, 1, 7]第72次的棋子已经放完：[5, 2, 4, 7, 0, 3, 1, 6]第73次的棋子已经放完：[5, 2, 6, 1, 3, 7, 0, 4]第74次的棋子已经放完：[5, 2, 6, 1, 7, 4, 0, 3]第75次的棋子已经放完：[5, 2, 6, 3, 0, 7, 1, 4]第76次的棋子已经放完：[5, 3, 0, 4, 7, 1, 6, 2]第77次的棋子已经放完：[5, 3, 1, 7, 4, 6, 0, 2]第78次的棋子已经放完：[5, 3, 6, 0, 2, 4, 1, 7]第79次的棋子已经放完：[5, 3, 6, 0, 7, 1, 4, 2]第80次的棋子已经放完：[5, 7, 1, 3, 0, 6, 4, 2]第81次的棋子已经放完：[6, 0, 2, 7, 5, 3, 1, 4]第82次的棋子已经放完：[6, 1, 3, 0, 7, 4, 2, 5]第83次的棋子已经放完：[6, 1, 5, 2, 0, 3, 7, 4]第84次的棋子已经放完：[6, 2, 0, 5, 7, 4, 1, 3]第85次的棋子已经放完：[6, 2, 7, 1, 4, 0, 5, 3]第86次的棋子已经放完：[6, 3, 1, 4, 7, 0, 2, 5]第87次的棋子已经放完：[6, 3, 1, 7, 5, 0, 2, 4]第88次的棋子已经放完：[6, 4, 2, 0, 5, 7, 1, 3]第89次的棋子已经放完：[7, 1, 3, 0, 6, 4, 2, 5]第90次的棋子已经放完：[7, 1, 4, 2, 0, 6, 3, 5]第91次的棋子已经放完：[7, 2, 0, 5, 1, 4, 6, 3]第92次的棋子已经放完：[7, 3, 0, 2, 5, 1, 6, 4]Process finished with exit code 0 所以我们可以看到，共有92种放法。 排列组合不多说，如 1234567891011121314151617181920212223242526272829package Recursion;//排列组合public class SortTest &#123; public static void main(String[] args) &#123; char[] array = &#123;'A', 'B', 'C'&#125;; arrange(array, 0, array.length); &#125; public static void arrange(char[] array, int start, int len) &#123; if (start == len - 1) &#123; for (int i = 0; i &lt; array.length; i++) System.out.print(array[i]); System.out.println(); return; &#125; for (int i = start; i &lt; len; i++) &#123; char temp = array[start]; array[start] = array[i]; array[i] = temp; arrange(array, start + 1, len); temp = array[start]; array[start] = array[i]; array[i] = temp; &#125; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mybatis-plus]]></title>
    <url>%2F2019%2F09%2F16%2Fmybatis-plus%E5%88%86%E9%A1%B5%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[MyBatis-Plus快速上手MyBatis-Plus是针对MyBatis的增强方案，别人造好的车轮，我们甚至SQL语句都不用写了，分页也是自动完成的。 官宣图： 话说这些技术有各种动物，还挺有趣的。 相关依赖123456789101112131415161718192021222324252627282930313233&lt;!--数据源 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--mysql连接驱动 --&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;&lt;!--可选--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--mybatis-plus(springBoot)--&gt;&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.2.0&lt;/version&gt;&lt;/dependency&gt;&lt;!--lombok--&gt;&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.10&lt;/version&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; 基础配置 数据库基础 12345#数据库基础配置spring.datasource.url=jdbc:h2:~/H2databasespring.datasource.username=***spring.datasource.password=***spring.datasource.driver-class-name=org.h2.Driver 使用连接池时 123456789# DataSource Configspring: datasource: driver-class-name: org.h2.Driver schema: classpath:db/schema-h2.sql data: classpath:db/data-h2.sql url: jdbc:h2:~/H2database username: *** password: *** mybatis-plus的配置 MapperXml，如果需要的话 1mybatis-plus.mapper-locations=classpath:/mapper/*Mapper.xml 配置类 1234@Configuration@MapperScan("cn.shirtiny.community.SHcommunity.Mapper")public class MybatisPlusConfig &#123;&#125; 如果没有什么配置需要的话，直接在启动类加个@MapperScan注解就行了： 123456789101112package cn.shirtiny.community.SHcommunity;import ...@SpringBootApplication@MapperScan("cn.shirtiny.community.SHcommunity.Mapper")public class CommunityApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(CommunityApplication.class, args); &#125;&#125; Mapper接口 甚至什么都不用写 123456package cn.shirtiny.community.SHcommunity.Mapper;import ...public interface InvitationMapper extends BaseMapper&lt;Invitation&gt; &#123;&#125; ok，没错，能用了，直接调用mapper接口的方法就能操作数据库了。 Mybatis-Plus的CRUD接口 如何分页因为之前常用的是PageHelper，翻了翻Mybatis-Plus的文档，试了下，发现比PageHelper更方便，当然，因人而异。 MP分页插件 Mybatis-Plus内置分页插件的使用方式： 首先在刚刚Mybatis-Plus的配置类里添加： 1234@Beanpublic PaginationInterceptor paginationInterceptor() &#123; return new PaginationInterceptor();&#125; 我的配置类 1234567891011121314151617181920212223242526package cn.shirtiny.community.SHcommunity.Config;import ...@EnableTransactionManagement@Configuration@MapperScan("cn.shirtiny.community.SHcommunity.Mapper")public class MybatisPlusConfig &#123; @Value("$&#123;myPageSize&#125;") private long limit; /** * 分页插件 */ @Bean public PaginationInterceptor paginationInterceptor() &#123; PaginationInterceptor paginationInterceptor = new PaginationInterceptor(); // paginationInterceptor.setLimit(你的最大单页限制数量，默认 500 条，小于 0 如 -1 不受限制); paginationInterceptor.setLimit(limit); return paginationInterceptor; &#125; //...其他配置&#125; 然后就可以用了 直接调用mapper接口的selectPage()方法即可，如： 123//null是查询条件为空，page是mybatis-plus提供的Page类invitationMapper.selectPage(page,null);//该方法，返回一个Ipage对象 实际使用： 12345678910111213141516171819202122232425262728293031//分页展示首页的帖子 @GetMapping("/") public String toIndexByPage(@RequestParam(value = "curPage",defaultValue = "1") long curPage ,Model model)&#123;//前往首页并分页 Page&lt;Invitation&gt; page=new Page&lt;&gt;(); page.setCurrent(curPage); IPage&lt;Invitation&gt; pageInfo = invitationService.selectBypage(page); model.addAttribute("pageInfo",pageInfo); //总页数 long pages = pageInfo.getPages(); //若当前页大于总页数 if (curPage&gt;pages)&#123; return "redirect:/?curPage="+pages; &#125; //若已到最后一页 if (curPage==pages)&#123; model.addAttribute("pageError","已经到最后一页喽~，后面的页数是装饰品O(∩_∩)O"); &#125; //控制的打印前端标签 long[] pageNumArray=new long[7]; long pageNum=curPage-3; for (int i=0;i&lt;curPage+4;i++)&#123; if (i&gt;=pageNumArray.length)&#123; break; &#125; pageNumArray[i]=pageNum; pageNum++; &#125; model.addAttribute("pageNumArray",pageNumArray); return "index"; &#125; 自定义分页有时候我们需要自定sql语句，还想要分页，这方面的需求也是常有的。 其实很简单，你只需要在方法形参传入Page，返回Ipage即可，mybatis-plus自动帮你分页，比如： 12345678910package cn.shirtiny.community.SHcommunity.Mapper;import ...public interface InvitationMapper extends BaseMapper&lt;Invitation&gt; &#123; //自定义的分页方法 @Select("select * from USER u join INVITATION i on u.ID=i.AUTHOR_ID") IPage&lt;InvitationDTO&gt; selectDtoByPage(Page&lt;InvitationDTO&gt; page);&#125; 官方的描述： 注解说一下基本使用，详细请查阅官方文档 @TableName 类对应的表名，如： 1@TableName("comment") @TableId 标识域为数据库表主键id，可设置id类型（数据库自增或无状态等），如： 1@TableId(value = "comment_id",type = IdType.AUTO) @TableField 非主键字段，可以指定字段名、是否为数据库表字段，插入时是否允许为空等，如： 1@TableField(value = "reviewer_id",insertStrategy = FieldStrategy.NOT_NULL) 基本的模型如： 123456789101112131415161718192021222324package cn.shirtiny.community.SHcommunity.Model;import com.baomidou.mybatisplus.annotation.*;import lombok.Data;@TableName("comment")@Datapublic class Comment &#123; //评论的主键id @TableId(value = "comment_id",type = IdType.AUTO) long commentId; //评论者id @TableField(value = "reviewer_id",insertStrategy = FieldStrategy.NOT_NULL) long reviewerId; //被评论的对象id @TableField(value = "target_id",insertStrategy = FieldStrategy.NOT_NULL) long targetId; //评论内容 @TableField(value = "comment_content",insertStrategy = FieldStrategy.NOT_NULL) String commentContent; //创建时间 @TableField(value = "created_time",insertStrategy = FieldStrategy.NOT_NULL) long createdTime;&#125;]]></content>
      <categories>
        <category>学习经验</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构_栈]]></title>
    <url>%2F2019%2F09%2F14%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E6%A0%88%2F</url>
    <content type="text"><![CDATA[数据结构与算法栈Stack、逆波兰表达式Reverse Polish Notation 1. 栈栈的示意图： 只操作栈顶元素，栈底不变每次元素进栈，top上移；元素出栈，top下移所以晚进栈的元素，会先出栈栈滿的条件top==Maxsize-1（Maxsize是初始化数组的值）栈空的条件top==-1（即初始状态）tips：我们已经分析过了队列，与队列进行比较。 Java实现 可以用数组实现，也可以用链表，类比队列的实现，较为简单。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125package Stack;import java.util.Scanner;/** * 栈的数组方式实现 */public class ArrayStack &#123; int MaxSize = 0;//最大容量 int top = -1;//栈顶指针 int base = -1;//栈底 int[] array;//数组 public ArrayStack(int maxSize) &#123;//初始化栈 MaxSize = maxSize; array = new int[MaxSize]; &#125; //判断栈滿 public boolean isFull() &#123; return top == MaxSize - 1; &#125; //判断栈空 public boolean isEmpty() &#123; return top == base; &#125; //元素入栈 public void push(int node) &#123; if (isFull()) &#123; System.out.println("栈滿"); &#125; else &#123; top++;//top上移 array[top] = node; &#125; &#125; //元素出栈 public int pop() &#123; if (isEmpty()) &#123; throw new RuntimeException("栈为空"); &#125; else &#123; int value = array[top]; top--; return value; &#125; &#125; //显示当前的栈顶元素 public int showTop() &#123; if (isEmpty()) &#123; throw new RuntimeException("为空"); &#125; else &#123; return array[top]; &#125; &#125; //打印栈 public void show() &#123; if (isEmpty()) &#123; System.out.println("为空"); &#125; else &#123; for (int i = 0; i &lt;= top; i++) &#123;//从0遍历到top即可 System.out.println(array[i]); &#125; &#125; &#125;&#125;class ArrayStackDemo &#123; public static void main(String[] args) &#123; ArrayStack stack = new ArrayStack(5); boolean loop = true; String key = ""; Scanner scanner = new Scanner(System.in); while (loop) &#123; System.out.println("show: 表示显示栈"); System.out.println("exit: 退出程序"); System.out.println("push: 表示添加数据到栈(入栈)"); System.out.println("pop: 表示从栈取出数据(出栈)"); System.out.println("showTop: 表示显示当前栈顶的数据"); System.out.println("请输入你的选择"); key = scanner.next(); switch (key) &#123; case "show": stack.show(); break; case "push": System.out.println("请输入一个数"); int value = scanner.nextInt(); stack.push(value); break; case "pop": try &#123; int res = stack.pop(); System.out.printf("出栈的数据是 %d\n", res); &#125; catch (Exception e) &#123; // TODO: handle exception System.out.println(e.getMessage()); &#125; break; case "showTop": try &#123; int res = stack.showTop(); System.out.printf("出栈的数据是 %d\n", res); &#125; catch (Exception e) &#123; // TODO: handle exception System.out.println(e.getMessage()); &#125; break; case "exit": scanner.close(); loop = false; break; default: break; &#125; &#125; System.out.println("程序退出~~~"); &#125;&#125; 2. 逆波兰表达式前缀表达式 前缀表达式是一种没有括号的算术表达式，与中缀表达式不同的是，其将运算符写在前面，操作数写在后面，又称波兰表达式，如： 1- + 1 * + 2 3 4 5 中缀表达式 中缀表达式是我们生活中常见的表达式，如： 11+((2+3)*4)-5 后缀表达式 与前缀表达式相反，把运算符写在后面，操作数写在前面，又称逆波兰表达式，后缀表达式更加利于计算机的执行，所以常常把中缀表达式转成后缀表达式来执行。后缀表达式的例子，如： 11 2 3+4*+5- 中缀表达式–&gt;后缀表达式的转换假如给定中缀表达式： 11+((2+3)*4)-5 中缀表达式转成后缀表达的算法： 初始化两个栈：运算符栈s1和储存中间结果的栈s2； 从左至右扫描中缀表达式； 遇到操作数时，将其压s2； 遇到运算符时，比较其与s1栈顶运算符的优先级： 如果s1为空，或栈顶运算符为左括号“(”，则直接将此运算符入栈； 否则，若优先级比栈顶运算符的高，也将运算符压入s1； 否则，将s1栈顶的运算符弹出并压入到s2中，再次转到(4-1)与s1中新的栈顶运算符相比较； 遇到括号时： 如果是左括号“(”，则直接压入s1 如果是右括号“)”，则依次弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，此时将这一对括号丢弃 重复步骤2至5，直到表达式的最右边 将s1中剩余的运算符依次弹出并压入s2 依次弹出s2中的元素并输出，结果的逆序即为中缀表达式对应的后缀表达式 当然，最后也可以不动s1，把s2中的元素压入s1，然后输出s1即可。 上面是引用的资料，说了这么多，总结就这几句话：在运算符只有+ - * /时（其他情况暂不考虑）不是运算符也不是括号，那就是字母或数字，直接扔到集合里（栈或队列也行）扫描到左括号(，直接入符号栈扫描到右括号)，不让它push入栈，把符号栈里的元素pop弹出并加入集合，直到pop出一个左括号(为止。注意，左括号(不加入集合扫描到运算符：与栈顶top的运算符比较优先级，如果top的优先级比较高，弹出top并加入集合，继续看下一个top，如此循环，当top的元素优先级低时，就入栈。栈为空时，当然是直接入栈；top是左括号(时，无视它，也直接入栈。 java实现将以下字符串转换成逆波兰表达式： 1+((2+3)*4)-5 22*(94+6/31-513)+44 aa*(s+ad+c)-d 3A*(2b+5a+abc)-3abcd 转换支持字母和数字的组合，运算符只考虑+-*/，数字暂时只考虑正整数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223package Stack;import com.sun.org.apache.xpath.internal.operations.Operation;import java.util.*;public class ReversePolishNotationCalculator &#123;//关于逆波兰表达式的计算器 //运算符栈 Stack stack = new Stack(); //输出集合 List&lt;String&gt; list = new ArrayList&lt;&gt;(); //自定义运算符优先级 HashMap&lt;String, Integer&gt; hashMap = new HashMap&lt;String, Integer&gt;() &#123; &#123; //用map把运算符对应一个int值，模拟优先级 put("+", 0); put("-", 0); put("*", 1); put("/", 1); //战术性把左括号当成优先级最低的运算符 put("(", -1); &#125; &#125;; //获取运算符优先级，（自定义的） public int getOperatorPrecedence(String operator) &#123; return hashMap.get(operator); &#125; //匹配字母,判断是否是字母的方法,这样可以转换a*(b+c)-d这样的表达式 public boolean isABC(String value) &#123; return value.matches("[a-zA-Z]+"); &#125; //匹配字母，比较ascii码的方式 public boolean isABC(int value) &#123; return 97 &lt;= value &amp;&amp; value &lt;= 122 || 65 &lt;= value &amp;&amp; value &lt;= 90; &#125; //匹配数字,查看value是不是匹配数字 public boolean isNum(String value) &#123; return value.matches("\\d+"); &#125; //匹配数字，比较ascii码的方式 public boolean isNum(int value) &#123; return 48 &lt;= value &amp;&amp; value &lt;= 57; &#125; //确认是不是+-*/这4个运算符 public boolean isOperator(String value) &#123; return "+".equals(value) || "-".equals(value) || "*".equals(value) || "/".equals(value); &#125; //循环比较当前运算符与栈顶运算符的优先级 public void loopCompare(String curOper) &#123; //拿到当前运算符的优先级数 int curP = getOperatorPrecedence(curOper); int stackP; String pop; while (true) &#123; if (stack.empty()) &#123; stack.push(curOper); break; &#125; //获取栈顶元素的优先级数 stackP = getOperatorPrecedence((String) stack.peek()); //如果该运算符的优先级高，将该运算符入栈，结束循环 if (curP &gt; stackP) &#123; stack.push(curOper); break; //若该运算符优先级低 &#125; else &#123; //将栈中的一个元素pop出，然后加入集合 pop = (String) stack.pop(); list.add(pop); &#125; &#125; &#125; //将字符串每个字符间添加空格，注意有多位数 public String addBlank(String expression) &#123; //先判断字符串是否为空 if (expression == null || expression.length() == 0) &#123; return null; &#125; //把字符串转成int数组 int[] array = expression.codePoints().toArray(); //全局用的字符串构建器 StringBuilder sb = new StringBuilder(); //临时用的 StringBuilder sbNum = null; //临时字符串 String sbNumString = ""; //从int型的ASCII值转成字符型 for (int i = 0; i &lt; array.length; i++) &#123; //如果当前值是数字或字母 if (isNum(array[i]) || isABC(array[i])) &#123; //新建一个临时数字字符串构建器 sbNum = new StringBuilder(); //临时变量 int j = i; //查看下一个是不是也是数字或字母 while (true) &#123; //已经到数组最大长度时（说明一直到最后都是数字和字母），把最后一个数字\字母拼进来，让i遍历完成 if (j == array.length - 1) &#123; sbNum.append((char) array[j]); i = j + 1; break; &#125; //当前值不是数字也不是字母时，把i改为j的值，跳出循环 if (!isNum(array[j]) &amp;&amp; !isABC(array[j])) &#123; i = j - 1; break; &#125; //临时拼接 sbNum.append((char) array[j]); j++; &#125; //结束循环后，说明一个完整的数字\字母已经拼接完成 sbNumString = sbNum.toString(); //拼入全局字符串 sb.append(sbNumString + " "); &#125; else &#123; //如果不是数字或字母，直接拼接 sb.append((char) array[i] + " "); &#125; &#125; return sb.toString(); &#125; //把输入的中缀表达式字符串，转为逆波兰表达式，这是表达式中字符有空格隔开的情况 public String convertorWithBlank(String expression) &#123; //先判断字符串是否为空 if (expression == null || expression.length() == 0) &#123; return null; &#125; //去除字符串头尾的空格 String expressionTrim = expression.trim(); //按空格拆分出一个字符串数组 String[] strings = expressionTrim.split(" "); //不进行运算，不用转int for (String value : strings) &#123; if (isOperator(value)) &#123; //是运算符的话，去循环比较优先级 loopCompare(value); //如果是左括号 &#125; else if ("(".equals(value)) &#123; //压入栈 stack.push(value); //如果是右括号 &#125; else if (")".equals(value)) &#123; while (true) &#123; String pop = (String) stack.pop(); //当pop出左括号时结束循环 if ("(".equals(pop)) &#123; break; &#125; //把不是(的运算符加入集合 list.add(pop); &#125; //既不是运算符，也不是括号（设表达式中不包括大括号、中括号、以及除了+—*/以外的运算符等） &#125; else &#123; //是数字或字母或数字+字母，加入集合 list.add(value); &#125; &#125; //最后，将栈中剩余的元素加入集合 while (!stack.empty()) &#123; list.add((String) stack.pop()); &#125; //结束后，得到一个包含全部字符的list集合 //使用StringBuilder构建出字符串 StringBuilder sb = new StringBuilder(); for (String m : list) &#123; sb.append(m + " "); &#125; //返回一个和字符串构建器内容相同的字符串 return sb.toString(); &#125; //把输入的中缀表达式字符串，转为逆波兰表达式，这是不带空格的情况 public String convertor(String expression) &#123; //转成有空格的字符串 String expressionWithBlank = addBlank(expression); //转成后缀表达式（逆波兰表达式） return convertorWithBlank(expressionWithBlank); &#125; //转换测试 public static void main(String[] args) &#123; ReversePolishNotationCalculator calculator = new ReversePolishNotationCalculator(); String expression1 = "1+((2+3)*4)-5"; String expression2 = "22*(94+6/31-513)+44"; String expression3 = "aa*(s+ad+c)-d"; String expression4 = "3A*(2b+5a+abc)-3abcd"; String converteds1 = calculator.convertor(expression1); String converteds2 = calculator.convertor(expression2); String converteds3 = calculator.convertor(expression3); String converteds4 = calculator.convertor(expression4); System.out.println(converteds1); System.out.println(converteds2); System.out.println(converteds3); System.out.println(converteds4); &#125;&#125; 输出结果 12341 2 3 + 4 * + 5 - 22 94 6 31 / + 513 - * 44 + aa s ad + c + * d - 3A 2b 5a + abc + * 3abcd - 计算逆波兰表达经过上面的转换，我们得到一个后缀表达式，计算机计算后缀表达式的算法如下： 从左至右扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（次顶元素 和 栈顶元素），并将结果入栈；重复上述过程直到表达式最右端，最后运算得出的值即为表达式的结果 比如，逆波兰表达式： 13 4 + 5 × 6 - 后缀表达式是没有括号的，所以对计算机来说，简单了许多，把运算符置后，方便栈运算。 直到了这个逻辑，那么代码实现就很简单了： java实现 利用中缀–&gt;后缀表达式的代码，我们直接计算中缀表达式，即(3+4)×5-6。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//计算一个中缀表达式的结果，只考虑正整数、+-*/、不包含字母，考虑到操作数长度，全程使用long类型计算 public Long caculate(String expression) &#123; //先判断字符串是否为空 if (expression == null || expression.length() == 0) &#123; return null; &#125; //把输入的中缀表达式转为逆波兰表达式 String RPNexpression = convertor(expression); //计算逆波兰表达式，注意，转换来的表达式是有空格隔开的 String[] splits = RPNexpression.split(" "); //把栈和集合初始化 stack = new Stack(); list = new ArrayList&lt;&gt;(); //两个参与运算的临时变量 long numTop; long numNext; //存储value的long值 long valueLong; //遍历数组 for (String value : splits) &#123; //如果是数字 if (isNum(value)) &#123; //转成long类型后直接入栈 valueLong = Long.parseLong(value); stack.push(valueLong); //如果是运算符 &#125; else if (isOperator(value)) &#123; numTop = (long) stack.pop(); numNext = (long) stack.pop(); //进行运算,然后把运算后的结果入栈 stack.push(caculateTopAndNext(numTop, numNext, value)); &#125; else &#123; System.out.println("表达式不合法，并且不能包含字母、小数、负数、以及+-*/以外的其他运算符"); return null; &#125; &#125; //根据栈内是否为空，空的话返回null，不为空返回栈内元素 return stack.empty() ? null : (long) stack.pop(); &#125; //测试 public static void main(String[] args) &#123; ReversePolishNotationCalculator calculator = new ReversePolishNotationCalculator(); Long rs = calculator.caculate("(3+4)*5-6"); System.out.println(rs); &#125; 输出结果 129 ☘(๑•̀ㅂ•́)و✧预告： Shirtiny：下篇文章是关于递归的，正在写]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flyway数据库迁移、版本控制]]></title>
    <url>%2F2019%2F09%2F12%2FFlyway%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%81%E7%A7%BB%E3%80%81%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%2F</url>
    <content type="text"><![CDATA[使用Flyway进行数据库迁移、版本控制flyway官网 快速上手很简单，flyway配置极少，以约定为主。 简单的使用介绍，更多详细信息会持续更新。 项目中flyway集成h2数据库Maven插件 123456789101112131415161718&lt;!-- flyway--&gt;&lt;plugin&gt; &lt;groupId&gt;org.flywaydb&lt;/groupId&gt; &lt;artifactId&gt;flyway-maven-plugin&lt;/artifactId&gt; &lt;version&gt;6.0.2&lt;/version&gt; &lt;configuration&gt; &lt;url&gt;jdbc:h2:~/H2database&lt;/url&gt; &lt;user&gt;root&lt;/user&gt; &lt;password&gt;123456&lt;/password&gt; &lt;/configuration&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.h2database&lt;/groupId&gt; &lt;artifactId&gt;h2&lt;/artifactId&gt; &lt;version&gt;1.4.197&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/plugin&gt; Gradle插件 1234567891011121314buildscript &#123; dependencies &#123; classpath 'com.h2database:h2:1.4.197' &#125;&#125;plugins &#123; id "org.flywaydb.flyway" version "6.0.2"&#125;flyway &#123; url = 'jdbc:h2:file:./target/foobar' user = 'sa'&#125; ### 快速使用 以Maven项目为例： resources目录下建立db/migration文件夹，然后在里面放入固定前缀的sql文件即可，V1__表示版本1： 文件内容： 1234567891011121314151617181920212223242526create table USER( ID BIGINT auto_increment, NICKNAME VARCHAR(100) not null, PASSWORD VARCHAR(100), EMAIL VARCHAR(200) not null constraint USER_EMAIL_UINDEX unique, AVATARIMAGE VARCHAR(500), GITHUB_ID VARCHAR(500) constraint USER_GITHUB_ID_UINDEX unique, GMT_CREATE BIGINT not null, GMT_MODIFIED BIGINT not null, constraint USER_PK primary key (ID));comment on table USER is '论坛的用户表';comment on column USER.GMT_CREATE is '创建时间戳';comment on column USER.GMT_MODIFIED is '变更时间戳';create unique index USER_ID_UINDEX on USER (ID); 创建了一个User表 然后在命令行运行： 1mvn flyway:migrate 会自动运行刚刚目录下的sql： 然后观察数据库，会发现数据库多了一张表： 这个表里是已执行sql的历史记录，对应版本。 tips： 已执行的sql下次运行将不会再被执行 如果原sql被改变，会在运行时报错停止，保护数据库原先版本 当改动了原sql或有其他异常时，可尝试以下命令： 1mvn flyway:repair 删除失败的迁移项，并且重新对齐迁移校验，修复SCHEMA_VERSION V1__两个下划线，这个前缀代表版本1，后面的名字是自定义描述，比如： 如文件名：V1__Create_User_Table.sql，Create_User_Table是描述信息，V是Version，数字是版本号。 撤销 1mvn flyway:undo 社区版是不支持的这个功能的，大概是要付费了]]></content>
      <categories>
        <category>学习经验</category>
      </categories>
      <tags>
        <tag>Flyway</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[H2数据库]]></title>
    <url>%2F2019%2F09%2F11%2FH2%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[H2数据库、SpringBoot配置、IDEA 数据库管理H2数据库体积小，轻便，可以嵌入到应用中的数据库。 简要提一下。 官网的QuickStart Maven依赖 1234567&lt;!-- h2数据库--&gt; &lt;dependency&gt; &lt;groupId&gt;com.h2database&lt;/groupId&gt; &lt;artifactId&gt;h2&lt;/artifactId&gt; &lt;version&gt;1.4.199&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; SpringBoot配置 application.properties 12345#h2数据库配置spring.datasource.url=jdbc:h2:~/H2databasespring.datasource.username=***spring.datasource.password=***spring.datasource.driver-class-name=org.h2.Driver application.yml 123456789# h2 DataSource Configspring: datasource: driver-class-name: org.h2.Driver schema: classpath:db/schema-h2.sql data: classpath:db/data-h2.sql url: jdbc:h2:~/H2database username: *** password: *** 需要引入spring-jdbc，自动配置嵌入式的数据库 spring-jdbc 12345&lt;!-- spring-jdbc 自动配置嵌入式数据库 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;&lt;/dependency&gt; IDEA连接H2数据库 这里提一下，应该都知道的，idea自带有数据库管理的。 这样填，选Embedded（嵌入），用户密码可以不设，path是路径，~是当前用户的文件夹，H2database是数据库名 比如图中的h2数据库实际位于(~/H2database)： 测试用的数据表 1234567891011121314151617181920212223242526create table USER( ID BIGINT auto_increment, NICKNAME VARCHAR(100) not null, PASSWORD VARCHAR(100), EMAIL VARCHAR(200) not null constraint USER_EMAIL_UINDEX unique, AVATARIMAGE VARCHAR(500), GITHUB_ID VARCHAR(500) constraint USER_GITHUB_ID_UINDEX unique, GMT_CREATE BIGINT not null, GMT_MODIFIED BIGINT not null, constraint USER_PK primary key (ID));comment on table USER is '论坛的用户表';comment on column USER.GMT_CREATE is '创建时间戳';comment on column USER.GMT_MODIFIED is '变更时间戳';create unique index USER_ID_UINDEX on USER (ID); 其他数据库，像MySQL也是类似配置，顺便附Mybatis的Spring Boot配置： Maven依赖 123456&lt;!-- mybatis --&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.0&lt;/version&gt;&lt;/dependency&gt; Gradle的依赖 Gradle和Maven作用类似，还是很好用的，只是网好像有点慢，可能是我网络的问题。 123dependencies &#123; compile("org.mybatis.spring.boot:mybatis-spring-boot-starter:2.1.0")&#125; mybatis下划线转驼峰 如：user_id -&gt; userId 实际上就是把数据库表中的字段下划线去除，然后再设置大小写不敏感。这是springboot里的配置方式: application.properties 1mybatis.configuration.map-underscore-to-camel-case=true 顺便回顾下SSM的： mybatis的配置文件，在&lt;configuration标签配置： 123&lt;settings&gt; &lt;setting name="mapUnderscoreToCamelCase" value="true"/&gt;&lt;/settings&gt; 最后，推荐MyBatis-Plus，很好用。 然后是springboot的文档]]></content>
      <categories>
        <category>学习经验</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>IDEA</tag>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Github授权登录]]></title>
    <url>%2F2019%2F09%2F08%2Fgithub%E6%8E%88%E6%9D%83%E7%99%BB%E5%BD%95%2F</url>
    <content type="text"><![CDATA[Github第三方授权登录创建一个OAuth App 登录Github，在用户头像的位置，依次进入： -&gt; Settings/ Developer settings /OAuth Apps 点击New OAuth App 新建OAuth App Application name，自定义的名字 Homepage URL，随便写个 Application description，描述，自定义写 Authorization callback URL，请求github后回调的url，认真写个，不过以后能改 编辑OAuth App信息 这是你的客户端id和密钥 这是头像和信息，我这里回调地址写的本地地址，项目上线后再改成公网地址 我的回调地址：http://localhost:8888/github/codeCallback 授权流程流程图： 实现 ①调用github授权的api，传递自己的id、scope（是需要的信息，比如user），用controller跳转或直接写在页面的a标签里。 GET方式，api： https://github.com/login/oauth/authorize必带参数：client_id：客户端idscope：需要请求的信息，user repo返回值：code：用于下一步请求access_tokenstate：这一步请求时的可选参数，是自己定义的一串字符串返回值实例：http://localhost:8888/github/codeCallback?code=d367eeabc1e0614c3a58&amp;state=shirtiny2011054984anro更多参数详情，参照官方文档。 Controller（或直接写在页面里） 123456789@Value("$&#123;Github_Oauth_Authorize_FullUrl&#125;")private String Authorize_URL;//请求Github登录授权 @GetMapping(value = "/github/loginWithGithub") public String loginWithGithub() throws IOException &#123; //发送请求 return "redirect:"+Authorize_URL; &#125; ②处理github响应的code、state，传给github的access_token api，拿到响应后的令牌 POST方式，api：https://github.com/login/oauth/access_token必带参数：client_id：客户端idclient_secret：客户端密钥code：上一步github返回的codestate：上一步github返回的state，如果有的话返回值：access_token：用于下一步请求用户信息token_type：令牌类型返回值实例：access_token=e72e16c7e42f292c6912e7710c838347ae178b4a&amp;token_type=bearer 服务 12345678910111213141516171819202122 @Override public String getAccessToken(String code, String state) throws IOException &#123; OkHttpClient httpClient = new OkHttpClient(); //json MediaType final MediaType MediaType_JSON= MediaType.get("application/json; charset=utf-8"); //需要实体类对象 然后转成json字符串 githubOauth.setCode(code); githubOauth.setState(state);// githubOauth.setRedirect_uri("http://localhost:8888/github/codeCallback"); String json = JSON.toJSONString(githubOauth); //创建请求体 RequestBody requestBody = RequestBody.create(MediaType_JSON, json); //建立请求，post方式调用 Request request= new Request.Builder().url(url_AccessToken).post(requestBody).build(); //执行请求 Response response = httpClient.newCall(request).execute(); //拿到响应结果 String tokenAndType = response.body().string(); System.out.println("得到通关令牌和令牌类型："+tokenAndType); return tokenAndType; &#125; ③将响应的令牌传给github的user api，获取用户信息 GET方式，api：https://api.github.com/user必带参数：access_token：上一步github返回的access_token返回值：用户信息，一个json格式的字符串，建议建一个实体类，方便存储这些信息。 服务 1234567891011@Override public String getUserInfoJson(String access_token) throws IOException &#123; //根据github回调code取用户信息，需要post请求 OkHttpClient httpClient = new OkHttpClient(); Request request = new Request.Builder().url(url_User+"?access_token="+access_token).build(); Response response = httpClient.newCall(request).execute(); //得到响应的json字符串 String userInfoJson = response.body().string(); System.out.println("用令牌调用github的user_api，得到github用户信息："+userInfoJson); return userInfoJson; &#125; 完整Controller 123456789101112131415161718192021222324252627282930313233package cn.shirtiny.community.SHcommunity.Controller;import ...@Controllerpublic class LoginController &#123; @Autowired private IGithubService githubService; @Value("$&#123;Github_Oauth_Authorize_FullUrl&#125;") private String Authorize_URL; //请求Github登录授权 @GetMapping(value = "/github/loginWithGithub") public String loginWithGithub() throws IOException &#123; //发送请求 return "redirect:"+Authorize_URL; &#125; //github那边处理完登录、注册、授权，之后会回调设置的url，我设置的回调地址是：http://localhost:8888/github/codeCallback @GetMapping(value = "/github/codeCallback")//接收github返回的参数值，样例：http://callbackurl?code=...&amp;state=... public String githubCodeCallback(String code,String state , HttpServletRequest httpServletRequest) throws IOException &#123; String tokenAndType = githubService.getAccessToken(code, state);//tokenAndType样例access_token=e72e16c7e42f292c6912e7710c838347ae178b4a&amp;token_type=bearer //把tokenAndType根据&amp;号分割，取第一个，再根据=号分割，取第二个，得到token String accessToken= tokenAndType.split("&amp;")[0].split("=")[1]; String userInfoJson = githubService.getUserInfoJson(accessToken); GithubUserInfo userInfo = JSON.parseObject(userInfoJson, GithubUserInfo.class); System.out.println(userInfo); httpServletRequest.getSession().setAttribute("userinfo",userInfo); return "redirect:/index"; &#125;&#125; 属性配置文件 *为保密信息 12345678Github_Oauth_Authorize_Url=https://github.com/login/oauth/authorizeGithub_Oauth_Client_Id=***********Github_Oauth_Client_Secret=***********Github_Oauth_Scope=userGithub_Oauth_State=**********Github_Oauth_AccessToken_Url=https://github.com/login/oauth/access_tokenGithub_Oauth_Authorize_FullUrl=https://github.com/login/oauth/authorize?client_id=*********&amp;scope=user&amp;state=***********Github_Oauth_User_Url=https://api.github.com/user 首页页面 123456789101112131415&lt;!-- 右下拉框--&gt; &lt;ul class="nav navbar-nav navbar-right"&gt;&lt;!-- if判断 标签内有效--&gt; &lt;li&gt;&lt;a href="/github/loginWithGithub" th:if="$&#123;session.userinfo==null&#125;"&gt;登录&lt;/a&gt;&lt;/li&gt; &lt;li class="dropdown" th:if="$&#123;session.userinfo!=null&#125;" &gt; &lt;a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false"&gt;&lt;span th:text="$&#123;session.userinfo.getLogin()&#125;"&gt;&lt;/span&gt;个人中心 &lt;span class="caret"&gt;&lt;/span&gt;&lt;/a&gt; &lt;ul class="dropdown-menu"&gt; &lt;li&gt;&lt;a href="#"&gt;Action&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;Another action&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;Something else here&lt;/a&gt;&lt;/li&gt; &lt;li role="separator" class="divider"&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;Separated link&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; 官方文档]]></content>
      <categories>
        <category>学习经验</category>
      </categories>
      <tags>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单链表、双向链表、单向环形链表]]></title>
    <url>%2F2019%2F09%2F05%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E5%8D%95%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[数据结构与算法链表LinkedList 链表是有序列表，但其在内存中并非有序存储，如单链表： 以节点的方式，链式存储。按实际需求，也有无头节点的链表。 1. 单链表SingleLinkedList单链表逻辑结构： 每个节点都包含两个域 data域，用来存储数据对象 next域，指向下一个节点 head头节点，不存放具体数据，只表示单链表的头，不能移动 尾节点，即链表最后的一个节点，next域为null 分析 首先会创建一个头结点，data域为空，next域为空得出结论，当head头节点的next域为空时，单链表为空向链表中加入一个节点：找到尾节点使尾节点的next域指向此节点尾节点的next域始终为空所以，除了head节点以外，当节点next域为空时，此节点为尾节点 联想 考虑节点排序时，向链表加入一个节点：找到编号大于新加入节点的节点，即满足linkedNode.id&gt;newNode.id的节点执行插入，将此节点放在新节点的next域，然后把新节点放入上一节点的next域，即newNode.next=linkedNode;linkedNode.pre.next=newNode;//而实际上linkedNode.pre是不存在的，因为单链表的节点只有next域，不能用当前节点表示上一个节点//设linkedNode的上一个节点为preNode==linkedNode.pre//则可以把linkedNode表示为pretNode.next，所以上面2个语句为：newNode.next=preNode.next;preNode.next=newNode;删除一个节点找到编号等于指定编号的节点，即满足linkedNode.id==deleteId的节点执行删除，用此节点的后一节点，顶替此节点的位置，即linkedNode.pre.next=linkedNode.next;//同理，设linkedNode的上一个节点为preNode==linkedNode.pre，则有：preNode.next=preNode.next.next;//此时在链表外的linkedNode成了不被引用的对象，会被JVM垃圾回收机制自动回收修改节点信息根据id找到对应节点，修改data域信息即可。统计单链表内有效节点的个数size让temp从第一个有效节点head.next开始遍历，计数即可。查找到单链表中倒数第n个节点需要先获得链表有效节点的个数size第(size-n+1)个节点，便是倒数第n个节点反转单链表，即：假如有节点为1234的链表，将它反转为4321创建一个新的头结点newHead，用来作为新链表的头遍历原链表时，将当前链表的节点放入newHead与newHead后一个节点之间遍历原链表时，需要保存当前节点的下一个节点，以便返回到原链表最后遍历完成后，将新节点的第一个有效节点，放入原head节点的next域逆序打印单链表遍历时，把单链表中节点压入栈中，然后再从栈中取出的节点并打印即可。合并两个有序的单链表，使之仍然有序（示例中为由小到大）初始化temp1为链表1的第一个有效节点。而temp2为链表2的头结点将链表1放入链表2中，使temp2不断后移。在找到temp1的插入位置后，temp1才后移。若直到temp2后移到末尾都没有找到temp1能插入的位置，则把temp1置于temp2末尾，结束循环。取出链表中所有节点的集合遍历取出，使用List集合注意，取出时要把每个节点的next域置为空，注意临时保存断掉的链表，以及循环退出条件按顺序批量添加节点foreach遍历上面方法取出的节点集合，然后调用排序添加节点的方法即可。使一个无序链表转换为有序列表（示例中为由小到大）与上面的方法结合，就可以实现2个无序列表合并到1个有序列表 单链表java实现Node节点类 123456789101112131415161718192021222324252627282930313233package LinkedList;public class Node &#123; //data int id; String name; Node next;//next Node pre;//pre，单链表不用 //构造器 public Node() &#123; &#125; public Node(int id, String name) &#123; this.id = id; this.name = name; &#125; public Node(int id, String name, Node next) &#123; this.id = id; this.name = name; this.next = next; &#125; @Override//重写toString方法，注意，无需打印next和pre public String toString() &#123; return "Node&#123;" + "id=" + id + ", name='" + name + '\'' + '&#125;'; &#125; //setter&amp;getter，我在单向链表中直接对属性操作，在双向链表中使用set方法，目的是产生对比，让读者体会方法封装的可读性和便利性。&#125; 单链表类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296package LinkedList;public class SingleLinkedList &#123; private Node headNode=new Node();//头节点 private Node temp;//设一个过渡节点，初始为头节点 //获取头节点 public Node getHeadNode()&#123; return this.headNode; &#125; //判断链表是否为空 public boolean isNonNode()&#123; return headNode.next == null; &#125; //添加Node(不考虑排序) public void addNode(Node node)&#123; temp=headNode;//初始化temp //找到尾节点 while (true)&#123; //判断过渡节点的next域是否为空 if (temp.next==null)&#123; temp.next=node; break;//找到next域为空的节点，便退出循环 &#125;else &#123; //否则temp后移一个节点 temp=temp.next; &#125; &#125; &#125; //添加Node，考虑排序 public void addNodeByOrder(Node node)&#123; temp=headNode;//初始化temp while(true)&#123; if (temp.next==null)&#123;//此时链表为空或已到链表末尾 //直接添加节点 temp.next=node; break; &#125;else if (temp.next.id&gt;node.id)&#123;//此时temp与temp.next之间的位置，便是node应该插入的位置 node.next=temp.next;//将temp.next，变成node的后一个节点 temp.next=node;//将node，作为temp的后一个节点 break; &#125;else if (temp.next.id==node.id)&#123; System.out.println("该编号的节点已经存在"); break; &#125; temp=temp.next;//以上都不满足，后移temp &#125; //删除节点 public void deleteNode(int id)&#123; temp=headNode;//初始化temp while (true)&#123; if (temp.next==null)&#123; System.out.println("链表中没找到要删除的节点"); break; &#125;else if (temp.next.id==id)&#123; temp.next=temp.next.next;//用要删除节点的后一个节点，替换要删除的节点 //不被引用的对象，会被JVM垃圾回收机制自动回收 System.out.println("删除"+id+"号节点"); break; &#125; temp=temp.next;//此次循环未找到符合条件的节点，后移 &#125; &#125; //修改节点 public void updateNode(Node newNode)&#123; temp=headNode; while (true)&#123; if (temp.next==null)&#123; System.out.println("链表中没找到要修改的节点"); break; &#125;else if (temp.next.id==newNode.id)&#123; temp.next.name=newNode.name; break; &#125; temp=temp.next; &#125; &#125; //打印链表 public void show()&#123; //当链表为空时，直接提示链表为空 if (isNonNode())&#123; System.out.println("当前单链表为空"); &#125;else &#123; temp=headNode;//初始化temp while (true)&#123; temp=temp.next;//temp后移 if (temp==null)&#123;//到尾节点的next时结束 break; &#125; System.out.println(temp);//输出此时temp的值 &#125; &#125; &#125; //获取链表有效节点个数 public int getSize()&#123; temp=headNode.next;//初始化temp，注意，这次初始temp的值为头节点的下一个节点，即第一个有效节点 int size=0; while (true)&#123; if (temp==null)&#123; break; &#125; size++; temp=temp.next; &#125; return size; &#125; //查找到倒数第n个节点，方案① public Node getLastIndexOf(int n)&#123; int size=getSize(); if (isNonNode()||n&lt;=0||n&gt;size)&#123; System.out.println("没有找到该编号的节点"); return null; &#125; temp=headNode; int i=0; while (true)&#123; i++; temp=temp.next; if (i==(size-n+1))&#123;//第一次循环时，i与temp为0和head，第二次时i与temp为1和第一个有效节点，所以i可以作为有效节点的坐标 return temp; &#125; &#125; &#125; //或使用for循环 /* temp=headNode.next;//这里把temp设为了第一个有效节点，i= size - index时结束循环。当然，也可以同上面while一样设为head，i= size - index+1时结束循环。 for(int i =0; i&lt; size - index; i++) &#123; cur = cur.next; &#125; return cur; */ //反转单向链表 public void reverseLinkedList()&#123; if (headNode.next==null||headNode.next.next==null)&#123; System.out.println("当前链表为空，或只有一个节点，不需要反转"); return; &#125; temp=headNode.next;//初始化temp为第一个有效节点 Node nextNode;//存储当前节点的下一个节点 Node newHead =new Node();//新的头结点 while (true)&#123; if (temp==null)&#123;//循环到temp为空 break; &#125; nextNode=temp.next;//把当前节点的下一个节点存起来 temp.next=newHead.next;//把新head的后一位节点，交给当前节点的next域 newHead.next=temp;//把当前节点，交给新head的next域 temp=nextNode;//让temp回到原链表上，后移一位 &#125; headNode.next=newHead.next;//把新合成的链表的第一个有效节点，交给原来的head的next域 &#125; //逆序打印单向链表 public void reversePrintList()&#123; temp=headNode.next; if (isNonNode())&#123; System.out.println("链表为空"); &#125;else &#123; Stack&lt;Node&gt; nodeStack=new Stack&lt;&gt;();//创建栈对象 while (true)&#123; if (temp==null)&#123; break; &#125; nodeStack.push(temp);//把节点压入栈 temp=temp.next;//节点后移 &#125; while (nodeStack.size()&gt;0)&#123; System.out.println(nodeStack.pop());//从栈中取出节点并打印 &#125; &#125; &#125; //合并两个有序的单链表，使之仍然有序 public SingleLinkedList compound2LinkedList(SingleLinkedList list1,SingleLinkedList list2)&#123; Node temp1= list1.temp=list1.headNode.next;//第一个有效节点 Node temp2 =list2.temp=list2.headNode;//头结点 //把链1放入链2中 Node head2= list2.headNode;//2链的head，没用到 Node next1;//1链的临时存储节点 while (true)&#123; if (temp1==null&amp;&amp;temp2.next==null)&#123; break; &#125; if (temp1!=null)&#123; next1=temp1.next;//临时保存1链当前节点的下一个节点 if (temp2.next==null)&#123;//temp2.next走到头，也没发现大于temp1的数 System.out.println("此后的链2一直小于链1的某个数，由于是有序列表，所以此后链2一直小于链1，直接将把链1放在链2的后面即可"); temp2.next=temp1;//把当前temp1的值，挂在temp2的尾部 break; &#125; if (temp2.next.id&gt;=temp1.id)&#123; temp1.next=temp2.next; temp2.next=temp1; temp1=next1;//直到temp2符合条件，temp1才后移 &#125; &#125; temp2=temp2.next;//temp2始终后移，注意，此时的temp2这条链应该为部分list1与全部list2的混合 &#125; return list2; &#125; //取节点集合 public List&lt;Node&gt; getNodes(SingleLinkedList list)&#123; Node temp=list.temp=list.headNode.next;//初始化temp为该链表的第一个有效节点 List&lt;Node&gt; nodeList=new ArrayList&lt;&gt;();//新建一个node集合 Node next=new Node();//初始一个next对象用于存储temp.next while (true)&#123; if (next==null)&#123;//当next为空时，退出循环 break; &#125; next=temp.next;//将temp的下一个节点临时保存，即保存temp节点以后的链表 temp.next=null;//将temp的next域设为null nodeList.add(temp);//将temp加入节点集合 temp=next;//将temp重新回到链表上 &#125; return nodeList; &#125; //按顺序批量添加节点 public void addNodesByOrder(List&lt;Node&gt; nodes)&#123; temp=headNode;//初始化temp for (Node node :nodes) &#123; addNodeByOrder(node);//调用排序添加单个node的方法 &#125; &#125; //将一个无序链表转为有序链表 public SingleLinkedList formatLinkedList(SingleLinkedList list1)&#123; List&lt;Node&gt; nodes = getNodes(list1); SingleLinkedList list2=new SingleLinkedList(); list2.addNodesByOrder(nodes); return list2; &#125; //测试 public static void main(String[] args) &#123; //生成无序列表1 SingleLinkedList singleLinkedList1=new SingleLinkedList(); singleLinkedList1.addNode(new Node(1,"1号节点")); singleLinkedList1.addNode(new Node(9,"9号节点")); singleLinkedList1.addNode(new Node(2,"2号节点")); singleLinkedList1.addNode(new Node(4,"4号节点")); System.out.println("**********无序链表1"); singleLinkedList1.show(); //序列化无序链表1 SingleLinkedList linkedList1 = singleLinkedList1.formatLinkedList(singleLinkedList1); System.out.println("**********转换成有序链表1"); linkedList1.show(); //生成无序列表2 SingleLinkedList singleLinkedList2=new SingleLinkedList(); singleLinkedList2.addNode(new Node(2,"2号节点")); singleLinkedList2.addNode(new Node(9,"9号节点")); singleLinkedList2.addNode(new Node(6,"6号节点")); singleLinkedList2.addNode(new Node(1,"1号节点")); System.out.println("**********无序链表2"); singleLinkedList2.show(); //序列化无序链表2 SingleLinkedList linkedList2 = singleLinkedList2.formatLinkedList(singleLinkedList2); System.out.println("**********转换成有序链表2"); linkedList2.show(); //合并两个有序列表，用哪个对象都行 SingleLinkedList list = linkedList1.compound2LinkedList(linkedList1, linkedList2); System.out.println("**************两个有序列表合并后的链表"); list.show(); &#125;&#125; 输出结果： 12345678910111213141516171819202122232425262728293031**********无序链表1Node&#123;id=1, name='1号节点'&#125;Node&#123;id=9, name='9号节点'&#125;Node&#123;id=2, name='2号节点'&#125;Node&#123;id=4, name='4号节点'&#125;**********转换成有序链表1Node&#123;id=1, name='1号节点'&#125;Node&#123;id=2, name='2号节点'&#125;Node&#123;id=4, name='4号节点'&#125;Node&#123;id=9, name='9号节点'&#125;**********无序链表2Node&#123;id=2, name='2号节点'&#125;Node&#123;id=9, name='9号节点'&#125;Node&#123;id=6, name='6号节点'&#125;Node&#123;id=1, name='1号节点'&#125;**********转换成有序链表2Node&#123;id=1, name='1号节点'&#125;Node&#123;id=2, name='2号节点'&#125;Node&#123;id=6, name='6号节点'&#125;Node&#123;id=9, name='9号节点'&#125;**************两个有序列表合并后的链表Node&#123;id=1, name='1号节点'&#125;Node&#123;id=1, name='1号节点'&#125;Node&#123;id=2, name='2号节点'&#125;Node&#123;id=2, name='2号节点'&#125;Node&#123;id=4, name='4号节点'&#125;Node&#123;id=6, name='6号节点'&#125;Node&#123;id=9, name='9号节点'&#125;Node&#123;id=9, name='9号节点'&#125;Process finished with exit code 0 2. 双向链表DoublyLinkedList双向链表逻辑结构： 参照单向链表，双向链表在单向链表的基础上，在每个节点多了一个pre域，指向上一个节点。 双向链表中的节点可以获取父节点增删时需要把next域和pre域都修改按顺序增加时，即插入操作：修改pre和next时，注意执行顺序先让node的pre和next分别连到temp和temp.next然后将temp.next的pre连到node最后才将temp的next连到node，否则会找不到原先的temp.next由于过渡节点temp可以指向上一个节点，方便了操作，所以删除时temp可以初始为第一个有效节点：此时temp为要删除的节点，temp.pre和temp.next的中间是temp。将temp.next的pre连到temp.pre，把temp.pre的next连到temp.next。还要注意，当要删除的节点为尾节点时，temp.next.set()会造成空指针异常我们之前已经详细的分析了单向链表，其余请对照单向链表思考，修改代码。 双向链表java实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310package LinkedList;import java.util.ArrayList;import java.util.List;import java.util.Stack;public class DoublyLinkedListTest &#123;//双向链表的测试类 public static void main(String[] args) &#123; DoublyLinkedList linkedList=new DoublyLinkedList(); linkedList.addNodeByOrder(new Node(1,"1hao")); linkedList.addNodeByOrder(new Node(3,"3hao")); linkedList.addNodeByOrder(new Node(2,"2hao")); linkedList.addNodeByOrder(new Node(4,"4hao"));// linkedList.show(); List&lt;Node&gt; nodes = getNodes(linkedList); DoublyLinkedList list=new DoublyLinkedList(); list.addNodesByOrder(nodes); list.show(); &#125; //反转单向链表 public static void reverseLinkedList(DoublyLinkedList list)&#123; Node headNode = list.getHeadNode(); Node temp; if (headNode.next==null||headNode.next.next==null)&#123; System.out.println("当前链表为空，或只有一个节点，不需要反转"); return; &#125; temp=headNode.next;//初始化temp为第一个有效节点 Node nextNode;//存储当前节点的下一个节点 Node newHead =new Node();//新的头结点 while (true)&#123; if (temp==null)&#123;//循环到temp为空 break; &#125; nextNode=temp.next;//把当前节点的下一个节点存起来 temp.next=newHead.next;//把新head的后一位节点，交给当前节点的next域 newHead.next=temp;//把当前节点，交给新head的next域 temp=nextNode;//让temp回到原链表上，后移一位 &#125; headNode.next=newHead.next;//把新合成的链表的第一个有效节点，交给原来的head的next域 &#125; //逆序打印单向链表 public static void reversePrintList(DoublyLinkedList list)&#123; Node headNode = list.getHeadNode(); Node temp=headNode.next; if (list.isNonNode())&#123; System.out.println("链表为空"); &#125;else &#123; Stack&lt;Node&gt; nodeStack=new Stack&lt;&gt;();//创建栈对象 while (true)&#123; if (temp==null)&#123; break; &#125; nodeStack.push(temp);//把节点压入栈 temp=temp.next;//节点后移 &#125; while (nodeStack.size()&gt;0)&#123; System.out.println(nodeStack.pop());//从栈中取出节点并打印 &#125; &#125; &#125; //合并两个有序的单链表，使之仍然有序 public static DoublyLinkedList compound2LinkedList(DoublyLinkedList list1,DoublyLinkedList list2)&#123; Node temp1= list1.temp=list1.headNode.next;//第一个有效节点 Node temp2 =list2.temp=list2.headNode;//头结点 //把链1放入链2中 Node head2= list2.headNode;//2链的head，没用到 Node next1;//1链的临时存储节点 while (true)&#123; if (temp1==null&amp;&amp;temp2.next==null)&#123; break; &#125; if (temp1!=null)&#123; next1=temp1.next;//临时保存1链当前节点的下一个节点 if (temp2.next==null)&#123;//temp2.next走到头，也没发现大于temp1的数 System.out.println("此后的链2一直小于链1的某个数，由于是有序列表，所以此后链2一直小于链1，直接将把链1放在链2的后面即可"); temp2.next=temp1;//把当前temp1的值，挂在temp2的尾部 break; &#125; if (temp2.next.id&gt;=temp1.id)&#123; temp1.next=temp2.next; temp2.next=temp1; temp1=next1;//直到temp2符合条件，temp1才后移 &#125; &#125; temp2=temp2.next;//temp2始终后移，注意，此时的temp2这条链应该为部分list1与全部list2的混合 &#125; return list2; &#125; //取节点集合 public static List&lt;Node&gt; getNodes(DoublyLinkedList list)&#123; Node temp=list.temp=list.headNode.next;//初始化temp为该链表的第一个有效节点 List&lt;Node&gt; nodeList=new ArrayList&lt;&gt;();//新建一个node集合 Node next=new Node();//初始一个next对象用于存储temp.next while (true)&#123; if (next==null)&#123;//当next为空时，退出循环 break; &#125; next=temp.next;//将temp的下一个节点临时保存，即保存temp节点以后的链表 temp.next=null;//将temp的next域设为null temp.pre=null; nodeList.add(temp);//将temp加入节点集合 temp=next;//将temp重新回到链表上 &#125; return nodeList; &#125; //将一个无序链表转为有序链表 public static DoublyLinkedList formatLinkedList(DoublyLinkedList list1)&#123; List&lt;Node&gt; nodes = getNodes(list1); DoublyLinkedList list2=new DoublyLinkedList(); list2.addNodesByOrder(nodes); return list2; &#125;&#125;//******************************************** //双向链表类 class DoublyLinkedList &#123; Node headNode=new Node();//头节点 Node temp;//设一个过渡节点，初始为第一个有效节点 //获取头节点 public Node getHeadNode()&#123; return headNode; &#125; public boolean isNonNode()&#123; return headNode.next == null; &#125; //添加Node(不考虑排序) public void addNode(Node node)&#123; temp=headNode;//初始化temp //找到尾节点 while (true)&#123; //判断过渡节点的next域是否为空 if (temp.next==null)&#123; //将node加入链表 temp.setNext(node); node.setPre(temp); break;//找到next域为空的节点，便退出循环 &#125;else &#123; //否则temp后移一个节点 temp=temp.getNext(); &#125; &#125; &#125; //添加Node，考虑排序 public void addNodeByOrder(Node node)&#123; temp=headNode;//初始化temp while(true)&#123; if (temp.next==null)&#123;//此时链表为空或已到链表末尾 //直接添加节点 temp.setNext(node); node.setPre(temp); break; &#125;else if (temp.next.id&gt;node.id) &#123;//此时temp与temp.next之间的位置，便是node应该插入的位置 node.setPre(temp);//先让node的pre连到temp node.setNext(temp.next);//node的next连到temp.next temp.next.setPre(node);//然后先把temp.next的pre连到node temp.setNext(node);//最后把temp的next连到node break; &#125; temp=temp.next;//以上都不满足，后移temp &#125; &#125; //按顺序批量添加节点 public void addNodesByOrder(List&lt;Node&gt; nodes)&#123; temp=headNode;//初始化temp for (Node node :nodes) &#123; addNodeByOrder(node);//调用排序添加单个node的方法 &#125; &#125; //删除节点 public void deleteNode(int id)&#123; temp=headNode.getNext();//初始化temp为第一个有效节点 while (true)&#123; if (temp==null)&#123; System.out.println("链表中没找到要删除的节点"); break; &#125;else if (temp.id==id)&#123; if (temp.next==null)&#123; temp.pre.setNext(null);//如果节点在最尾部 System.out.println("删除"+temp.id+"号节点，该节点是尾节点"); break; &#125; temp.next.setPre(temp.pre);//把temp.next的pre连到temp.pre，中间是temp temp.pre.setNext(temp.next);//把temp.pre的next连到temp.next，中间是temp //此时，没有任何节点的next或pre指向temp，不被引用的对象，会被JVM垃圾回收机制自动回收 System.out.println("删除"+temp.id+"号节点"); break; &#125; temp=temp.next;//此次循环未找到符合条件的节点，后移 &#125; &#125; //修改节点 public void updateNode(Node newNode)&#123; temp=headNode; while (true)&#123; if (temp.next==null)&#123; System.out.println("链表中没找到要修改的节点"); break; &#125;else if (temp.next.id==newNode.id)&#123; temp.next.name=newNode.name; break; &#125; temp=temp.next; &#125; &#125; //打印链表 public void show()&#123; //当链表为空时，直接提示链表为空 if (isNonNode())&#123; System.out.println("当前单链表为空"); &#125;else &#123; temp=headNode;//初始化temp while (true)&#123; temp=temp.next;//temp后移 if (temp==null)&#123;//到尾节点的next时结束 break; &#125; System.out.println(temp);//输出此时temp的值 &#125; &#125; &#125; //获取链表有效节点个数 public int getSize()&#123; temp=headNode.next;//初始化temp，注意，这次初始temp的值为头节点的下一个节点，即第一个有效节点 int size=0; while (true)&#123; if (temp==null)&#123; break; &#125; size++; temp=temp.next; &#125; return size; &#125; //查找到倒数第n个节点 public Node getLastIndexOf(int n)&#123; int size=getSize(); if (isNonNode()||n&lt;=0||n&gt;size)&#123; System.out.println("没有找到该编号的节点"); return null; &#125; temp=headNode; int i=0; while (true)&#123; i++; temp=temp.next; if (i==(size-n+1))&#123;//第一次循环时，i与temp为0和head，第二次时i与temp为1和第一个有效节点，所以i可以作为有效节点的坐标 return temp; &#125; &#125; &#125; //或使用for循环 /* temp=headNode.next;//这里把temp设为了第一个有效节点，i= size - index时结束循环。当然，也可以同上面while一样设为head，i= size - index+1时结束循环。 for(int i =0; i&lt; size - index; i++) &#123; cur = cur.next; &#125; return cur; */ &#125; 3. 环形链表单向环形链表图示： 这是最简单的形式，除了没有头结点和尾节点外，也没有其他环形结构 单个节点的next指向自己，也可以成为环形 遍历方法： 设一个指针指向第一个节点，命名为first，该指针位置不变。 设一个移动的指针，初始为first，命名为temp，显然，当temp.next==first时，遍历结束，此时temp表示链表尾部（逻辑上） 遍历前，应当确保temp==first，才能从头遍历 加入新节点时，将链表遍历到尾节点，然后将尾节点的next指向新节点，再把新节点的next指向first。 java实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980package LinkedList;public class SingleCircleLinkedList &#123; private Node first=null;//指向第一个节点 private Node temp=first;//遍历用的节点，初始为第一个节点 public void addNode(Node node)&#123; temp=first; while (true)&#123; if (first==null) &#123;//第一个节点为空，说明链表中没有节点 node.setNext(node);//单节点环形 this.first = node; this.temp = first;//初始化first和temp &#125;else&#123; temp=temp.next;//temp后移 &#125; if (temp.next==first)&#123;//temp移动后，如果temp.next为first，则说明链表已经遍历到尾部 temp.setNext(node); node.setNext(first);//构造环形 break; &#125; &#125; &#125; //根据指定的id 删除该节点 public void deleteNode(int id) &#123; if (isNon()) &#123; System.out.println("链表为空"); &#125; else &#123; temp = first;//初始化 while (true) &#123; if (temp.next.id == id) &#123; if (temp.next == first) &#123;//删除的节点为第一个节点 //更新first first = temp.next.next; &#125; temp.setNext(temp.next.next); System.out.println("删除节点:" + id); break; &#125; temp = temp.next;//temp后移 if (temp == first) &#123; System.out.println("没找到要删除的节点"); break; &#125; &#125; &#125; &#125; //打印链表 public void show()&#123; if (first==null)&#123; System.out.println("链表为空"); &#125;else &#123; temp=first;//初始化temp while (true)&#123; System.out.println(temp); if (temp.next==first)&#123; break; &#125; temp=temp.next;//temp后移 &#125; &#125; &#125;&#125;//测试class SingleCircleLinkedListTest&#123; public static void main(String[] args) &#123; SingleCircleLinkedList singleCircleLinkedList=new SingleCircleLinkedList(); singleCircleLinkedList.addNode(new Node(1,"1hao")); singleCircleLinkedList.addNode(new Node(3,"3hao")); singleCircleLinkedList.addNode(new Node(4,"4hao")); singleCircleLinkedList.addNode(new Node(6,"6hao")); singleCircleLinkedList.show(); &#125;&#125; 约瑟夫置换单向链表的实际应用中，约瑟夫问题是非常经典的。下面使用单向环形链表易懂的解决约瑟夫问题，及其变体。 百度百科——约瑟夫问题 分析 这里我们依然使用Node节点类，不再新建。需要把N个节点加入链表，并且自动编号从1位置开始计数，temp每后移1次，计数变量i的值就+1删除条件：当计数变量i==m时，删除当前temp指向的节点要注意，要想删除temp，就需要找到temp.pre，但是单向链表的节点只有next在i==m-1时，temp.next就是i==m时的要删除的temp。所以只需要在i==m-1时把temp.next删除即可遍历结束条件：链表中只剩一个节点时，即temp.next==tem java实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//根据约瑟夫问题删除节点 public void deleteByJ(int m) &#123;//每次循环中，第m个节点被删除 if (isNon()) &#123; System.out.println("链表为空"); &#125; else &#123; temp = first;//初始为第一个节点 int i = 1;//计数变量 while (true) &#123; if (temp.next == temp) &#123;//链表中只有一个节点 System.out.println("最后一个节点为：" + temp); break; &#125; if (i == m - 1) &#123;//当数到m号节点的前一个时，删除m节点 System.out.println(temp.next.id + "号节点出列"); temp.setNext(temp.next.next);//删除节点 first = temp.next;//把被删除节点的后一个节点作为第一个节点 i = 1;//重置i temp = first;//重置temp为新的first &#125; else &#123; temp = temp.next;//temp后移 i++;//计数+1 &#125; &#125; &#125; &#125;//给定节点总数n，自动编号，组成一个环形 public void autoAdd(int n) &#123; N = n; //生成 for (int i = 1; i &lt;= n; i++) &#123; Node node = new Node(); node.setId(i); JosephusList.addNode(node); &#125; &#125;//约瑟夫环class Josephus &#123; private SingleCircleLinkedList JosephusList = new SingleCircleLinkedList();//初始队列 private int N;//总人数 private int M;//数到M的人出列 ... //给定数字m，从1号开始数，每次循环数到m的节点出列（删除），直到剩最后一个 public void run(int m) &#123; M = m; JosephusList.deleteByJ(m); &#125;&#125;//测试class SingleCircleLinkedListTest &#123; public static void main(String[] args) &#123; Josephus josephus = new Josephus(); josephus.autoAdd(41);//建立一个总数41的环形链表 josephus.run(3);//默认从1开始数，数到3的节点出列 &#125;&#125; 运行结果 12345673号节点出列6号节点出列9号节点出列...35号节点出列16号节点出列最后一个节点为：Node&#123;id=31, name='null'&#125; 约瑟夫问题变体约瑟夫问题变体很多，解决方式更是多种多样。都在约瑟夫问题的基础上变动，如： 设编号为1,2，··· n的n个人围坐一圈，设编号为k的人从1开始报数，数到m的那个人出列，然后从出列的下一位开始重新从1报数，如此循环，直到只有最后一个人为止，求出队的人的编号序列 相对于原生的约瑟夫问题，这里不在是从1号位置开始报数，而是改成了从k号位置报数，k成了 一个第三方指定的变量。 思路 由于与上个问题区别不大，我们这次换一种不同的思路来解决。 注意判断k是否在符合规则的范围内 报数前，将first指向k号节点，将temp指向此时first的前一个节点 报数时，将first和temp同时移动m-1次，每次移动1位。完成后，此时first就指向需要删除的节点m，temp指向first指向节点的前一个节点 把first.next设为新的first节点，然后把first指向temp.next，如此循环即可]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx反向代理、负载均衡]]></title>
    <url>%2F2019%2F09%2F04%2Fnginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E3%80%81%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%2F</url>
    <content type="text"><![CDATA[Nginx反向代理、负载均衡反向代理什么是反向代理 客户端向代理服务器发送请求，代理服务器根据这个请求去选择实际能提供相关服务的http服务器，然后把资源通过代理服务器交给客户端。此时，客户端只能知道代理服务器的地址，无法知道实际提供服务的http服务器地址。 与之对应的，是前向代理。前向代理中，客户端通过一个代理客户端来发送请求，此时服务器只知道代理客户端的地址，不知道真实客户端的地址，如VPN。 要注意的是，文中的代理服务器与代理客户端的说法是为了方便理解，实际上两者都是服务器，只是代理的对象不同，有点像学生代表、或明星的经纪人？ Nginx如何做反向代理 只需要在nginx的conf配置文件中，增加server代码块，修改对应的server_name、location、upstream。 也可以用这种方法做虚拟主机，这样可以两个域名指向同一台nginx服务器，用户访问不同的域名显示不同的网页内容，因为多个域名可以对应一个ip地址，最好是根据域名区分，ip或端口也行。 先看基于域名的虚拟主机配置 123456789101112131415161718192021#虚拟主机1server &#123; listen 80; server_name s1.shirtiny.cn; location / &#123; root html-s1; index index.html index.htm; &#125; &#125;#虚拟主机2 server &#123; listen 80; server_name s2.shirtiny.cn; location / &#123; root html-s2; index index.html index.htm; &#125; &#125; 反向代理配置 除了upstream外，还要注意location的变化，proxy_pass。 1234567891011121314151617181920212223242526272829#http服务器upstream tomcat_server1 &#123; server 192.168.101.5:8080; &#125;upstream tomcat_server2 &#123; server 192.168.101.6:8080; &#125;#配置虚拟主机1 server &#123; listen 80; server_name aaa.test.com; location / &#123; #域名aaa.test.com的请求全部转发到tomcat_server1即tomcat1服务上 proxy_pass http://tomcat_server1; #欢迎页面，按照从左到右的顺序查找页面 index index.jsp index.html index.htm; &#125; &#125;#配置虚拟主机2 server &#123; listen 80; server_name bbb.test.com; location / &#123; #域名bbb.test.com的请求全部转发到tomcat_server2即tomcat2服务上 proxy_pass http://tomcat_server2; index index.jsp index.html index.htm; &#125; &#125; 详细参考 负载均衡Load Balance，同种服务有多个http服务器时，nginx根据http服务器被分配的权重，把请求轮换分配给某个http服务器。 只需要在upstream对服务器进行权重分配，weight默认为1。 123456789101112131415161718192021222324252627282930upstream tomcat_server_pool&#123; server 192.168.101.5:8080 weight=3; server 192.168.101.6:8080 weight=1; &#125;#详细说明#定义负载均衡设备的 Ip及设备状态 upstream myServer &#123; server 127.0.0.1:9090 down; server 127.0.0.1:8080 weight=2; server 127.0.0.1:6060; server 127.0.0.1:7070 backup; &#125;#upstream 每个设备的状态:#down 表示单前的server暂时不参与负载 #weight 默认为1.weight越大，负载的权重就越大。 #max_fails ：允许请求失败的次数默认为1.当超过最大次数时，返回proxy_next_upstream 模块定义的错误 #fail_timeout:max_fails 次失败后，暂停的时间。 #backup： 其它所有的非backup机器down或者忙的时候，请求backup机器。所以这台机器压力会最轻。#在需要使用负载的Server节点下添加#proxy_pass http://myServer; server &#123; listen 80; server_name aaa.test.com; location / &#123; proxy_pass http://myServer; index index.jsp index.html index.htm; &#125; &#125; 高可用准备两台Nginx服务器，一主一备。都装keepalived做健康检查，两个keepalived会保持通讯，主服务器拿到虚拟ip（vip）运行中，当主Nginx服务器上的keepalived失去响应时，备用服务器上的keepalived会启动备用的Nginx，拿到主Nginx的虚拟ip（vip），代替主服务器工作。 keepalived的安装安装环境1234567su - rootyum -y install kernel-devel*yum -y install openssl-*yum -y install popt-develyum -y install lrzszyum -y install openssh-clientsyum -y install libnl libnl-devel popt 安装keepalived将keepalived-1.2.15.tar.gz上传到服务器/usr/local/下。 123456789cd /usr/localtar -zxvf keepalived-1.2.15.tar.gzcd keepalived-1.2.15#执行配置命令./configure --prefix=/usr/local/keepalived#编译make#安装make install 至此安装完成。 123456789101112#拷贝执行文件cp /usr/local/keepalived/sbin/keepalived /usr/sbin/#将init.d文件拷贝到etc下,加入开机启动项cp /usr/local/keepalived/etc/rc.d/init.d/keepalived /etc/init.d/keepalived#将keepalived文件拷贝到etc下，加入网卡配置cp /usr/local/keepalived/etc/sysconfig/keepalived /etc/sysconfig/ #创建keepalived文件夹mkdir -p /etc/keepalived#将keepalived配置文件拷贝到etc下cp /usr/local/keepalived/etc/keepalived/keepalived.conf /etc/keepalived/keepalived.conf#添加可执行权限chmod +x /etc/init.d/keepalived 加入开机启动12chkconfig --add keepalived #添加时必须保证/etc/init.d/keepalived存在chkconfig keepalived on 添加完可查询系统服务是否存在：chkconfig --list 启动keepalived123启动：service keepalived start停止：service keepalived stop重启：service keepalived restart 配置日志文件12345678#将keepalived日志输出到local0：vi /etc/sysconfig/keepalivedKEEPALIVED_OPTIONS="-D -d -S 0"#在/etc/rsyslog.conf里添加:local0.* /var/log/keepalived.log#重新启动keepalived和rsyslog服务：service rsyslog restart service keepalived restart 打开防火墙的通讯地址12iptables -A INPUT -d 224.0.0.18 -j ACCEPT/etc/rc.d/init.d/iptables save 主Nginx修改主nginx下/etc/keepalived/keepalived.conf文件 123456789101112131415161718192021222324252627! Configuration File for keepalived#全局配置global_defs &#123; notification_email &#123; #指定keepalived在发生切换时需要发送email到的对象，一行一个 XXX@XXX.com &#125; notification_email_from XXX@XXX.com #指定发件人 #smtp_server XXX.smtp.com #指定smtp服务器地址 #smtp_connect_timeout 30 #指定smtp连接超时时间 router_id LVS_DEVEL #运行keepalived机器的一个标识&#125;vrrp_instance VI_1 &#123; state MASTER #标示状态为MASTER 备份机为BACKUP interface eth0 #设置实例绑定的网卡 virtual_router_id 51 #同一实例下virtual_router_id必须相同 priority 100 #MASTER权重要高于BACKUP 比如BACKUP为99 advert_int 1 #MASTER与BACKUP负载均衡器之间同步检查的时间间隔，单位是秒 authentication &#123; #设置认证 auth_type PASS #主从服务器验证方式 auth_pass 8888 &#125; virtual_ipaddress &#123; #设置vip 192.168.101.100 #可以多个虚拟IP，换行即可 &#125;&#125; 备Nginx修改备nginx下/etc/keepalived/keepalived.conf文件 配置备nginx时需要注意：需要修改state为BACKUP , priority比MASTER低，virtual_router_id和master的值一致 123456789101112131415161718192021222324252627! Configuration File for keepalived#全局配置global_defs &#123; notification_email &#123; #指定keepalived在发生切换时需要发送email到的对象，一行一个 XXX@XXX.com &#125; notification_email_from XXX@XXX.com #指定发件人 #smtp_server XXX.smtp.com #指定smtp服务器地址 #smtp_connect_timeout 30 #指定smtp连接超时时间 router_id LVS_DEVEL #运行keepalived机器的一个标识&#125;vrrp_instance VI_1 &#123; state BACKUP #标示状态为MASTER 备份机为BACKUP interface eth0 #设置实例绑定的网卡 virtual_router_id 51 #同一实例下virtual_router_id必须相同 priority 99 #MASTER权重要高于BACKUP 比如BACKUP为99 advert_int 1 #MASTER与BACKUP负载均衡器之间同步检查的时间间隔，单位是秒 authentication &#123; #设置认证 auth_type PASS #主从服务器验证方式 auth_pass 8888 &#125; virtual_ipaddress &#123; #设置vip 192.168.101.100 #可以多个虚拟IP，换行即可 &#125;&#125; tips： 因为备份服务器的启动，是依据主服务器上的keepalived的响应状况判断的，所以当主服务器的keepalived意外停止，或者当nginx进程停止时，keepalived没有按计划停止，就无法启动备份服务器。 nginx进程检测脚本为了解决nginx进程和keepalived不同时存在的问题，需要在主服务器上编写Nginx进程检测脚本check_nginx.sh，判断nginx进程是否存在，如果nginx不存在就将keepalived进程杀掉。 123456#!/bin/bash# 如果进程中没有nginx则将keepalived进程kill掉A=`ps -C nginx --no-header |wc -l` ## 查看是否有 nginx进程 把值赋给变量A if [ $A -eq 0 ];then ## 如果没有进程值得为 零 service keepalived stop ## 则结束 keepalived 进程fi 脚本运行测试 将check_nginx.sh拷贝至/etc/keepalived下， 将nginx停止，将keepalived启动，执行脚本：sh /etc/keepalived/check_nginx.sh，若keepalived进程被顺利杀死，即成功。 修改主nginx的keepalived.conf，添加脚本定义检测： 1234567891011121314151617181920212223242526272829303132333435363738#全局配置global_defs &#123; notification_email &#123; #指定keepalived在发生切换时需要发送email到的对象，一行一个 XXX@XXX.com &#125; notification_email_from miaoruntu@itcast.cn #指定发件人 #smtp_server XXX.smtp.com #指定smtp服务器地址 #smtp_connect_timeout 30 #指定smtp连接超时时间 router_id LVS_DEVEL #运行keepalived机器的一个标识&#125; ##监控脚本vrrp_script check_nginx &#123; script "/etc/keepalived/check_nginx.sh" ##监控脚本 interval 2 ##时间间隔，2秒 weight 2 ##权重&#125;vrrp_instance VI_1 &#123; state MASTER #标示状态为MASTER 备份机为BACKUP interface eth0 #设置实例绑定的网卡 virtual_router_id 51 #同一实例下virtual_router_id必须相同 priority 100 #MASTER权重要高于BACKUP 比如BACKUP为99 advert_int 1 #MASTER与BACKUP负载均衡器之间同步检查的时间间隔，单位是秒 authentication &#123; #设置认证 auth_type PASS #主从服务器验证方式 auth_pass 8888 &#125; #监控脚本 track_script &#123; check_nginx #监控脚本 &#125; virtual_ipaddress &#123; #设置vip 192.168.101.100 #可以多个虚拟IP，换行即可 &#125;&#125;#修改后重启keepalived#观察keepalived日志：#tail -f /var/log/keepalived.log]]></content>
      <categories>
        <category>学习经验</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[今日硬盘阵亡]]></title>
    <url>%2F2019%2F09%2F03%2F%E7%A1%AC%E7%9B%98%E9%98%B5%E4%BA%A1%2F</url>
    <content type="text"><![CDATA[今日1T机械硬盘君阵亡察觉硬盘运行声响不正常，还好当时觉得不妙，便把博客备份传到群文件了。传完不久，机械硬盘阵亡，电脑死机，内存内的程序还在运行。下午在固态硬盘上装了个盗版win10系统，临时使用。 从零开始的环境搭建由于数据全部丢失，硬盘维修状况尚不可知，在临时系统里，准备必要的学习环境 安装必要驱动 卸除所有不需要的软件 firefox浏览器安装开发者版本，因为账号似乎与普通版区分，需要用来账号同步，账号依然是我qq邮箱同步完成后，收藏与记录的表单就有了，主题皮肤还在，只是布局要自己改谷歌以后有需要时再装 因为博客有备份，先恢复博客安装nodejs、git、hexo安装nodejs，也包括其他.msi的安装时遇到2503错误，是windows权限问题，需要使用msiexec命令管理员身份运行 cmd命令行cd 到软件所在目录msiexec /package 你的.msi软件大概是这样，记得不是很清楚，详情去百度。安装hexo时遇到问题可查看hexo迁移使用hexo命令需要把D:\hexoBlog\ShirtinyBlog\node_modules\.bin配置到path全局环境变量 安装Typora用来写md文章。 输入法依然按照我的习惯来在系统设置里，语言选项，增加英语（美国），这样将设win+空格，将纯英文环境与中英文环境分开分开中文输入法依然用手心输入法，将微软拼音从设置中删除。 QQ装上，方便在手机与电脑间传点小东西 百度云用的下载器，超级会员太坑，用speedPan或pandownload来下载百度云资源 Xshell、Xftp，在博客找。VMwear虚拟机暂不装，硬盘空间不够，只能先租服务器了。 RDM，远程管理redis数据，比较方便 解压软件，Bandizip，百度到官网下载。 视频播放器Potplayer IntelliJ IDEA 【8qhm】或寻找新的破解版，或使用教育邮箱此版本安装方式，适用于jetbrains公司的工具破解管理员身份运行idea安装包，选系统位数，然后完成安装修改host，在末尾加：0.0.0.0 account.jetbrains.com0.0.0.0 www.jetbrains.com在激活界面，选Activation code，然后复制注册码即可在其安装目录的lib文件夹下，把resources_cn.jar复制过来，可以汉化（虽然不用汉化）代码样式用 Visual Studio 2013 百度jdk1.8去Oracle下jdk，需要Oracle账号 PostMan，用来调试接口 doc文档暂用WPS 安装Go，2503错误看上面 VScode，因为要经常看乱七八糟后缀名的文件，还要作为go的ide。vsGo插件安装 为Idea安装Go的插件，go module的代理可以用阿里云的 Maven，官网下个，然后解压，环境变量是MAVEN_HOME、解压的文件夹目录，path是%MAVEN_HOME%\bin，环境变量好像都一个配法。 WebStorm，改host，然后当时用的注册码 PR，编辑媒体 OBS，直播推流、录制媒体 Docker，window家庭版要装Docker Toolbox看文档装就行了。 Clash，Github上开源的翻墙工具，windows版本的GUI挺好看的。]]></content>
      <categories>
        <category>系统维护</category>
      </categories>
      <tags>
        <tag>硬盘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Solr-Error]]></title>
    <url>%2F2019%2F09%2F03%2FSolr-Error-solrj-beans-BindingException%2F</url>
    <content type="text"><![CDATA[控制台： Exception in thread “main” org.apache.solr.client.solrj.beans.BindingException: Could not instantiate object of class com.SH.Rest.Pojo.Solr_pojo 异常产生经过： 在使用SolrJ时，调用SolrClient对象的addBean()方法以及QueryResponse对象的getBeans()方法时，抛出异常。 1234solrClient.addBean(pojo);//以及QueryResponse queryResponse = solrClient.query(query);List&lt;Solr_pojo&gt; solr_pojos = queryResponse.getBeans(Solr_pojo.class); 异常全文： Exception in thread “main” org.apache.solr.client.solrj.beans.BindingException: Could not instantiate object of class com.SH.Rest.Pojo.Solr_pojo at org.apache.solr.client.solrj.beans.DocumentObjectBinder.getBean(DocumentObjectBinder.java:71) at org.apache.solr.client.solrj.beans.DocumentObjectBinder.getBeans(DocumentObjectBinder.java:50) at org.apache.solr.client.solrj.response.QueryResponse.getBeans(QueryResponse.java:646) at com.SH.Rest.Service.serviceImpl.SearchServiceImpl.query(SearchServiceImpl.java:32) at com.SH.Rest.Service.serviceImpl.SearchServiceImpl.main(SearchServiceImpl.java:41)Caused by: java.lang.InstantiationException: com.SH.Rest.Pojo.Solr_pojo at java.lang.Class.newInstance(Class.java:427) at org.apache.solr.client.solrj.beans.DocumentObjectBinder.getBean(DocumentObjectBinder.java:65) … 4 moreCaused by: java.lang.NoSuchMethodException: com.SH.Rest.Pojo.Solr_pojo.() at java.lang.Class.getConstructor0(Class.java:3082) at java.lang.Class.newInstance(Class.java:412) … 5 moreDisconnected from the target VM, address: ‘127.0.0.1:1331’, transport: ‘socket’Process finished with exit code 1 解决方法： 无法实例化对象，可能是因为属性类型不匹配，要仔细检查对象类与solr域的类型是否对应，是否做好转换，另外还需检查有无空构造器，以及setter&amp;getter参数类型是否有误。 样例 下面给出我当时改后的pojo类与solr域的示例。 Solr_pojo类 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.SH.Rest.Pojo;import org.apache.solr.client.solrj.beans.Field;import java.util.Date;public class Solr_pojo &#123; @Field("id") private String id; @Field("solr_title") private String title; @Field("solr_sell_point") private String sellPoint; @Field("solr_price") private Long price; @Field("solr_num") private Integer num; @Field("solr_barcode") private String barcode; @Field("solr_image") private String image; @Field("solr_cid") private Long cid; @Field("solr_status") private int status; @Field("solr_created") private Date created; @Field("solr_updated") private Date updated; //... //setter&amp;getter&amp;各种构造器重载，别忘了空构造&#125; managed-schema，solr域配置 12345678910111213141516171819&lt;!-- &lt;field name="solr_id" type="plong" stored="true" required="true" indexed="false" /&gt; --&gt; &lt;field name="solr_title" type="text_ik" stored="true" indexed="true" required="true"/&gt; &lt;field name="solr_sell_point" type="text_ik" stored="true" indexed="true" required="true"/&gt; &lt;field name="solr_price" type="plong" stored="true" indexed="true" required="true"/&gt; &lt;field name="solr_num" type="pint" stored="true" indexed="true" required="true"/&gt; &lt;field name="solr_barcode" type="string" stored="true" indexed="false" required="false"/&gt; &lt;field name="solr_image" type="string" stored="true" indexed="false" required="false"/&gt; &lt;field name="solr_cid" type="plong" stored="true" indexed="false" required="true"/&gt; &lt;field name="solr_status" type="pint" stored="true" indexed="true" required="true"/&gt; &lt;field name="solr_created" type="pdate" stored="true" indexed="false" required="true"/&gt; &lt;field name="solr_updated" type="pdate" stored="true" indexed="false" required="true"/&gt; &lt;!-- 复制域只是用来搜索便利，提高搜索的性能，要有多值、分词、可被索引、但不存储、无类型 --&gt; &lt;field name="tao_keywords" type="text_ik" indexed="true" stored="false" multiValued="true" /&gt; &lt;copyField source="solr_title" dest="tao_keywords" /&gt; &lt;copyField source="solr_sell_point" dest="tao_keywords" /&gt; &lt;copyField source="solr_price" dest="tao_keywords" /&gt; &lt;copyField source="solr_num" dest="tao_keywords" /&gt; &lt;copyField source="solr_status" dest="tao_keywords" /&gt;]]></content>
      <categories>
        <category>开发问题</category>
      </categories>
      <tags>
        <tag>solrJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SolrJ]]></title>
    <url>%2F2019%2F09%2F03%2FSolrJ%2F</url>
    <content type="text"><![CDATA[SolrJSolrJ是Solr的java客户端实现，通过java代码连接solr服务器，并使用。 依赖12345&lt;dependency&gt; &lt;groupId&gt;org.apache.solr&lt;/groupId&gt; &lt;artifactId&gt;solr-solrj&lt;/artifactId&gt; &lt;version&gt;8.2.0&lt;/version&gt;&lt;/dependency&gt; 对象绑定@field注解，注解中的值为，该字段对应的solr域的名称 12345678910111213141516public class Solr_pojo &#123; @Field("id") private String id; @Field("solr_title") private String title; @Field("solr_sell_point") private String sellPoint; @Field("solr_price") private Long price; ... //setter&amp;getter 单机模式URL和HttpSolrClient注意上下两个URL的区别 1234//直接指定solr的URL和core1，只能查询或更新core1内容String URL="http://my-solr-server:8983/solr/core1";SolrClient client = new HttpSolrClient(URL);QueryResponse resp = client.query(new SolrQuery("*:*")); 1234//指定solr的URL，查询或更新时要指定coreString URL="http://my-solr-server:8983/solr";SolrClient client = new HttpSolrClient(URL);QueryResponse resp = client.query("core1", new SolrQuery("*:*")); 新增和更新方式①：add(SolrInputDocument) 123456789SolrInputDocument fields = new SolrInputDocument(); fields.addField("id","224895477"); fields.addField("solr_title","shirtiny"); ...solrClient.add(fields);solrClient.commit();solrClient.close(); 方式②：addBean 12345678910Solr_pojo pojo=new Solr_pojo();//Solr_pojo是一个自定义的，与solr索引域对应的pojo类pojo.setId("224895477");pojo.setTitle("shirtiny");//...UpdateResponse response = solrClient.addBean(pojo);//把对象传入，solr会根据id进行覆盖 solrClient.commit();solrClient.close(); 其中UpdateResponse返回的是状态码和执行耗时。 删除ById: 单个：deleteById(&quot;id&quot;); 123UpdateResponse response = solrClient.deleteById("2248954774");solrClient.commit();solrClient.close(); 批量：deleteById(List); 直接创建一个id的List集合 123456789List&lt;String&gt; ids=new ArrayList&lt;&gt;(); ids.add("224895477"); ids.add("2248954771"); ids.add("2248954772"); ids.add("2248954773");UpdateResponse response = solrClient.deleteById(ids);solrClient.commit();solrClient.close(); 或 把按照一定格式，包含多个id的字符串，用split分成数组，然后再用Arrays.asList()方法把数组转成List集合 1234567String ids="224895477,2248954771,2248954772,2248954773,4564564564";String[] idSplit = ids.split(",");List&lt;String&gt; idList = Arrays.asList(idSplit);UpdateResponse response = solrClient.deleteById(ids);solrClient.commit();solrClient.close(); ByQuery:deleteByQuery(&quot;x:x&quot;);删除所有查询到的数据。 123UpdateResponse response = solrClient.deleteByQuery("solr_title:手机");solrClient.commit();solrClient.close(); 查询基本查询1234567891011SolrQuery query=new SolrQuery("*:*");QueryResponse response = solrClient.query(query);solrClient.close();//或SolrQuery query=new SolrQuery();query.set("q","solr_title:手机 AND solr_sell_point:清仓 OR solr_title:老年人"); QueryResponse response = solrClient.query(query);//tips://df设置默认搜索域，设置默认域后q值不用加字段名query.set("df","myKeyWords");query.set("q","手机"); 结果筛选 set方式 1query.set("fq","solr_price:[* TO 9999]","solr_title:联通"); setFilterQueries方式 1query.setFilterQueries("solr_price:[* TO 9999]","solr_title:联通"); addFilterQuery方式 12query.addFilterQuery("solr_price:[* TO 9999]");query.addFilterQuery("solr_title:联通"); 结果排序 addSort，SolrQuery.ORDER.asc顺序，SolrQuery.ORDER.desc倒序 123query.addSort("solr_price", SolrQuery.ORDER.asc);//价格顺序query.addSort("solr_title", SolrQuery.ORDER.desc);//标题倒序query.addSort("score", SolrQuery.ORDER.desc);//匹配得分倒序 结果分页 setStart、setRows 1234int pageNum=5;int rows=60;query.setStart((pageNum-1)*rows);//start=（当前页数-1）*rowsquery.setRows(rows);//每页条数 结果回显 set 1query.set("fl","*,score");//*表示显示全部信息，score表示增加匹配得分的显示 setFields 1query.setFields("solr_title","score"); 关键字高亮1234567891011121314//开启高亮功能query.setHighlight(true);//添加需要高亮的字段（域）query.addHighlightField("solr_title");query.addHighlightField("solr_price");//高亮前缀query.setHighlightSimplePre("&lt;em&gt;");//高亮后缀query.setHighlightSimplePost("&lt;/em&gt;");//查询QueryResponse response = solrClient.query(query);//拿到高亮集合Map&lt;String, Map&lt;String, List&lt;String&gt;&gt;&gt; highlighting = response.getHighlighting(); 响应集合 可直接将结果转为对象集合 12QueryResponse queryResponse = solrClient.query(query);List&lt;Solr_pojo&gt; solr_pojos = queryResponse.getBeans(Solr_pojo.class); 响应头 header包括查询的值、查询的条件、耗时、状态码、响应类型等信息。 1NamedList&lt;Object&gt; header = queryResponse.getHeader(); Results结果集、结果属性 查询结果 1234567891011121314151617//获取查询的结果集SolrDocumentList results = response.getResults();//查询到的结果集 results.getNumFound();//共查询到多少条数据 results.getMaxScore();//关键字的最大匹配得分 results.getStart();//偏移量，即分页的start，正常分页的话是(当前页码-1)*rows//遍历得到单个结果对象List&lt;Solr_pojo&gt; solrPojos=new ArrayList&lt;&gt;(); for (SolrDocument result:results)&#123; String id = (String) result.getFieldValue("id"); // String title = (String) result.get("solr_title"); String title = (String)result.getFieldValue("solr_title"); System.out.println(id+"\t"+title); Solr_pojo solrPojo=new Solr_pojo(id,title); solrPojos.add(solrPojo); &#125; System.out.println(solrPojos); 高亮域替换查询结果 123456789101112131415List&lt;Solr_pojo&gt; solrPojos=new ArrayList&lt;&gt;(); //拿到高亮区域 Map&lt;String, Map&lt;String, List&lt;String&gt;&gt;&gt; highlighting = response.getHighlighting(); for (SolrDocument result:results)&#123; String id =(String) result.get("id");//从result拿到id Map&lt;String, List&lt;String&gt;&gt; listMap = highlighting.get(id);//因为高亮区域与结果中的id是相同的，所以可以通过上述id取到高亮区域的&lt;高亮域名，value数组&gt;的集合 List&lt;String&gt; solr_titles = listMap.get("solr_title");//通过高亮域名，拿到高亮值value的数组 String title = solr_titles.get(0);//list里只有1个值，index的0号位置，便是高亮的值了 System.out.println(id+"\t"+title); Solr_pojo solrPojo=new Solr_pojo(id,title); solrPojos.add(solrPojo); &#125; System.out.println(solrPojos); 集群模式使用的SolrClient，由HttpSolrClient，变为CloudSolrClient，然后要记得设置默认索引集合，其他与单机模式一样。 123CloudSolrClient client=new CloudSolrClient("192.168.249.131:2181,192.168.249.131:2182,192.168.249.131:2183");client.setDefaultCollection("collection1");]]></content>
      <categories>
        <category>学习经验</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>solr</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[solr-tomcat集成]]></title>
    <url>%2F2019%2F08%2F23%2Fsolr-tomcat%2F</url>
    <content type="text"><![CDATA[将solr从Jetty转到Tomcat、ik分词、数据库索引 复制一份tomcat，然后再solr根目录的同级目录新建一个文件夹用于存放集成后的solr，自定义名字solr_home 修改apache-tomcat-8.5.37\conf\server.xml，修改tomcat涉及的端口号，这里可以都加1 123&lt;Server port="8006" shutdown="SHUTDOWN"&gt;&lt;Connector connectionTimeout="20000" port="8081" protocol="HTTP/1.1" redirectPort="8443"/&gt; &lt;Connector port="8010" protocol="AJP/1.3" redirectPort="8443"/&gt; 若已经配置了tomcat的环境变量，需要编辑bin/startup.bat，将if not “%CATALINA_HOME%” == “” goto gotHome注释掉( 前面加rem是注释)： 1REM if not "%CATALINA_HOME%" == "" goto gotHome 参考： 默认启动其他tomcat的问题 Rem注释 在solr_home文件夹下，新建logs文件夹，然后修改Tomcat\bin下的catalina.bat，增加solr.log.dir系统变量，指定solr日志记录存放地址。 在set “JAVA_OPTS=%JAVA_OPTS% %JSSE_OPTS%”这句下，新增： 1set "JAVA_OPTS=%JAVA_OPTS% -Dsolr.log.dir=D:\SolrRepo\solr_home\logs" solr.log.dir的值为刚刚新建的logs文件夹的绝对路径。 把solr-8.0.0目录下的server/solr-webapp/webapps放置到tomcat/webapp的目录下，重命名为solr。 将solr-8.0.0\server\lib\ext下的所有jar包拷贝到tomcat里的webapps\solr\WEB-INF\lib 将solr-8.0.0\server\lib下 除jetty以外的jar拷贝到tomcat里的webapps\solr\WEB-INF\lib 将solr-8.0.0\dist下 jar包也拷贝到tomcat里的webapps\solr\WEB-INF\lib 放数据库连接驱动的jar包，如mysql-connector-java.jar到webapps\solr\WEB-INF\lib，顺便往solr-8.2.0\dist文件夹下也放一份数据库连接驱动的jar包。 在tomcat里的webapps\solr\WEB-INF下创建classes文件夹，将solr/server/resources下的配置文件拷贝到新建的classes文件夹里 把solr-8.0.0 里面的solr文件夹下全部的内容放入solr_home文件夹内（相当于复制一份solr文件夹，然后改名为solr_home ） 把solr-8.0.0下contrib和dist文件夹也拷贝至solr_home目录下 在solr_home目录下新建new_core文件夹；并拷贝solr-8.0.0\example\example-DIH\solr\db目录下所有文件至SolrHome\new_core下。 修改solr-home\new_core\conf\solrconfig.xml文件下的对应内容为：(改一下相对路径，加个mysql的连接驱动) 1234567891011121314&lt;lib dir="$&#123;solr.install.dir:../&#125;/contrib/extraction/lib" regex=".*\.jar" /&gt; &lt;lib dir="$&#123;solr.install.dir:../&#125;/dist/" regex="solr-cell-\d.*\.jar" /&gt; &lt;lib dir="$&#123;solr.install.dir:../&#125;/contrib/clustering/lib/" regex=".*\.jar" /&gt; &lt;lib dir="$&#123;solr.install.dir:../&#125;/dist/" regex="solr-clustering-\d.*\.jar" /&gt; &lt;lib dir="$&#123;solr.install.dir:../&#125;/contrib/langid/lib/" regex=".*\.jar" /&gt; &lt;lib dir="$&#123;solr.install.dir:../&#125;/dist/" regex="solr-langid-\d.*\.jar" /&gt; &lt;lib dir="$&#123;solr.install.dir:../&#125;/contrib/velocity/lib" regex=".*\.jar" /&gt; &lt;lib dir="$&#123;solr.install.dir:../&#125;/dist/" regex="solr-velocity-\d.*\.jar" /&gt; &lt;lib dir="$&#123;solr.install.dir:../&#125;/dist/" regex="ojdbc\d.*\.jar" /&gt; &lt;lib dir="$&#123;solr.install.dir:../&#125;/dist/" regex="solr-dataimporthandler\d.*\.jar" /&gt; &lt;lib dir="$&#123;solr.install.dir:../&#125;/dist/" regex="mysql-connector-java-*\.jar" /&gt; 最后solr_home的文件夹内容： 配置tomcat→webApp→solr→WEB_INF下的web.xml，添加配置（指定solr数据源的位置）： 123456&lt;env-entry&gt; &lt;env-entry-name&gt;solr/home&lt;/env-entry-name&gt; &lt;!--这里填你建的solr_home文件夹的绝对路径 --&gt; &lt;env-entry-value&gt;D:\SolrRepo\solr_home&lt;/env-entry-value&gt; &lt;env-entry-type&gt;java.lang.String&lt;/env-entry-type&gt; &lt;/env-entry&gt; 然后把 &lt;1security-constraint&gt;整个注释掉,目的是防止tomcat 403问题 1234567891011121314151617 &lt;!-- &lt;security-constraint&gt; &lt;web-resource-collection&gt; &lt;web-resource-name&gt;Disable TRACE&lt;/web-resource-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;http-method&gt;TRACE&lt;/http-method&gt; &lt;/web-resource-collection&gt; &lt;auth-constraint/&gt; &lt;/security-constraint&gt; &lt;security-constraint&gt; &lt;web-resource-collection&gt; &lt;web-resource-name&gt;Enable everything but TRACE&lt;/web-resource-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;http-method-omission&gt;TRACE&lt;/http-method-omission&gt; &lt;/web-resource-collection&gt; &lt;/security-constraint&gt;--&gt; 添加ik中文分词器ik分词器jar包 将下载好的jar包放入Tomcat 8.5/webapps/solr/WEB-INF/lib目录中 打开solr_home/new_core/conf目录中的managed-schema文件，添加如下代码： 1234567891011&lt;!-- ik分词器 --&gt; &lt;fieldType name="text_ik" class="solr.TextField"&gt; &lt;analyzer type="index"&gt; &lt;tokenizer class="org.wltea.analyzer.lucene.IKTokenizerFactory" useSmart="false" conf="ik.conf"/&gt; &lt;filter class="solr.LowerCaseFilterFactory"/&gt; &lt;/analyzer&gt; &lt;analyzer type="query"&gt; &lt;tokenizer class="org.wltea.analyzer.lucene.IKTokenizerFactory" useSmart="true" conf="ik.conf"/&gt; &lt;filter class="solr.LowerCaseFilterFactory"/&gt; &lt;/analyzer&gt; &lt;/fieldType&gt; 在界面Analysis的Analyse Fieldname / FieldType:中选text_ik即可使用。 添加数据库索引 在solr_home\你的核心\conf下的managed-schema，配置域信息，用来接收数据库数据的对应字段 123456789101112131415161718192021 &lt;!--solr需要数据有个固定的主键id，而那个id是由solr配置好的，名为id的域。所以应该把数据库表的主键id绑定到solr自带的名为id的域上，所以不需要再自定一个其他名称的id &lt;field name="solr_id" type="plong" stored="true" required="true" indexed="false" /&gt; --&gt; &lt;field name="solr_title" type="text_ik" stored="true" indexed="true" required="true"/&gt; &lt;field name="solr_sell_point" type="text_ik" stored="true" indexed="true" required="true"/&gt; &lt;field name="solr_price" type="plong" stored="true" indexed="true" required="true"/&gt; &lt;field name="solr_num" type="pint" stored="true" indexed="true" required="true"/&gt; &lt;field name="solr_barcode" type="string" stored="true" indexed="false" required="false"/&gt; &lt;field name="solr_image" type="string" stored="true" indexed="false" required="false"/&gt; &lt;field name="solr_cid" type="plong" stored="true" indexed="false" required="true"/&gt;&lt;!--注意，数据库中tinyInt的数据类型，在solr默认提供的数据类型中，是找不到对应类型的。 --&gt; &lt;field name="solr_status" type="pint" stored="true" indexed="true" required="true"/&gt; &lt;field name="solr_created" type="pdate" stored="true" indexed="false" required="true"/&gt; &lt;field name="solr_updated" type="pdate" stored="true" indexed="false" required="true"/&gt; &lt;!-- 复制域只是用来搜索便利，提高搜索的性能，要有多值、分词、可被索引、但不存储、无类型 --&gt; &lt;field name="tao_keywords" type="text_ik" indexed="true" stored="false" multiValued="true" /&gt; &lt;copyField source="solr_title" dest="tao_keywords" /&gt; &lt;copyField source="solr_sell_point" dest="tao_keywords" /&gt; &lt;copyField source="solr_price" dest="tao_keywords" /&gt; &lt;copyField source="solr_num" dest="tao_keywords" /&gt; &lt;copyField source="solr_status" dest="tao_keywords" /&gt; 在solr_home\你的核心\conf下的db-data-config.xml配置数据库数据信息，&amp;符号需要使用&amp;amp;来替换，如果数据库表中有tinyInt的数据类型，需要设置tinyInt1isBit=false或true，详情： solr中tinyInt1isBit的设置 solr中tinyInt转boolean 123456789101112131415161718192021222324&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;dataConfig&gt; &lt;dataSource type="JdbcDataSource" driver="com.mysql.jdbc.Driver" url="jdbc:mysql://localhost:3306/taotao?useUnicode=true&amp;amp;characterEncoding=UTF-8&amp;amp;useSSL=false&amp;amp;tinyInt1isBit=false" user="root" password="123456" /&gt; &lt;document&gt; &lt;!--自定义的实体名，查询语句。根据返回结果，将数据库表的字段名与solr域名绑定 --&gt; &lt;entity name="taoDB" query="SELECT * from tb_item" &gt; &lt;field column="id" name="id" /&gt; &lt;field column="title" name="solr_title" /&gt; &lt;field column="sell_point" name="solr_sell_point" /&gt; &lt;field column="price" name="solr_price" /&gt; &lt;field column="num" name="solr_num" /&gt; &lt;field column="barcode" name="solr_barcode" /&gt; &lt;field column="image" name="solr_image" /&gt; &lt;field column="cid" name="solr_cid" /&gt; &lt;field column="status" name="solr_status" /&gt; &lt;field column="created" name="solr_created" /&gt; &lt;field column="updated" name="solr_updated" /&gt; &lt;/entity&gt; &lt;/document&gt;&lt;/dataConfig&gt; tips： 在xml的sql语句中，不能直接用大于号、小于号要用转义字符 解决方式： 转义字符： &amp;lt;是&lt;，小于号 &amp;gt;是&gt;，大于号 &amp;amp;是&amp;，和 &amp;apos;是’，单引号 &amp;quot;是”，双引号 或 使用&lt;![CDATA[]]&gt;标记： &lt;![CDATA[ state &lt;= 3 ]]&gt; 不过要注意，&lt;![CDATA[ ]]&gt;标记的sql语句中的&lt;where&gt; &lt;if&gt;等标签不会被解析 参考文章： https://blog.csdn.net/weixin_42613538/article/details/89516198 https://blog.csdn.net/ailian_f/article/details/89407754 https://blog.csdn.net/l1336037686/article/details/80723636]]></content>
      <categories>
        <category>学习经验</category>
      </categories>
      <tags>
        <tag>solr</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[千 与 千寻的神隐]]></title>
    <url>%2F2019%2F08%2F22%2F%E5%8D%83%E4%B8%8E%E5%8D%83%E5%AF%BB%E7%9A%84%E7%A5%9E%E9%9A%90%2F</url>
    <content type="text"><![CDATA[千 と 千尋の神隠し搬运： Bilibili@风格里哦 在B站浏览该页：传送门 var ap = new APlayer({ element: document.getElementById("aplayer-VQnQsrVj"), narrow: false, autoplay: true, showlrc: false, music: { title: "One Summer's Day", author: "久石譲", url: "http://server.shirtiny.cn/music/One Summer's Day.mp3", pic: "https://file.moetu.org/images/2019/08/20/78da987214933136431ddaca0eba896b0cccbc458f84e1ec.th.png", lrc: "" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); > 直接搬原网页[#狡猾.jpg]]]></content>
      <categories>
        <category>闲谈</category>
      </categories>
      <tags>
        <tag>千与千寻</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[队列、环形队列]]></title>
    <url>%2F2019%2F08%2F19%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E9%98%9F%E5%88%97%E3%80%81%E7%8E%AF%E5%BD%A2%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[数据结构与算法单队列ArrayQueue、环形队列CircleArrayQueue 1. 单队列 队列是一个有序列表，可以使用数组或链表来实现。 先入先出，先存入队列的数据先取出，如排队。 单队列的3个属性： MaxSize表示队列最大容量 rear表示尾指针，指向队列末尾，记录该数据的下标，随着数据输入而改变。 而front表示头指针，一般让它指向队列头的前一个位置，记录队列头的前一个下标，先自增后取值。 单队列生命周期 开始时，rear与front均指向-1，这是初始状态。 每把一个数据放入队列，尾指针rear就会+1。当rear=MaxSize-1时，队列满。 每把一个数据从队列中取出，头指针front+1。当front==rear时，即头指针与尾指针指向同一处，此时队列为空。无法再取，所以，front&lt;=rear。 单队列使用完一次后，便不能再次使用。 单队列数组实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154package Queue;import java.util.Scanner;public class ArrayQueue &#123; private int MaxSize; private int front; private int rear; private int[] array; //初始化数组 ArrayQueue(int MaxSize)&#123; this.MaxSize=MaxSize; array=new int[MaxSize]; front=-1; rear=-1; &#125; //判断队列是否满 boolean isFull()&#123; return rear==MaxSize-1; &#125; //判断队列是否为空 boolean isEmpty()&#123; return rear==front; &#125; //向队列增加数据 void add(int data)&#123; if (isFull())&#123;//判断队列是否已满 System.out.println("队列已满，无法存"); &#125;else &#123; rear++;//尾指针后移 array[rear]=data;//赋值 System.out.println("尾指针+1："+rear); &#125; &#125; //从队列取数据 int get()&#123; if (isEmpty())&#123;//判断队列是否为空 throw new RuntimeException("队列为空，无法取"); &#125;else &#123; front++; System.out.println("头指针+1："+front); return array[front];//取值 &#125; &#125; //显示整个队列 void show()&#123; if (isEmpty())&#123;//判断队列是否为空 throw new RuntimeException("队列空，无数据"); &#125;else &#123; for (int data:array)&#123;//打印数组 System.out.print(data+"\t"); &#125; System.out.println(); &#125; &#125; //展示队列头数据 int showFront()&#123; if (isEmpty())&#123;//判断队列是否为空 throw new RuntimeException("队列空，无数据"); &#125;else &#123; return array[front+1];//返回头数据，指针不变 &#125; &#125; //展示队列尾数据 int showRear()&#123; if (isEmpty())&#123;//判断队列是否为空 throw new RuntimeException("队列空，无数据"); &#125;else &#123; return array[rear];//返回尾数据，指针不变 &#125; &#125; //测试队列 public static void main(String[] args) &#123; //创建一个队列对象，容量为3 ArrayQueue queue = new ArrayQueue(3); char key;//接收用户输入 Scanner scanner = new Scanner(System.in);// boolean loop = true; //输出一个菜单 while(loop) &#123; System.out.println("s(show): 显示队列"); System.out.println("e(exit): 退出程序"); System.out.println("a(add): 添加数据到队列"); System.out.println("g(get): 从队列取出数据"); System.out.println("h(head): 查看队列头的数据"); System.out.println("r(rear): 查看队列尾的数据"); key = scanner.next().charAt(0);//接收一个字符 switch (key) &#123; case 's': queue.show(); break; case 'a': System.out.println("输入一个数"); int value = scanner.nextInt(); queue.add(value); break; case 'g': //取出数据 try &#123; int res = queue.get(); System.out.printf("取出的数据是%d\n", res); &#125; catch (Exception e) &#123; // TODO: handle exception System.out.println(e.getMessage()); &#125; break; case 'h': //查看队列头的数据 try &#123; int res = queue.showFront(); System.out.printf("队列头的数据是%d\n", res); &#125; catch (Exception e) &#123; // TODO: handle exception System.out.println(e.getMessage()); &#125; break; case 'r': //查看队列头的数据 try &#123; int rear = queue.showRear(); System.out.printf("队列尾的数据是%d\n", rear); &#125; catch (Exception e) &#123; // TODO: handle exception System.out.println(e.getMessage()); &#125; break; case 'e': //退出 scanner.close(); loop = false; break; default: break; &#125; &#125; System.out.println("程序退出~~"); &#125;&#125; 2. 环形队列相比单队列，环形队列属性设定有所变动： 属性的设定 初始时front = rear = 0，而不是-1 rear指向队列尾数据的下一个空间，在尾数据后预留一个空间，即rear指向的位置不放值。（预留空间是为了区分队列空和队列满，空元素作为队尾的标志） front直接指向头数据 容量为MaxSize-1 环形队列生命周期 开始时，rear与front均指向0，这是初始状态。 每把一个数据放入队列，尾指针rear就会+1。当（rear+1)%MaxSize=front 时，队列满。因为rear指向尾数据的下一个空间，队列满时rear+1自然等于front。之所以%MaxSize取模是因为：环形队列指针的值会一直增加，%Maxsize会得到周期性的值，就像角度会加到362度、750度一样。温馨提示：%运算符：比如2%3就是，2除以3等于0余2，所以2%3就是2，而3%2=1。 每把一个数据从队列中取出，头指针front+1。当front==rear时，即头指针与尾指针指向同一处，此时队列为空。重点这里不再像单队列，在循环中，front与rear的大小关系是不定的，有时rear&gt;front，有时front&gt;rear。为什么会出现这种情形呢，rear&gt;front的情形好理解，尾与头嘛。至于front&gt;rear的情形，我们类比一下角度，假如rear在361度的位置，front在365度的位置，别忘了是环形。由此可以得出，环形队列中的元素总数为：(rear-front+MaxSize)%MaxSize，始终用尾减去头，又因为rear-front的值正负不定，所以要加上MaxSize再%MaxSize。 环形队列可循环使用。遍历时，从front开始，一直到front+size结束，size是当前元素个数，因为元素个数size会随着出队进队变化，变化量与front的移动量是一致的 环形队列数组实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172package Queue;import java.util.Scanner;public class CircleQueue &#123; private int MaxSize; private int front; private int rear; private int[] array; //初始化数组 CircleQueue(int MaxSize)&#123; this.MaxSize=MaxSize; array=new int[MaxSize]; front=0; rear=0; &#125; //判断队列是否满 boolean isFull()&#123; return (rear+1)%MaxSize==front; &#125; //判断队列是否为空 boolean isEmpty()&#123; return rear==front; &#125; //向队列增加数据 void add(int data)&#123; if (isFull())&#123;//判断队列是否已满 System.out.println("队列已满，无法存"); &#125;else &#123; array[rear%MaxSize]=data;//赋值 rear++;//尾指针后移 System.out.println("尾指针+1："+rear%MaxSize); &#125; &#125; //从队列取数据 int get()&#123; if (isEmpty())&#123;//判断队列是否为空 throw new RuntimeException("队列为空，无法取"); &#125;else &#123; int data=array[front%MaxSize]; front++; System.out.println("头指针+1："+front%MaxSize); return data;//取值 &#125; &#125; //队列中的有效元素总数 int getSize()&#123; return (rear-front+MaxSize)%MaxSize; &#125; //显示整个队列 void show()&#123; if (isEmpty())&#123;//判断队列是否为空 System.out.println("队列为空"); &#125;else &#123; for (int i=front%MaxSize;i&lt;front%MaxSize+getSize();i++)&#123;//打印数组 System.out.println(array[i]+"\t"); &#125; System.out.println(); &#125; &#125; //展示队列头数据 int showFront()&#123; if (isEmpty())&#123;//判断队列是否为空 throw new RuntimeException("队列空，无数据"); &#125;else &#123; return array[front%MaxSize];//返回头数据，指针不变 &#125; &#125; //展示队列尾数据 int showRear()&#123; if (isEmpty())&#123;//判断队列是否为空 throw new RuntimeException("队列空，无数据"); &#125;else &#123; return array[(rear-1)%MaxSize];//返回尾数据，指针不变 &#125; &#125; //测试队列 public static void main(String[] args) &#123; //创建一个队列对象，容量为5 CircleQueue queue = new CircleQueue(5); char key;//接收用户输入 Scanner scanner = new Scanner(System.in);// boolean loop = true; //输出一个菜单 while(loop) &#123; System.out.println("s(show): 显示队列"); System.out.println("e(exit): 退出程序"); System.out.println("a(add): 添加数据到队列"); System.out.println("g(get): 从队列取出数据"); System.out.println("z(getSize): 查看有效元素个数"); System.out.println("h(head): 查看队列头的数据"); System.out.println("r(rear): 查看队列尾的数据"); key = scanner.next().charAt(0);//接收一个字符 switch (key) &#123; case 's': queue.show(); break; case 'a': System.out.println("输入一个数"); int value = scanner.nextInt(); queue.add(value); break; case 'g': //取出数据 try &#123; int res = queue.get(); System.out.printf("取出的数据是%d\n", res); &#125; catch (Exception e) &#123; // TODO: handle exception System.out.println(e.getMessage()); &#125; break; case 'h': //查看队列头的数据 try &#123; int res = queue.showFront(); System.out.printf("队列头的数据是%d\n", res); &#125; catch (Exception e) &#123; // TODO: handle exception System.out.println(e.getMessage()); &#125; break; case 'r': //查看队列头的数据 try &#123; int rear = queue.showRear(); System.out.printf("队列尾的数据是%d\n", rear); &#125; catch (Exception e) &#123; // TODO: handle exception System.out.println(e.getMessage()); &#125; break; case 'z': //查看队列头的数据 try &#123; int size = queue.getSize(); System.out.printf("元素个数是%d\n", size); &#125; catch (Exception e) &#123; // TODO: handle exception System.out.println(e.getMessage()); &#125; break; case 'e': //退出 scanner.close(); loop = false; break; default: break; &#125; &#125; System.out.println("程序退出~~"); &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue基础]]></title>
    <url>%2F2019%2F08%2F19%2FVue2%2F</url>
    <content type="text"><![CDATA[Vue基础知识Vue生命周期&amp;Hook回调函数 beforeCreate、Created等是钩子回调的函数，通过这些函数，我们可以指定在Vue生命周期的某一阶段做一些事情。 回调函数示例 1234567891011121314const app =new Vue(&#123; el:'#id', data:obj, methods:&#123;...&#125;, //回调函数 beforeCreate:function()&#123;...&#125;, mounted:function()&#123;...&#125; ...&#125;) //其中，data的obj对象为。data可以是对象。 const obj=&#123; count:0, i:'haha' &#125; 指令 v-once：执行一次后，内容不再随数据的变化再改变。 v-html：对内容进行html解析渲染 v-pre：不对内容进行任何解析 v-cloak：斗篷，vuejs生效前保留v-cloak，vuejs生效后删除所有v-cloak属性，可以用css控制v-cloak来达成我们的目的，比如当vuejs延迟加载的时候，不让用户看到未被vuejs渲染的源码内容。 v-text：如v-text=”message”，把message数据作为字符串显示，会覆盖掉原本的内容 v-one:如v-on:click=”message”，监听某个事件 V-bind动态的绑定特殊意义的属性，如a标签的href，img标签的src，还有class等，动态绑定数据。 简写为：:，是语法糖。 静态实例1234567891011121314151617181920212223&lt;div id="app"&gt; &lt;h1&gt;v-bind指令&lt;/h1&gt; &lt;a v-bind:href="aURL"&gt;blog&lt;/a&gt; &lt;img v-bind:src="imgURL"&gt;&lt;br&gt; v-bind简写:&lt;img :src="imgURL"&gt;&lt;/div&gt; &lt;script&gt; //url对象 const url=&#123; aURL:"http://shirtiny.cn",imgURL:"https://file.moetu.org/images/2019/08/20/b46b2347f21fd46f60baf163a57da47c2b17554146847392.png" &#125;; const app=new Vue(&#123; el:'#app',//挂载 data:url//数据对象 &#125;) &lt;/script&gt; 如绑定class、style的实例对象： 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;style&gt; .red&#123; color: red; &#125; .line&#123; text-decoration: underline; &#125;&lt;/style&gt;&lt;div id="app"&gt; &lt;!--&lt;h1 class="class" v-bind:class="&#123;key1:value,key2:value&#125;"&gt;v-bind指令&lt;/h1&gt;--&gt; &lt;p class="class" v-bind:class="&#123;red:isRed,line:isLine&#125;"&gt;v-bind指令&lt;/p&gt;&lt;br&gt; &lt;!-- 原class与v-bind:class可以共存，它们会在被渲染时合并（2+1=3）不会覆盖 --&gt; &lt;button v-on:click="changeRed"&gt;切换颜色&lt;/button&gt; &lt;button v-on:click="changeLine"&gt;下划线&lt;/button&gt; &lt;!--或者 --&gt; &lt;p v-bind:class="getClass()"&gt;v-bind指令&lt;/p&gt;&lt;br&gt; &lt;!-- style也一样的--&gt; &lt;p :style="&#123;color:'red',fontSize:'50px'&#125;"&gt;v-bind指令&lt;/p&gt;&lt;br&gt; &lt;/div&gt; &lt;script&gt; const app=new Vue(&#123; el:'#app',//挂载 data:&#123;//class状态 isRed:true, isLine:false &#125;, methods:&#123; changeRed:function () &#123; this.isRed=!this.isRed//在true和false之间切换 &#125;, changeLine:function () &#123; this.isLine=!this.isLine &#125;, getClass:function () &#123; return &#123;red: this.isRed,line: this.isLine&#125;; &#125; &#125; &#125;) &lt;/script&gt; 对象用｛｝括起来，是key：value的形式，{key1:value,key2:value} 原class与v-bind:class可以共存，它们会在被渲染时合并（2+1=3）不会覆盖 数组： 12345678910111213141516171819202122232425&lt;div id="app"&gt; &lt;p v-bind:class="[isRed,isLine]"&gt;v-bind指令&lt;/p&gt;&lt;br&gt; &lt;!--或--&gt; &lt;p v-bind:class="getClass()"&gt;v-bind指令&lt;/p&gt;&lt;br&gt; &lt;!-- style也一样，数组里放对象，或放键值对都行--&gt; &lt;p :style="[hahaColor,hahaLine]"&gt;v-bind指令&lt;/p&gt;&lt;br&gt;&lt;/div&gt; &lt;script&gt; const app=new Vue(&#123; el:'#app',//挂载 data:&#123;//class状态 isRed:"red", isLine:"line", hahaColor:&#123;color:'red',fontSize:'50px'&#125;,//对象 hahaLine:&#123;'text-decoration':'underline'&#125;//对象 &#125;, methods:&#123; getClass:function () &#123; return [this.isRed,this.isLine]; &#125; &#125; &#125;) &lt;/script&gt; 计算属性computed 实际上代表了一个函数的值 12345678910111213141516171819&lt;!--计算属性--&gt;&lt;div id="app"&gt; &#123;&#123;laopo&#125;&#125;&lt;/div&gt;&lt;script&gt; const app=new Vue(&#123; el:"#app", data:&#123; haha:'许愿贞德', dd:"贞环转" &#125;, computed:&#123; laopo:function () &#123; return this.haha+this.dd; &#125; &#125; &#125;)&lt;/script&gt;]]></content>
      <categories>
        <category>休闲</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>javaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jedis的Spring整合、Redis缓存]]></title>
    <url>%2F2019%2F08%2F18%2FSpring%E6%95%B4%E5%90%88Jedis%2F</url>
    <content type="text"><![CDATA[Spring整合Jedis使用RedisJedis是Redis的java版本客户端的实现，通过它，我们可以轻松的创建一个jedis对象来操作Redis数据库，或者将Redis做为缓存使用。 Maven依赖Official Releases 1234567&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;type&gt;jar&lt;/type&gt; &lt;scope&gt;compile&lt;/scope&gt;&lt;/dependency&gt; Snapshots 1234567&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;3.2.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 基本使用单节点 直连方式 12345678//通过连接和端口号，就可以拿到jedis对象Jedis jedis=new Jedis("192.168.1.105",6379);//通过jedis对象，使用命令来操作即可jedis.set("abc","123");String abc = jedis.get("abc");//记得释放 jedis.close(); 连接池方式 1234567891011//先拿到连接池对象 JedisPool pool=new JedisPool("192.168.1.105",6379);//再通过连接拿到实例Jedis jedis = pool.getResource(); jedis.set("gg","2");String gg = jedis.get("gg");//释放连接jedis.close();pool.close(); 多节点集群 12345678910111213141516171819202122//nodes，需要一个Set集合来存放节点（因为set内是不重复的），实现使用HashSetSet&lt;HostAndPort&gt; nodes=new HashSet&lt;HostAndPort&gt;();//单个nodeHostAndPort node1 = new HostAndPort("192.168.1.105", 7001);//放入nodes集合nodes.add(node1);//推荐写法 nodes.add(new HostAndPort("192.168.1.105",7002)); nodes.add(new HostAndPort("192.168.1.105",7003)); nodes.add(new HostAndPort("192.168.1.105",7004)); nodes.add(new HostAndPort("192.168.1.105",7005)); nodes.add(new HostAndPort("192.168.1.105",7006)); //通过node集合拿到jedisCluster对象，就可以使用命令了JedisCluster jedisCluster=new JedisCluster(nodes); jedisCluster.set("222","aaaa");String a222 = jedisCluster.get("222");//可选释放jedisCluster.close(); tips： JedisAPI测试 Set和List Spring整合开发测试时常用单节点模式，需要时切换到集群模式。 单节点 123456789101112131415161718192021222324252627282930 &lt;!-- jedis客户端单机版 --&gt; &lt;bean id="redisClient" class="redis.clients.jedis.JedisPool"&gt; &lt;constructor-arg name="host" value="192.168.25.153"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name="port" value="6379"&gt;&lt;/constructor-arg&gt; &lt;!--连接池配置，不配的话会有个默认配置，可以用 --&gt; &lt;constructor-arg name="poolConfig" ref="jedisPoolConfig"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt;&lt;!-- 连接池配置 --&gt; &lt;bean id="jedisPoolConfig" class="redis.clients.jedis.JedisPoolConfig"&gt; &lt;!-- 最大连接数 --&gt; &lt;property name="maxTotal" value="30" /&gt; &lt;!-- 最大空闲连接数 --&gt; &lt;property name="maxIdle" value="10" /&gt; &lt;!-- 每次释放连接的最大数目 --&gt; &lt;property name="numTestsPerEvictionRun" value="1024" /&gt; &lt;!-- 释放连接的扫描间隔（毫秒） --&gt; &lt;property name="timeBetweenEvictionRunsMillis" value="30000" /&gt; &lt;!-- 连接最小空闲时间 --&gt; &lt;property name="minEvictableIdleTimeMillis" value="1800000" /&gt; &lt;!-- 连接空闲多久后释放, 当空闲时间&gt;该值 且 空闲连接&gt;最大空闲连接数 时直接释放 --&gt; &lt;property name="softMinEvictableIdleTimeMillis" value="10000" /&gt; &lt;!-- 获取连接时的最大等待毫秒数,小于零:阻塞不确定的时间,默认-1 --&gt; &lt;property name="maxWaitMillis" value="1500" /&gt; &lt;!-- 在获取连接的时候检查有效性, 默认false --&gt; &lt;property name="testOnBorrow" value="true" /&gt; &lt;!-- 在空闲时检查有效性, 默认false --&gt; &lt;property name="testWhileIdle" value="true" /&gt; &lt;!-- 连接耗尽时是否阻塞, false报异常,ture阻塞直到超时, 默认true --&gt; &lt;property name="blockWhenExhausted" value="false" /&gt; &lt;/bean&gt; 集群 12345678910111213141516171819202122232425262728293031&lt;bean id="redisClient" class="redis.clients.jedis.JedisCluster"&gt; &lt;constructor-arg name="nodes"&gt; &lt;set&gt; &lt;bean class="redis.clients.jedis.HostAndPort"&gt; &lt;constructor-arg name="host" value="192.168.25.153"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name="port" value="7001"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean class="redis.clients.jedis.HostAndPort"&gt; &lt;constructor-arg name="host" value="192.168.25.153"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name="port" value="7002"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean class="redis.clients.jedis.HostAndPort"&gt; &lt;constructor-arg name="host" value="192.168.25.153"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name="port" value="7003"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean class="redis.clients.jedis.HostAndPort"&gt; &lt;constructor-arg name="host" value="192.168.25.153"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name="port" value="7004"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean class="redis.clients.jedis.HostAndPort"&gt; &lt;constructor-arg name="host" value="192.168.25.153"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name="port" value="7005"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean class="redis.clients.jedis.HostAndPort"&gt; &lt;constructor-arg name="host" value="192.168.25.153"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name="port" value="7006"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;/set&gt; &lt;/constructor-arg&gt; &lt;constructor-arg name="poolConfig" ref="jedisPoolConfig"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; 为了满足两者直接的切换，需要一个Dao层，提供同一个接口，不同的实现类。 通用接口 12345678910111213141516171819202122public interface IJedisDao &#123; String set(String key,String value); String get(String key); long hset(String hkey,String key,String value); String hget(String hkey,String key); long incr(String key); long expire(String key,int second); long ttl(String key); long del (String key); long hdel(String hkey,String key); //...&#125; 单节点模式实现类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283package com.SH.Rest.Dao.DaoImpl;import ...public class JedisDaoSingleImpl implements IJedisDao &#123; @Autowired private JedisPool jedisPool; @Override public String set(String key, String value) &#123; Jedis jedis = jedisPool.getResource(); String s = jedis.set(key, value); jedis.close(); return s; &#125; @Override public String get(String key) &#123; Jedis jedis = jedisPool.getResource(); String s = jedis.get(key); jedis.close(); return s; &#125; @Override public long hset(String hkey, String key, String value) &#123; Jedis jedis = jedisPool.getResource(); Long hset = jedis.hset(hkey, key, value); jedis.close(); return hset; &#125; @Override public String hget(String hkey, String key) &#123; Jedis jedis = jedisPool.getResource(); String s = jedis.hget(hkey, key); jedis.close(); return s; &#125; @Override public long incr(String key) &#123; Jedis jedis = jedisPool.getResource(); Long result = jedis.incr(key); jedis.close(); return result; &#125; @Override public long expire(String key, int second) &#123; Jedis jedis = jedisPool.getResource(); Long result = jedis.expire(key, second); jedis.close(); return result; &#125; @Override public long ttl(String key) &#123; Jedis jedis = jedisPool.getResource(); Long result = jedis.ttl(key); jedis.close(); return result; &#125; @Override public long del(String key) &#123; Jedis jedis = jedisPool.getResource(); Long result = jedis.del(key); jedis.close(); return result; &#125; @Override public long hdel(String hkey, String key) &#123; Jedis jedis = jedisPool.getResource(); Long result = jedis.hdel(hkey, key); jedis.close(); return result; &#125; //...&#125; 使用单点模式时的spring配置： 123456789&lt;!-- Redis客户端，单点模式，连接没配置，为默认--&gt; &lt;bean id="jedisPool" class="redis.clients.jedis.JedisPool"&gt; &lt;constructor-arg name="host" value="192.168.1.105"/&gt; &lt;constructor-arg name="port" value="6379"/&gt; &lt;/bean&gt;&lt;!--单点模式实现类--&gt; &lt;bean id="jedisDao" class="com.SH.Rest.Dao.DaoImpl.JedisDaoSingleImpl"&gt; &lt;/bean&gt; 集群模式实现类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package com.SH.Rest.Dao.DaoImpl;import ...public class JedisDaoClusterImpl implements IJedisDao &#123; //无需释放 @Autowired private JedisCluster jedisCluster; @Override public String get(String key) &#123; return jedisCluster.get(key); &#125; @Override public String set(String key, String value) &#123; return jedisCluster.set(key, value); &#125; @Override public String hget(String hkey, String key) &#123; return jedisCluster.hget(hkey, key); &#125; @Override public long hset(String hkey, String key, String value) &#123; return jedisCluster.hset(hkey, key, value); &#125; @Override public long incr(String key) &#123; return jedisCluster.incr(key); &#125; @Override public long expire(String key, int second) &#123; return jedisCluster.expire(key, second); &#125; @Override public long ttl(String key) &#123; return jedisCluster.ttl(key); &#125; @Override public long del(String key) &#123; return jedisCluster.del(key); &#125; @Override public long hdel(String hkey, String key) &#123; return jedisCluster.hdel(hkey, key); &#125; //...&#125; 使用集群模式时的spring配置： 123456789101112131415161718192021222324252627282930313233343536373839&lt;!-- Redis客户端，集群模式，连接池默认配置 --&gt;&lt;bean id="jedisCluster" class="redis.clients.jedis.JedisCluster"&gt; &lt;constructor-arg name="nodes"&gt; &lt;set&gt; &lt;bean class="redis.clients.jedis.HostAndPort"&gt; &lt;constructor-arg name="host" value="192.168.1.105"/&gt; &lt;constructor-arg name="port" value="7001"/&gt; &lt;/bean&gt; &lt;bean class="redis.clients.jedis.HostAndPort"&gt; &lt;constructor-arg name="host" value="192.168.1.105"/&gt; &lt;constructor-arg name="port" value="7002"/&gt; &lt;/bean&gt; &lt;bean class="redis.clients.jedis.HostAndPort"&gt; &lt;constructor-arg name="host" value="192.168.1.105"/&gt; &lt;constructor-arg name="port" value="7003"/&gt; &lt;/bean&gt; &lt;bean class="redis.clients.jedis.HostAndPort"&gt; &lt;constructor-arg name="host" value="192.168.1.105"/&gt; &lt;constructor-arg name="port" value="7004"/&gt; &lt;/bean&gt; &lt;bean class="redis.clients.jedis.HostAndPort"&gt; &lt;constructor-arg name="host" value="192.168.1.105"/&gt; &lt;constructor-arg name="port" value="7005"/&gt; &lt;/bean&gt; &lt;bean class="redis.clients.jedis.HostAndPort"&gt; &lt;constructor-arg name="host" value="192.168.1.105"/&gt; &lt;constructor-arg name="port" value="7006"/&gt; &lt;/bean&gt; &lt;/set&gt; &lt;/constructor-arg&gt;&lt;/bean&gt;&lt;!--集群模式实现类--&gt;&lt;bean id="jedisDao" class="com.SH.Rest.Dao.DaoImpl.JedisDaoClusterImpl"&gt;&lt;/bean&gt;&lt;!--单点模式实现类，现在是集群模式，所以注释掉这个bean--&gt; &lt;!-- &lt;bean id="jedisDao" class="com.SH.Rest.Dao.DaoImpl.JedisDaoSingleImpl"&gt; &lt;/bean&gt;--&gt; 使用示例缓存的添加不能影响正常的业务逻辑，不管缓存的情况如何，都要保证其他业务逻辑的正常运行，不可中断。 12345678910111213141516171819202122232425262728@AutoWiredprivate IJedisDao jedisDao;@Override public List&lt;Content&gt; getContentList(long id) &#123; //从缓存中取内容 try &#123; String result = jedisDao.hget(HashKEY, id + ""); if (!StringUtils.isBlank(result)) &#123;//判断缓存取出结果是否为空字符串 //把字符串转换成list List&lt;Content&gt; resultList = JsonUtils.jsonToList(result, Content.class); return resultList; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; //正常业务逻辑，根据内容分类id，数据库查询内容列表 List&lt;Content&gt; list = contentMapper.selectByid(id); //向缓存中添加内容 try &#123; //把list转换成字符串 String cacheString = JsonUtils.objectToJson(list); jedisDao.hset(HashKEY, id + "", cacheString); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; 缓存同步 当更新数据库内数据时，需要先把对应的Redis缓存删除（del删除对应key），然后再更新数据库。缓存是由服务层管理的，服务层需要提供一个删除缓存的服务，后台管理系统修改数据时，Http调用该服务即可。]]></content>
      <categories>
        <category>学习经验</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>SSM</tag>
        <tag>Redis</tag>
        <tag>Jedis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue快速入门]]></title>
    <url>%2F2019%2F08%2F18%2FVue%2F</url>
    <content type="text"><![CDATA[Vue框架快速入门实例环境准备 Vue.js【最好下载到本地】 开发工具：WebStorm ## 第一个Vue实例新建html 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!--div#app tab 快捷创建--&gt;&lt;div id="app"&gt; &#123;&#123;m&#125;&#125; &lt;h1&gt;&#123;&#123;h&#125;&#125;&lt;/h1&gt;&lt;/div&gt;&lt;!--引入vue.js --&gt;&lt;script src="js/vue.js"&gt;&lt;/script&gt; &lt;!--Vue实例 --&gt;&lt;script&gt; const a1=new Vue(&#123; el: '#app', data: &#123; m: 'haha', h: 'hehe' &#125; &#125;)&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 运行结果： 总结: const 定义常量，let定义变量。（代替var） new Vue({}) 创建Vue对象 el: ‘#app’ ，把&lt;div id=”app&gt;挂载给Vue对象管理 data:{m: ‘haha’ }，data对象中，有个属性m的值为haha ，Mustache语法，取m的值 编程范式由传统的命令式到声明式，数据与视图分离。 ## 简单列表html： 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!--div#app tab 快捷创建--&gt;&lt;div id="app"&gt; &lt;h1&gt;&#123;&#123;m&#125;&#125;&lt;/h1&gt; &lt;ul v-for="shuju in items"&gt; &lt;li&gt;&#123;&#123;shuju&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;script src="js/vue.js"&gt;&lt;/script&gt;&lt;script&gt; const app=new Vue(&#123; el:'#app', data:&#123; m:"列表", items:["第一个数据","第二个数据","fuck","444"] &#125; &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 运行结果： 总结: items:[“第一个数据”,”第二个数据”,”fuck”,”444”] 定义一个数组 &lt; ul v-for=”shuju in items”&gt; 遍历数组，赋值给一个名为shuju的变量 &lt; li&gt;&lt; /li&gt;取出数据 是响应式，浏览器控制台输入： ## 计数器方式1 123456789101112131415&lt;div id="app"&gt; &lt;h1&gt;计数:&#123;&#123;count&#125;&#125;&lt;/h1&gt; &lt;button v-on:click="count++" &gt; + &lt;/button&gt; &lt;button v-on:click="count--" &gt; - &lt;/button&gt;&lt;/div&gt;&lt;script&gt; const app=new Vue(&#123; el:'#app', data:&#123; count:0 &#125; &#125;)&lt;/script&gt; 方式2 123456789101112131415161718192021222324252627&lt;div id="app"&gt; &lt;h1&gt;计数:&#123;&#123;count&#125;&#125;&lt;/h1&gt; &lt;button v-on:click="add" &gt; + &lt;/button&gt; &lt;button v-on:click="sub" &gt; - &lt;/button&gt;&lt;/div&gt;&lt;script&gt; const app=new Vue(&#123; el:'#app', data:&#123; count:0 &#125;, methods:&#123; add:function () &#123; this.count++; console.log('执行自增');//浏览器控制台打印 &#125;, sub:function () &#123; app.count--; console.log('执行自减');//浏览器控制台打印 &#125; &#125; &#125;)&lt;/script&gt; 总结： &lt; button v-on:click=”” &gt; vi-on监听事件，v-on:click=””监听点击事件 v-on:click=”i++”，直接使i自增 v-on:click=”add”，调用add方法 Vue对象的methods属性 定义方法： 12345methods:&#123; add:function () &#123; this.count++; console.log('执行自增');//浏览器控制台打印 &#125;,]]></content>
      <categories>
        <category>休闲</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>javaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HttpClient]]></title>
    <url>%2F2019%2F08%2F16%2FHttpClient%2F</url>
    <content type="text"><![CDATA[使用HttpClient模拟浏览器访问HttpClient 是Apache HttpComponents 下的子项目，是支持 HTTP 协议的客户端编程工具包。它被用来发送和接受 HTTP 消息，并不能处理http响应内容。 依赖12345 &lt;dependency&gt; &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt; &lt;artifactId&gt;httpclient&lt;/artifactId&gt; &lt;version&gt;4.5.6&lt;/version&gt;&lt;/dependency&gt; 基本使用Get1234567891011//httpClient的创建CloseableHttpClient httpClient = HttpClients.createDefault();//创建一个GET对象HttpGet get = new HttpGet("http://shirtiny.cn");//发送请求，得到一个response对象CloseableHttpResponse response = httpClient.execute(get);//取响应实体，转换成字符串打印HttpEntity entity = response.getEntity();String string = EntityUtils.toString(entity, "utf-8");//响应状态码int statusCode = response.getStatusLine().getStatusCode(); 当需要传递参数时，可以直接在url改，也可以使用URIBuilder构建url 参数 1234567891011//基础urlURIBuilder uriBuilder = new URIBuilder("https://api.kaaass.net/biliapi/video/resolve");//加入参数uriBuilder.addParameter("id","53175612");uriBuilder.addParameter("quality","80");//构建出urlURI uri = uriBuilder.build();//放入get请求对象中即可HttpGet get=new HttpGet(uri);//然后执行...httpClient.execute(get); POST与Get类似。当需要提交表格数据时： 123456789101112//创建一个post对象HttpPost post = new HttpPost("http://localhost:8082/httpclient/post.html");//创建一个Entity。模拟一个表单List&lt;NameValuePair&gt; kvList = new ArrayList&lt;&gt;();kvList.add(new BasicNameValuePair("username", "zhangsan"));kvList.add(new BasicNameValuePair("password", "123")); //包装成一个Entity对象StringEntity entity = new UrlEncodedFormEntity(kvList, "utf-8");//设置请求的内容post.setEntity(entity);//执行post请求CloseableHttpResponse response = httpClient.execute(post); 工具类一个方便其他服务调用的httpClient的工具类。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118package Http_Utils;import ...public class HttpClientUtil &#123; public static String doGet(String url, Map&lt;String, String&gt; param) &#123; // 创建Httpclient对象 CloseableHttpClient httpclient = HttpClients.createDefault(); String resultString = ""; CloseableHttpResponse response = null; try &#123; // 创建uri URIBuilder builder = new URIBuilder(url); if (param != null) &#123; for (String key : param.keySet()) &#123; builder.addParameter(key, param.get(key)); &#125; &#125; URI uri = builder.build(); // 创建http GET请求 HttpGet httpGet = new HttpGet(uri); // 执行请求 response = httpclient.execute(httpGet); // 判断返回状态是否为200 if (response.getStatusLine().getStatusCode() == 200) &#123; resultString = EntityUtils.toString(response.getEntity(), "UTF-8"); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; if (response != null) &#123; response.close(); &#125; httpclient.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; return resultString; &#125; public static String doGet(String url) &#123; return doGet(url, null); &#125; public static String doPost(String url, Map&lt;String, String&gt; param) &#123; // 创建Httpclient对象 CloseableHttpClient httpClient = HttpClients.createDefault(); CloseableHttpResponse response = null; String resultString = ""; try &#123; // 创建Http Post请求 HttpPost httpPost = new HttpPost(url); // 创建参数列表 if (param != null) &#123; List&lt;NameValuePair&gt; paramList = new ArrayList&lt;&gt;(); for (String key : param.keySet()) &#123; paramList.add(new BasicNameValuePair(key, param.get(key))); &#125; // 模拟表单 UrlEncodedFormEntity entity = new UrlEncodedFormEntity(paramList); httpPost.setEntity(entity); &#125; // 执行http请求 response = httpClient.execute(httpPost); resultString = EntityUtils.toString(response.getEntity(), "utf-8"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; response.close(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; return resultString; &#125; public static String doPost(String url) &#123; return doPost(url, null); &#125; public static String doPostJson(String url, String json) &#123; // 创建Httpclient对象 CloseableHttpClient httpClient = HttpClients.createDefault(); CloseableHttpResponse response = null; String resultString = ""; try &#123; // 创建Http Post请求 HttpPost httpPost = new HttpPost(url); // 创建请求内容 StringEntity entity = new StringEntity(json, ContentType.APPLICATION_JSON); httpPost.setEntity(entity); // 执行http请求 response = httpClient.execute(httpPost); resultString = EntityUtils.toString(response.getEntity(), "utf-8"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; response.close(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; return resultString; &#125;&#125; HttpClient详解 pdf文档]]></content>
      <categories>
        <category>学习经验</category>
      </categories>
      <tags>
        <tag>httpclient</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二维数组⇌稀疏数组⇌数据文件]]></title>
    <url>%2F2019%2F08%2F11%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84-%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84-%E6%95%B0%E6%8D%AE%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[数据结构与算法稀疏数组SparseArray 1. 什么是稀疏数组一个数组含有大量重复的值的时候，可以把它转化为稀疏数组来表示，这样会大量节省空间占用。 稀疏数组： 是个二维数组，只有3列，分别对应：行row、列col、值value 第一行表示原数组的行数、列数、有效值个数。（注意，0是第一行） 从第二行开始，每行都会对应一个有效值。 用row（第一列）表示有效值是在原数组中的第几行 用col（第二列）表示有效值是在原数组中的第几列 用value（第三列）表示有效值在原数组中的值 行数为原数组有效值个数+1 示例： 原数组 0，0，0，0，0 1，0，2，0，0 0，0，0，0，0 0，0，0，1，0 对应的稀疏数组： 4，5，3 //表示原数组有4行、5列、3个有效值 1，0，1 //表示一个有效值，位置在原数组的第2行、第1列、值为1 1，2，2 //同上，表示位置在原数组第2行、第3列、值为2 3，3，1 //表示位置在原数组第4行、第4列、值为1 2. 二维数组⇌稀疏数组java代码演示，相互转换的过程。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101package SparseArray;import java.util.Arrays;public class SparseArray &#123; public static void main(String[] args) &#123; //1. 新建一个二维数组 int[][] array1 = new int[4][5]; //2. 给数组赋一些值 array1[1][0]=1; array1[1][2]=2; array1[3][3]=1; //3. 格式化输出数组 for (int i=0;i&lt;array1.length;i++)&#123;//array1.length是行数 for (int j=0;j&lt;array1[0].length;j++)&#123;//array1[0].length是第0行的列数// System.out.print(array1[i][j]+"\t"); &#125;// System.out.println(); &#125; //4. 更好的输出方式foreach System.out.println("##############这是原数组1"); for (int[] row:array1)&#123; for (int value:row)&#123; System.out.print(value+"\t"); &#125; System.out.println(); &#125; //5. 转为稀疏数组，首先需要得到原数组中的有效值个数 System.out.println("##############"); int num=0; for (int[] row:array1)&#123; for(int value:row)&#123; if (value!=0)&#123; num++; &#125; &#125; &#125; System.out.println("原数组1有："+num+"个有效值"); //6. 创建稀疏数组，因为稀疏数组第一行是对原数组大小的描述，其他行都是对有效值的描述， //所以，稀疏数组行数是 原数组有效值个数+1。 int [][] sparseArray=new int[num+1][3]; //7. 对稀疏数组的第一行赋值，对应原数组的行数、列数、有效值个数 sparseArray[0][0]=4; sparseArray[0][1]=5; sparseArray[0][2]=3; //8. 为稀疏数组赋值，对原数组进行遍历，需要明确第几行第几列 int n=1; for (int i=0;i&lt;array1.length;i++)&#123; for (int j=0;j&lt;array1[0].length;j++)&#123; if (array1[i][j]!=0)&#123; sparseArray[n][0]=i; sparseArray[n][1]=j; sparseArray[n][2]=array1[i][j]; n++; &#125; &#125; &#125; //9. 输出稀疏数组 System.out.println("##############这是转换后的稀疏数组"); for (int[] row:sparseArray)&#123; for (int value:row)&#123; System.out.print(value+"\t"); &#125; System.out.println(); &#125; //10. 再恢复成原数组 // 创建一个原数组2，原数组2的行数，是稀疏数组的第一行第一列的值 // 原数组2的列数，是稀疏数组的第一行第二列的值 int[][] array2=new int[sparseArray[0][0]][sparseArray[0][1]]; //11. 把稀疏数组中的有效值读出，赋给原数组2， // 只需付给原数组2有效值，i从1开始，也就是第二行开始， // 稀疏数组第i行，第1列是有效值的行数，第2列是有效值的列数，第3列是有效值的值 // 因为稀疏数组固定只有3列，一个循环即可 for (int i=1;i&lt;sparseArray.length;i++)&#123; array2[sparseArray[i][0]][sparseArray[i][1]]=sparseArray[i][2]; &#125; //12. 输出回复后的原数组2 System.out.println("##############这是恢复后的原数组2"); for (int[] row:array2)&#123; for (int value:row)&#123; System.out.print(value+"\t"); &#125; System.out.println(); &#125; &#125;&#125; 输出结果： ##############这是原数组10 0 0 0 01 0 2 0 00 0 0 0 00 0 0 1 0 ##############原数组1有：3个有效值 ##############这是转换后的稀疏数组4 5 31 0 11 2 23 3 1 ##############这是恢复后的原数组20 0 0 0 01 0 2 0 00 0 0 0 00 0 0 1 0 3. 稀疏数组⇌数据文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//13. 将稀疏数组存入本地文件 File file =new File("D:\\aria2\\SparseArray.data"); Writer writer=new FileWriter(file); for (int[] row:sparseArray)&#123; for (int value:row)&#123; writer.write(value+"\t"); &#125; writer.write("\r\n"); &#125; writer.close();//14. 从本地文件读取稀疏数组 System.out.println("##############这是从文件恢复的稀疏数组2"); //1.创建源 File src = new File("D:\\aria2\\SparseArray.data"); //2.选择流 BufferedReader in = new BufferedReader(new FileReader(src)); //3.1进行数据的搬移，但是数组首要考虑的事情是数组要多大？ int row =0;//用于创建要创建的二维稀疏数组的大小确定 String line; //一行数据 //逐行读取，并将每个数组放入到数组中 while ((line = in.readLine()) != null) &#123; row++; &#125; int sparseArr2[][] = new int [row][3]; //3.2文本数据转移到稀疏数组中 int rowtmp = 0; //由于读取完毕整个文本文档，重启流 in.close(); in = new BufferedReader(new FileReader(src)); while ((line = in.readLine()) != null) &#123; String[] temp = line.split("\t"); for (int j = 0; j &lt; temp.length; j++) &#123; sparseArr2[rowtmp][j]=Integer.parseInt(temp[j]); &#125; rowtmp++; &#125; //4.关闭流 in.close(); //验证文件读取是否正确 for(int[]temp1:sparseArr2) &#123; for (int temp2 : temp1) &#123; System.out.printf("%d\t", temp2); &#125; System.out.println(); &#125; 参考文章：稀疏数组转换、稀疏数组到文件、array[0].length、\r\n的区别]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JsonP跨域请求]]></title>
    <url>%2F2019%2F08%2F11%2FJsonP%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%2F</url>
    <content type="text"><![CDATA[使用JsonP跨域获取json数据JsonP示例JsonP的主要实现举例： 123456789101112131415161718192021222324252627282930var category = &#123;OBJ: $("#_JD_ALLSORT"), URL_Serv: "http://localhost:8082/category.json"&#125;,FN_GetData: function() &#123; //使用jsonp来实现跨域请求 $.getJSONP(this.URL_Serv, category.getDataService); //直接使用ajax请求json数据 /*$.getJSON(this.URL_Serv, function(json)&#123; category.getDataService(json); &#125;);*///解析json数据&#125;,getDataService: function(a) &#123; var b = [], c = this; $.each(a.data, function(a) &#123; this.index = a, "l" == this.t &amp;&amp; (this.i = c.FN_RefactorJSON(this.i, 7)), b.push(c.renderItem(this, a)) &#125;); b.push('&lt;div class="extra"&gt;&lt;a &#123;if pageConfig.isHome&#125;clstag="homepage|keycount|home2013|0614a"&#123;/if&#125; href="http://www.jd.com/allSort.aspx"&gt;\u5168\u90e8\u5546\u54c1\u5206\u7c7b&lt;/a&gt;&lt;/div&gt;'), this.OBJ.attr("load", "1").html(b.join("")), $.bigiframe(this.OBJ), this.FN_GetBrands(); var d = this, e = this.OBJ.outerWidth(), f = this.OBJ.outerHeight(); $("#_JD_ALLSORT").dropdown(&#123;delay: 0,onmouseleave: function() &#123; $("#_JD_ALLSORT .item").removeClass("hover") &#125;&#125;, function(a) &#123; var b, c, g = document.documentElement.scrollTop + document.body.scrollTop, h = $("#nav-2013").offset().top + 39; h &gt;= g ? (c = a.hasClass("fore13") ? 3 : 3, g = c) : (b = a.offset().top, g = g &gt; b - 5 ? b - h - 10 : Math.max(3, g - h)); var i = a.find(".i-mc"); if (i.css(&#123;top: g + "px"&#125;), d.OBJ.find("iframe")) &#123; var j = i.outerWidth() + e, k = i.outerHeight() &gt; f ? i.outerHeight() : f; d.OBJ.find("iframe").css(&#123;width: j,height: k,top: g&#125;) &#125; &#125;)&#125; 其中，http://localhost:8082/category.json的内容为： 1234567891011121314151617181920category.getDataService(&#123; "data": [ &#123; "u": "/products/1.html", "n": "&lt;a href='/products/1.html'&gt;图书、音像、电子书刊&lt;/a&gt;", "i": [ &#123; "u": "/products/2.html", "n": "电子书刊", "i": [ "/products/3.html|电子书", "/products/4.html|网络原创", "/products/5.html|数字杂志", "/products/6.html|多媒体图书" ] &#125; ]&#125;]&#125; ); 其实是一段js，把json包装在参数里。 跨域请求为什么不能直接用Ajax 直接使用ajax请求另一个端口上的json数据: 1234//直接使用ajax请求另一个端口上的json数据 $.getJSON(this.URL_Serv, function(json)&#123; category.getDataService(json); &#125;); 会出现以下异常： No &#39;Access-Control-Allow-Origin&#39; 什么是跨域 当一个请求url的协议、域名、端口三者之间任意一个与当前页面url不同即为跨域。 协议http-&gt;https、端口8081-&gt;8082、域名Shirtiny.cn-&gt;Github.com，都为跨域。 跨域问题的产生 同源策略（Sameoriginpolicy）是一种约定，它是浏览器最核心也最基本的安全功能。 同源策略会阻止一个域的javascript脚本和另外一个域的内容进行交互。所谓同源（即指在同一个域）就是两个页面具有相同的协议（protocol），主机（host）和端口号（port） 跨域的解决方式 document.domain 跨文档通信 API JSONP CORS JsonP流程JSONP 只支持get请求，不支持post请求。 核心思想：用特定方式请求 JSON 数据，服务器收到请求后，将数据放在一个指定名字的回调函数的参数位置传回来。 数据库查询-&gt;构建pojo对象首先需要把数据库中的数据查询出来，数据库中有时并不是直接保存的json数据，如存储的分类目录表： 12345678910111213CREATE TABLE `tb_item_cat` ( `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '类目ID', `parent_id` bigint(20) DEFAULT NULL COMMENT '父类目ID=0时，代表的是一级的类目', `name` varchar(50) DEFAULT NULL COMMENT '类目名称', `status` int(1) DEFAULT '1' COMMENT '状态。可选值:1(正常),2(删除)', `sort_order` int(4) DEFAULT NULL COMMENT '排列序号，表示同级类目的展现次序，如数值相等则按名称次序排列。取值范围:大于零的整数', `is_parent` tinyint(1) DEFAULT '1' COMMENT '该类目是否为父类目，1为true，0为false', `created` datetime DEFAULT NULL COMMENT '创建时间', `updated` datetime DEFAULT NULL COMMENT '创建时间', PRIMARY KEY (`id`), KEY `parent_id` (`parent_id`,`status`) USING BTREE, KEY `sort_order` (`sort_order`)) ENGINE=InnoDB AUTO_INCREMENT=1183 DEFAULT CHARSET=utf8 COMMENT='商品类目'; 为了能让查询到的数据转为json格式，我们需要构建Pojo对象。 需要的Json数据格式： 我们可以看到data是根节点，它有很多[0]、[1]、[2]这样的节点。节点包含属性u、n、i，而其中i又是一个子节点，它又包含了自己的u、n、i属性，其中i最终包含了若干字符串。 pojo类的构建我们把根节点data单独拿出来，构建出JsonData类，因为一个Json里会有1个存放节点集合的data根节点。 12345678910111213141516171819202122232425262728293031package com.SH.Rest.Pojo;import java.util.List;public class JsonData &#123; List&lt;?&gt; data; public List&lt;?&gt; getData() &#123; return data; &#125; public void setData(List&lt;?&gt; data) &#123; this.data = data; &#125; public JsonData(List&lt;?&gt; data) &#123; this.data = data; &#125; public JsonData() &#123; &#125; @Override public String toString() &#123; return "JsonData&#123;" + "data=" + data + '&#125;'; &#125;&#125; 每个data的节点以及节点的子节点，都有u、n、i 这3个属性，其中i都为一个集合，所以我们构建DataNode类，用来表示子节点。使用@JsonProperty(“”)注解，用来指定对应属性，转换成json数据对应的key名称。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package com.SH.Rest.Pojo;import com.fasterxml.jackson.annotation.JsonProperty;import java.util.List;public class DataNodes &#123; @JsonProperty("u") String url; @JsonProperty("n") String name; @JsonProperty("i") List&lt;?&gt; item; public DataNodes() &#123; &#125; public DataNodes(String url, String name, List&lt;?&gt; item) &#123; this.url = url; this.name = name; this.item = item; &#125; @Override public String toString() &#123; return "DataNodes&#123;" + "url='" + url + '\'' + ", name='" + name + '\'' + ", item=" + item + '&#125;'; &#125; public String getUrl() &#123; return url; &#125; public void setUrl(String url) &#123; this.url = url; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public List&lt;?&gt; getItem() &#123; return item; &#125; public void setItem(List&lt;?&gt; item) &#123; this.item = item; &#125;&#125; Service递归构建，得到节点pojo对象集合1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.SH.Rest.Service.serviceImpl;import ...@Servicepublic class JsonPserviceImpl implements IJsonPService &#123; @Autowired private TbItemCatMapper tbItemCatMapper; @Override public List&lt;?&gt; selectJson(long parentId) &#123; //设定查询条件，先查询库中所有parentId为0的目录，即所有顶层目录 TbItemCatExample example = new TbItemCatExample(); TbItemCatExample.Criteria criteria = example.createCriteria(); criteria.andParentIdEqualTo(parentId); List&lt;TbItemCat&gt; list = tbItemCatMapper.selectByExample(example);//执行 List resultList = new ArrayList&lt;&gt;(); //向list中添加节点 for (TbItemCat tbItemCat : list) &#123; //判断是否为父节点 if (tbItemCat.getIsParent()) &#123; DataNode dataNode = new DataNode(); if (parentId == 0) &#123; dataNode.setName("&lt;a href='/products/"+tbItemCat.getId()+".html'&gt;"+tbItemCat.getName()+"&lt;/a&gt;"); &#125; else &#123; dataNode.setName(tbItemCat.getName()); &#125; dataNode.setUrl("/products/"+tbItemCat.getId()+".html"); //递归 dataNode.setItem(selectJson(tbItemCat.getId())); resultList.add(dataNode); //如果是叶子节点 &#125; else &#123; resultList.add("/products/"+tbItemCat.getId()+".html|" + tbItemCat.getName()); &#125; &#125; return resultList; &#125;&#125; Controller把节点集合封装到data根节点对象，然后转换成json字符串12345678910111213141516171819202122232425262728package com.SH.Rest.Controller;import ...@Controllerpublic class JsonPController &#123; @Autowired private IJsonPService jsonPService; @RequestMapping(value = "/AllCategory",produces = "text/plain;charset=UTF-8") /*设置输出编码，或 @RequestMapping(value="/itemcat/list", produces=MediaType.APPLICATION_JSON_VALUE + ";charset=utf-8") */ @ResponseBody public String AllCategory(String callBack)&#123; List&lt;?&gt; dataNodelist = jsonPService.selectJson(0); JsonData data=new JsonData(); data.setData(dataNodelist); String json = JsonUtils.objectToJson(data); //拼接成js语句，callBack参数为请求中传递来的函数名 json=callBack+"("+json+");"; return json; &#125;&#125; 另一种方式（需要spring版本支持）： 12345678910@RequestMapping("/AllCategory") @ResponseBody public Object AllCategory(String callBack) &#123; List&lt;?&gt; dataNodelist = jsonPService.selectJson(0); JsonData data=new JsonData(); data.setData(dataNodelist); MappingJacksonValue mappingJacksonValue = new MappingJacksonValue(data); mappingJacksonValue.setJsonpFunction(callback); return mappingJacksonValue; &#125; 此时客户端只需要发请求： 1http://本机：端口/AllCategory?callBack=自定义函数 然后会自动调用自定义的函数，并将参数值（也就是json数据）传过来，详情可以看文章开头。 CORS方式]]></content>
      <categories>
        <category>学习经验</category>
      </categories>
      <tags>
        <tag>JsonP</tag>
        <tag>Js跨域请求</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Json格式数据转Html表格]]></title>
    <url>%2F2019%2F08%2F09%2FJson%E6%A0%BC%E5%BC%8F%E6%95%B0%E6%8D%AE%E8%BD%ACHtml%E9%A1%B5%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[Json数据→包含html语言的字符串输入数据数据库可以把下面的Json格式的字符串数据存储起来 123456789101112131415[ &#123;"group":"主体", "params":[ &#123;"k":"品牌","v":"1"&#125;, &#123;"k":"型号","v":"2"&#125;, &#123;"k":"颜色","v":"3"&#125;, &#123;"k":"上市年份","v":"4"&#125;]&#125;, &#123;"group":"网络", "params":[&#123;"k":"4G网络制式","v":"a"&#125;, &#123;"k":"3G网络制式","v":"b"&#125;, &#123;"k":"2G网络制式","v":"c"&#125;]&#125;, &#123;"group":"存储", "params":[&#123;"k":"机身内存","v":"de"&#125;, &#123;"k":"储存卡类型","v":"ef"&#125;]&#125;] 需要把json转成ListJson到java对象的转换，工具类： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package com.SH.utils;import java.util.List;import ... /*工具类，用于把json数据转成需要的java对象 */public class JsonUtils &#123; // 定义jackson对象 private static final ObjectMapper MAPPER = new ObjectMapper(); /** * 将对象转换成json字符串。 * &lt;p&gt;Title: pojoToJson&lt;/p&gt; * &lt;p&gt;Description: &lt;/p&gt; * @param data * @return */ public static String objectToJson(Object data) &#123; try &#123; String string = MAPPER.writeValueAsString(data); return string; &#125; catch (JsonProcessingException e) &#123; e.printStackTrace(); &#125; return null; &#125; /** * 将json结果集转化为对象 * * @param jsonData json数据 * @param clazz 对象中的object类型 * @return */ public static &lt;T&gt; T jsonToPojo(String jsonData, Class&lt;T&gt; beanType) &#123; try &#123; T t = MAPPER.readValue(jsonData, beanType); return t; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null; &#125; /** * 将json数据转换成pojo对象list * &lt;p&gt;Title: jsonToList&lt;/p&gt; * &lt;p&gt;Description: &lt;/p&gt; * @param jsonData * @param beanType * @return */ public static &lt;T&gt;List&lt;T&gt; jsonToList(String jsonData, Class&lt;T&gt; beanType) &#123; JavaType javaType = MAPPER.getTypeFactory().constructParametricType(List.class, beanType); try &#123; List&lt;T&gt; list = MAPPER.readValue(jsonData, javaType); return list; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null; &#125; &#125; 详细参考拿到数据库里的Json数据后，对其进行转换，两次遍历，利用map拿到value，然后使用StringBuffer生成html格式的字符串。 123456789101112131415161718192021222324252627282930@Servicepublic class SqlJson2JavaString &#123; public String json2String(String sqlData) &#123; String jsonData = sqlData; //生成html // 把规格参数json数据转换成java对象 List&lt;Map&gt; jsonList = JsonUtils.jsonToList(jsonData, Map.class); StringBuffer sb = new StringBuffer(); sb.append("&lt;table cellpadding=\"0\" cellspacing=\"1\" width=\"100%\" border=\"0\" class=\"Ptable\"&gt;\n"); sb.append(" &lt;tbody&gt;\n"); for(Map m1:jsonList) &#123; sb.append(" &lt;tr&gt;\n"); sb.append(" &lt;th class=\"tdTitle\" colspan=\"2\"&gt;"+m1.get("group")+"&lt;/th&gt;\n"); sb.append(" &lt;/tr&gt;\n"); List&lt;Map&gt; list2 = (List&lt;Map&gt;) m1.get("params"); for(Map m2:list2) &#123; sb.append(" &lt;tr&gt;\n"); sb.append(" &lt;td class=\"tdTitle\"&gt;"+m2.get("k")+"&lt;/td&gt;\n"); sb.append(" &lt;td&gt;"+m2.get("v")+"&lt;/td&gt;\n"); sb.append(" &lt;/tr&gt;\n"); &#125; &#125; sb.append(" &lt;/tbody&gt;\n"); sb.append("&lt;/table&gt;"); return sb.toString(); &#125;&#125; 这样，数据库存储中，这种&lt;K,V&gt;对形式的表格数据，可以用json数据保存，可以单表操作。 输出结果 使用工具类，处理数据库中json格式数据 123//将接收到的jsonData，转为map集合List&lt;Map&gt; jsonList = JsonUtils.jsonToList(jsonData, Map.class);System.out.println(jsonList); 打印转换的结果： 1[&#123;group=主体, params=[&#123;k=品牌, v=1&#125;, &#123;k=型号, v=2&#125;, &#123;k=颜色, v=3&#125;, &#123;k=上市年份, v=4&#125;]&#125;, &#123;group=网络, params=[&#123;k=4G网络制式, v=a&#125;, &#123;k=3G网络制式, v=b&#125;, &#123;k=2G网络制式, v=c&#125;]&#125;, &#123;group=存储, params=[&#123;k=机身内存, v=de&#125;, &#123;k=储存卡类型, v=ef&#125;]&#125;] 使用StringBuffer和遍历取出需要的数据： 123456789101112131415161718StringBuffer sb = new StringBuffer(); sb.append("&lt;table cellpadding=\"0\" cellspacing=\"1\" width=\"100%\" border=\"0\" class=\"Ptable\"&gt;\n"); sb.append(" &lt;tbody&gt;\n"); for(Map m1:jsonList) &#123; sb.append(" &lt;tr&gt;\n"); sb.append(" &lt;th class=\"tdTitle\" colspan=\"2\"&gt;"+m1.get("group")+"&lt;/th&gt;\n"); sb.append(" &lt;/tr&gt;\n"); List&lt;Map&gt; list2 = (List&lt;Map&gt;) m1.get("params"); for(Map m2:list2) &#123; sb.append(" &lt;tr&gt;\n"); sb.append(" &lt;td class=\"tdTitle\"&gt;"+m2.get("k")+"&lt;/td&gt;\n"); sb.append(" &lt;td&gt;"+m2.get("v")+"&lt;/td&gt;\n"); sb.append(" &lt;/tr&gt;\n"); &#125; &#125; sb.append(" &lt;/tbody&gt;\n"); sb.append("&lt;/table&gt;"); return sb.toString(); 最终结果为： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;table cellpadding="0" cellspacing="1" width="100%" border="0" class="Ptable"&gt; &lt;tbody&gt; &lt;tr&gt; &lt;th class="tdTitle" colspan="2"&gt;主体&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class="tdTitle"&gt;品牌&lt;/td&gt; &lt;td&gt;1&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class="tdTitle"&gt;型号&lt;/td&gt; &lt;td&gt;2&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class="tdTitle"&gt;颜色&lt;/td&gt; &lt;td&gt;3&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class="tdTitle"&gt;上市年份&lt;/td&gt; &lt;td&gt;4&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th class="tdTitle" colspan="2"&gt;网络&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class="tdTitle"&gt;4G网络制式&lt;/td&gt; &lt;td&gt;a&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class="tdTitle"&gt;3G网络制式&lt;/td&gt; &lt;td&gt;b&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class="tdTitle"&gt;2G网络制式&lt;/td&gt; &lt;td&gt;c&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th class="tdTitle" colspan="2"&gt;存储&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class="tdTitle"&gt;机身内存&lt;/td&gt; &lt;td&gt;de&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class="tdTitle"&gt;储存卡类型&lt;/td&gt; &lt;td&gt;ef&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt;]]></content>
      <categories>
        <category>学习经验</category>
      </categories>
      <tags>
        <tag>Json</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[music list]]></title>
    <url>%2F2019%2F08%2F07%2Fmusic-list%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>音乐</category>
      </categories>
      <tags>
        <tag>音乐</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[花に亡霊]]></title>
    <url>%2F2019%2F08%2F07%2F%E8%8A%B1%E3%81%AB%E4%BA%A1%E9%9C%8A%2F</url>
    <content type="text"><![CDATA[[by:时雨改三] [00:00.73]或许你已经忘记了吧 [00:04.00]我们曾坐在夏日的树荫下 将冰淇淋送入口中 [00:11.47]或许你已经忘记了吧 这世上净是谎言 [00:17.02]我们曾笑着说要去寻找真正的价值 [00:26.43]别让记忆消逝了 也别让色彩褪去了 [00:31.63]别让仅留于形影上的成为全部 [00:39.10]告诉我更多的言语吧 告诉我夏日即将来临 [00:44.30]我描绘着的 是映入眼帘的那夏日的亡灵呀 [00:49.69]裙摆随着夏风摇曳 回忆什么的就让它消逝吧 [00:54.93]轻轻地呼吸着 拭去的汗水滴成了夏 [01:22.29]或许你已经忘记了吧 [01:24.74]我们不是曾坐在夏日的树荫下 看到从远处山丘上探出头的那朵白云嘛 [01:32.74]你想要将它握入手中 傻傻地在空中比划着手 [01:37.97]我在纸上将它画下 笑着拿给你看 [01:45.04]别让记忆消逝了 [01:47.37]也别让色彩褪去了 [01:50.07]因为载入史册中的并非全部啊 [01:57.62]此刻容颜消散 [02:00.10]话语尽忘 [02:02.59]你微笑着 [02:04.43]我们是等待着夏日的亡灵啊 [02:07.89]向我更多诉说你的内心吧 [02:10.55]告诉我夏日的气息吧 [02:13.44]轻轻地呼吸着 [02:46.16]不要让记忆消逝啊 [02:48.74]不要让色彩褪去啊 [02:51.39]因为响彻于心灵的并非全部啊 [03:01.36]告诉我更多的话语吧 [03:03.86]告诉我什么是告别吧 [03:06.76]我现在仍在看着哦 [03:08.50]那夏日盛开繁花上的亡灵啊 [03:11.77]并非言语 而是时间 [03:14.83]也非时间 而是心灵 [03:17.43]轻轻地呼吸着 拭去汗水 夏意渐浓 [03:27.81]散发出夏日的气息 [03:47.12]或许你已经忘了吧 [03:49.59]我们曾坐在夏日的树荫下 将冰淇淋送入口中 等待着一阵清风 var ap = new APlayer({ element: document.getElementById("aplayer-UlkPbAfK"), narrow: false, autoplay: false, showlrc: 2, music: { title: "花に亡霊", author: "ヨルシカ", url: "https://sh-rep.oss-cn-hongkong.aliyuncs.com/%E8%8A%B1%E3%81%AB%E4%BA%A1%E9%9C%8A%20-%20%E3%83%A8%E3%83%AB%E3%82%B7%E3%82%AB.mp3", pic: "/2019/08/07/花に亡霊/花に亡霊%20-%20ヨルシカ.jpg", lrc: "花に亡霊 - ヨルシカ.lrc" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap);]]></content>
      <categories>
        <category>音乐</category>
      </categories>
      <tags>
        <tag>音乐</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新增视频播放插件]]></title>
    <url>%2F2019%2F08%2F06%2F%E6%96%B0%E5%A2%9E%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[更新视频、音频插件支持 有了服务器支持，现在可以用自己的媒体源了，媒体内容可以不再受公网限制。之前做html视频嵌入示例，发现部分html内容在https下无法正常使用，于是博客新增了对视频源的播放支持。 效果： (function(){var player = new DPlayer({"container":document.getElementById("dplayer1"),"autoplay":true,"theme":"#FADFA3","loop":true,"video":{"url":"http://server.shirtiny.cn/video/ys.mp4"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})() 这个插件是基于DPlayer的 ，若视频连接出错，多半是因为换了服务器ip或者暂时关闭了服务器，有的时间段会比较卡，也可能是协议的问题。 只需要安装对应插件，然后Github上有详细的文档说明，用起来也很方便。功能挺好的，只是有时候这播放器会出bug。 官方文档： 音乐播放插件：hexo-tag-aplayer 视频播放插件：hexo-tag-dplayer 安装插件： 1234#视频播放插件npm install hexo-tag-dplayer --save#音频播放插件，不过音乐是能正常播放的，暂时用不到这个npm install hexo-tag-aplayer --save 示例： 视频 12&lt;!-- 效果是上面的视频 ，沒声音是因为，这个视频源没加音频。有声音是因为文章下面有个背景音乐（显示中）--&gt;&#123;% dplayer "url=http://45.77.226.194/video/ys.mp4" "loop=yes" "theme=#FADFA3" "autoplay=true" %&#125; 其实相当于使用DPlayer： 123456789101112131415161718192021222324252627282930313233343536&#123;% raw %&#125;&lt;div id="player1" class="dplayer"&gt;&lt;/div&gt;&lt;script src="dist/DPlayer.min.js"&gt;&lt;/script&gt;&lt;!-- use your path --&gt;&lt;script&gt;var dp = new DPlayer(&#123;&#123; container: document.getElementById('dplayer'), autoplay: false, theme: '#FADFA3', loop: true, screenshot: true, hotkey: true, logo: 'logo.png', volume: 0.2, mutex: true, video: &#123; url: 'http://78.141.206.203/video/ys.mp4', pic: '', thumbnails: '', type: 'auto' &#125;, subtitle: &#123; &#125;, danmaku: &#123; &#125;, unlimited: true &#125;, contextmenu: [ &#123; &#125; ]&#125;);&lt;/script&gt;&#123;% endraw %&#125; 音频 1&#123;% aplayer "马宿" "Zelda" "http://78.141.206.203/music/masu.mp3" "autoplay" %&#125; var ap = new APlayer({ element: document.getElementById("aplayer-MMktnZTj"), narrow: false, autoplay: true, showlrc: false, music: { title: "马宿", author: "Zelda", url: "http://server.shirtiny.cn/music/masu.mp3", pic: "", lrc: "" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 参考文章]]></content>
      <categories>
        <category>系统维护</category>
      </categories>
      <tags>
        <tag>博客维护</tag>
        <tag>播放插件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在线视频播放、直播]]></title>
    <url>%2F2019%2F08%2F06%2F%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE%E3%80%81%E7%9B%B4%E6%92%AD%2F</url>
    <content type="text"><![CDATA[Nginx初窥：视频、直播前篇文章说了Sftp下的文件上传，访问时比如图片、json文件等是可以直接显示的。可压缩包或视频文件等，访问时只能下载，如何让视频在线播放？ 环境准备： 可用的服务器（CentOS 7系统）、Nginx、Nginx-Rtmp模块 、Ffmpeg、Jwplayer(可以从连接另存文件，不用登录) 工具：Xshell 6、Xftp 5 1. 在线视频播放其实要播放比较简单，主要问题是网速、负载等，这些是生产环境需要考虑的。 1.1. 安装Nginx服务器安装Nginx，包括远程工具，参照我之前的文章即可。 ### 1.2. 安装Nginx-Rtmp模块 在Github上下载nginx-rtmp-module-1.2.1.tar.gz 使用Xftp将下载的压缩包传到服务器的/usr/local文件夹。放哪都行，自己能找到就行。 使用tar命令解压该文件，得到nginx-rtmp-module-1.2.1文件夹，我的文件夹位置为： 1/usr/local/nginx-rtmp-module-1.2.1 此时，你需要找到之前Nginx解压后的文件夹，就是那个带版本号的文件夹。我的Nginx源码目录是： 1/usr/local/nginx-1.17.1 进入Nginx源码文件夹 1cd /usr/local/nginx-1.17.1 安装Nginx-Rtmp模块 此时，一定要进入nginx源码文件，不然找不到configure。还要注意找到之前rtmp模块解压后的文件夹位置，此时我nginx-1.17.1和nginx-rtmp-module-1.2.1都是放在/usr/local下的，所以用../就能找到。 123./configure --add-module=../nginx-rtmp-module-1.2.1 --with-http_ssl_modulemakemake install 模块安装完成。 参考：官方文档 1.3. 视频播放配置 打开/usr/local/nginx/conf目录下的nginx.conf配置文件，nginx是Nginx的安装目录 1vi /usr/local/nginx/conf/nginx.conf 键盘按i编辑，方向键移动光标，编辑完按 ” :wq “ 保存退出 编辑内容： 光标移动到文件最底部大括号外 （http｛｝代码块外），增加rtmp代码块： 12345678910111213141516rtmp&#123; server&#123; listen 2019; chunk_size 4096; #应用名随意，play播放指定目录或者 HTTP 地址的 flv 或者 mp4 文件 application video &#123; play /data/video; &#125;&#125;&#125; 此时虽然可以播放视频了，但http还找不到资源，所以还需要定义访问路径。 把光标移到http代码块里，按如下内容修改和增加代码，其实只加了个location，配置文件里#后内容是注释，忽略或删除。 123456789101112131415161718192021222324252627282930313233343536373839404142http &#123; include mime.types; default_type application/octet-stream; sendfile on; tcp_nopush on; keepalive_timeout 65; server &#123; listen 80; server_name localhost; #之前配置的根目录 location / &#123; root /data/www; index index.html index.htm; &#125; #之前配置的图片目录 location /images/ &#123; root /data; &#125; #新增的video目录，即浏览器访问http://ip地址/video时，会进入服务器的/data/video目录 location /video/ &#123; root /data; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; &#125; &#125; 保存并退出，然后重启Nginx服务。 1systemctl restart nginx.service 1.4. 测试视频播放 在服务器的/data/video目录下放入一个mll.mp4视频文件，目录/data/video要建个，根据你的配置的目录来。 浏览器访问http://ip地址/video/mll.mp4 如：http://108.160.134.51/video/mll.mp4 播放成功即可，我服务器速度贼慢，后面换个服务器试试效果。 这时，就可以把视频嵌入到html中播放了，比如： 1&lt;iframe src="http://78.141.206.203/video/ct.mp4" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" autoplay="" width="100%" height="450px"&gt; &lt;/iframe&gt; 效果： (function(){var player = new DPlayer({"container":document.getElementById("dplayer0"),"autoplay":true,"theme":"#FADFA3","video":{"url":"http://server.shirtiny.cn/video/Hold Me Now.mp4"},"danmaku":{"api":"http://dplayer.daoapp.io","token":"tokendemo"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})() 博客视频标签 服务器我换成伦敦的了，现在速度好些了，有的时间段比较卡。 Vultr测ping、服务器数据迁移备份 2. 直播这里搭建一个简单的直播体系，实际要复杂的多。 直播应该有推流端、服务器处理端、和接收端。 2.1. 服务器端配置之前配过视频播放了，这里也用Nginx-Rtmp模块，配置一下nginx就行了。 还是打开/usr/local/nginx/conf目录下的nginx.conf配置文件 1vi /usr/local/nginx/conf/nginx.conf 键盘按i编辑，方向键移动光标，编辑完按 ” :wq “ 保存退出 编辑内容： rtmp代码块 123456789101112131415161718192021222324252627282930rtmp&#123; server&#123; #端口号，要记住 listen 2019; chunk_size 4096; application video &#123; play /data/video; &#125; #新增live应用，名字可自定。live on，开启直播，一对多广播 application live &#123; live on; &#125; #hls，暂时用不到，可以不写 application hls_alic&#123; live on; hls on; hls_path /tmp/hls; &#125;&#125;&#125; http代码块 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354http &#123; include mime.types; default_type application/octet-stream; sendfile on; tcp_nopush on; keepalive_timeout 65; server &#123; listen 80; server_name localhost; location / &#123; root /data/www; index index.html index.htm; &#125; location /images/ &#123; root /data; &#125; location /video/ &#123; root /data; &#125; #新增，访问http://ip/stat时，为当前 HTTP location 设置 RTMP statistics 处理程序。RTMP statistics 是一个静态的 XML 文档。可以使用 rtmp_stat_stylesheet 指令在浏览器中作为 XHTML 页面查看这个文档。添加 XML 样式表引用到 statistics XML 使其可以在浏览器中可视。 location /stat &#123; rtmp_stat all; rtmp_stat_stylesheet stat.xsl; &#125; #新增，能直接访问stat.xsl文件，上面的一块，就是能在浏览器看到rtmp的状态信息 location /stat.xsl &#123; root /usr/local/nginx-rtmp-module-1.2.1; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; &#125; &#125; 重启Nginx服务。 1systemctl restart nginx.service 顺便让防火墙开放你配置的端口，比如这里我配置的2019端口： 1234#添加2019端口配置防火墙firewall-cmd --zone=public --add-port=2019/tcp --permanent#重新加载firewall-cmd --reload 浏览器访问http://你的服务器Ip/stat，如http://108.160.134.51/stat，若出现以下页面，则服务器配置成功。 2.2. 推流端推流可以用FFmpeg，功能强大，使用命令行进行操作，可以在服务器上使用，就是参数比较多，对新手不友好。 还可以用OBS，有windows版本，是大家常用的直播工具了。 OBS 先说下Obs，这个软件比较常见。在设置里面，左侧菜单选输出，输出模式选高级，点录像，选择输出到URL URL的格式是：rtmp://你的服务器ip:端口号/服务器配置的应用名/自定义个名字，容器格式最好选flv，因为体积会小点，其他看自己情况选。 FFmpeg FFmpeg，这个可以装在windows本机上，也可以装在服务器上，使用方式是命令行，下面说一下服务器上怎么装。windows同理，无所谓，可以用其他软件。 【FFmpeg使用示例：】ffmpeg -i /data/video/am.mkv -vcodec h264 -s 1920*1080 /data/video/am.mp4 我的服务器系统：CentOs 7，安装流程： 先安装环境支持，EPEL Release 12sudo yum install -y epel-release rpm#若出现缺少Code提示，执行：sudo rpm --import /etc/pki/rpm-gpg/RPM-GPG-KEY-EPEL-7 安装Nux-Dextop 12sudo rpm --import http://li.nux.ro/download/nux/RPM-GPG-KEY-nux.rosudo rpm -Uvh http://li.nux.ro/download/nux/dextop/el7/x86_64/nux-dextop-release-0-1.el7.nux.noarch.rpm 正式安装FFmpeg 123sudo yum install -y ffmpeg#检查是否安装成功ffmpeg -version 使用 这里使用服务器上的视频/data/video/mll.mp4，模拟推流。 推流到rtmp://localhost:2019/live/test，本地2019端口下的live应用，当然也可以推到远处的服务器，后面的test是自定义的名字。 1ffmpeg -re -i /data/video/mll.mp4 -c copy -f flv rtmp://localhost:2019/live/test 可以根据网速自定义码率： -b:v 3000k 意为视频码率3000k -b:a 320k 指音频 1ffmpeg -re -i /data/video/mllo.mp4 -c copy -b:v 3000k -b:a 320k -f flv rtmp://localhost:2019/live/test 更多使用参考：ffmpeg基础使用 推流后，我们需要一个接收端才能看到推流的效果。 2.3. 接收端（拉流端）这里我用的JWPlayer 解压JWPlayer，新建个html，与jwPlayer文件夹同级目录。 Html内容如下： 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt; &lt;html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"&gt; &lt;head&gt; &lt;meta http-equiv="content-type" content="text/html; charset=utf-8" /&gt; &lt;title&gt;live-player&lt;/title&gt; &lt;style type="text/css"&gt; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;script type='text/javascript' src='jwplayer/jwplayer.js'&gt;&lt;/script&gt; &lt;center&gt; &lt;b&gt;RTMP直播系统&lt;/b&gt; &lt;div id='mediaspace'&gt;This text will be replaced&lt;/div&gt; &lt;script type='text/javascript'&gt; // var server = window.location.hostname; // mylive 对应nginx.conf配置项application的名字 // live_stream 对应Adobe Flash Stream Media Live Encoder配置的stream名称 var live_url = 'rtmp://108.160.134.51:2019/live/test'; //链接的服务器流，与推流一致jwplayer('mediaspace').setup(&#123; 'flashplayer': 'jwplayer/jwplayer.flash.swf', 'file': live_url, 'controlbar': 'bottom', 'width': '760', 'height': '428', //autostart: true, //如果打开此标志，在打开网页时会自动播放直播流 &#125;); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 其中live_url应与推流端的推流地址一致，此html可传到服务器上Nginx管理的目录下，直接访问。也可在本地运行。 运行效果如图： 一个简单的直播系统便建好了。 参考文章： 利用RTMP实现直播系统 Nginx+RTMP 搭建视频点播服务器 译·Nginx RTMP模块指令详解 CentOS 7.5下FFmpeg安装、简单使用总结 ffmpeg基础使用 利用nginx搭建RTMP视频点播、直播/回放 ffmpeg+nginx+rtmp+web实现视频直播网站 使用nginx+nginx-rtmp-module+ffmpeg搭建流媒体服务器 Linux&amp;Windows搭建基于nginx的视频点播服务器 Nginx优化静态文件访问]]></content>
      <categories>
        <category>学习经验</category>
      </categories>
      <tags>
        <tag>视频播放</tag>
        <tag>直播</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sftp文件上传、下载]]></title>
    <url>%2F2019%2F08%2F05%2FSftp%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E3%80%81%E4%B8%8B%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[Sftp协议下文件上传、下载使用JSch进行Sftp连接问题产生 我用common-net，ftp连接时使用21端口会超时，后来发现使用Xftp工具用21端口也超时 1Connection timed out: connect 查了下百度，端口问题。 ftp服务用的是20、21端口，客户端添加ftp信息的时候输入的是21端口 ssh服务用的是22端口，应用于远程ssh管理Linux服务器； 然后我换了22端口进行尝试。 12 Could not parse response code.Server Reply: SSH-2.0-OpenSSH_7.4 异常如上，百度了下，于是开始用sftp协议尝试。 参考文章：主要参考，详细参考 问题解决 我制作了一个工具类，以供调用。 maven依赖 12345678&lt;dependency&gt; &lt;groupId&gt;com.jcraft&lt;/groupId&gt; &lt;artifactId&gt;jsch&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.jcraft&lt;/groupId&gt; &lt;artifactId&gt;jzlib&lt;/artifactId&gt; &lt;/dependency&gt; 还有一些依赖，如springMVC的依赖。 简单上传 遇到了很多的问题，像如何简化、如何创建目录、如何检查目录是否存在、认证问题等，在注释里写得很详细。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250package IO_Utils;import com.jcraft.jsch.*;import java.io.*;import java.lang.reflect.Array;import java.util.ArrayList;import java.util.Properties;import java.util.Vector;/** 我的sftp上传工具* */public class ImageSftp &#123; /**方法内属性说明 * private static ChannelSftp Sftp = null; //用户名(由外部传参) private static String ImgServerUsername = "root"; //主机ip(由外部传参) private static String ImgServerIp = "78.141.206.203"; //密码(由外部传参) private static String ImgServerPassword = "123456"; //端口号(由外部传参) private static int ImgServerPort = 22; //上传到的服务器目录(由外部传参) private static String ImgServerDirectory = "/data/images/"; //上传到服务器的文件命名为(由外部传参) private static String ImgServerFileName=""; //要上传的本地文件// private static File clientFile=null; //下载到本地的目录（由外部传参） private static String ClientDirectory = "D:\\aria2\\"; //下载到本地的文件命名为（由外部传参） private static String ClientFileName ="";*/ private Channel channel=null; private Session sshSession=null; private ChannelSftp sftp =null;/** 获取连接对象的方法* */ public ChannelSftp getConnect(String imgServerIp, int imgServerPort,String imgServerUsername,String imgServerPassword) &#123; JSch jsch = new JSch(); try &#123; //用户名、ip、端口号 sshSession = jsch.getSession(imgServerUsername,imgServerIp, imgServerPort); //配置属性 Properties config = new Properties(); config.put("StrictHostKeyChecking","no"); config.put("PreferredAuthentications","password"); sshSession.setConfig(config); //不检查主机严格密钥// sshSession.setConfig("StrictHostKeyChecking", "no"); //关闭gssapi认证，只使用密码认证，减少耗时 //config.put("userauth.gssapi-with-mic", "no");// sshSession.setConfig("PreferredAuthentications","password"); //给密码设值 sshSession.setPassword(imgServerPassword); //设置多少毫秒超时（设了会报错）// sshSession.connect(600);// sshSession.setServerAliveInterval(92000);// 请求时长 System.out.println("正在与服务器建立连接"); //开启sshSession链接// sshSession.connect(); sshSession.connect(5000); //获取sftp通道 channel = sshSession.openChannel("sftp"); channel.connect(); ChannelSftp sftp = (ChannelSftp) channel; System.out.println("已成功建立连接"); return sftp; &#125;catch (JSchException e)&#123; e.printStackTrace(); System.out.println("建立连接失败"); return null; &#125; &#125; /** * 上传方法 * @param sftp 通过getConnect()方法获得的链接对象 * @param inputStream 要上传文件的输入流 * //@param serverDirectory 某类文件存放的目录，必须指明为根目录某处，如：/data/video/，斜杠必须带 * @param finalServerDirectory 上传文件最终所在的目录，=serverDirectory/nextDirectory * @param serverFileName 为上传到服务器后的文件名 * */ public boolean upload(ChannelSftp sftp,InputStream inputStream ,String finalServerDirectory,String serverFileName) throws IOException, SftpException &#123; //连接服务器// ChannelSftp sftp = getConnect(); if (sftp!=null) &#123; //进入要存储的服务器目录// sftp.cd(serverDirectory); SftpATTRS stat=null; //判断文件夹是不是存在，这里要捕获异常，不然会卡住 try &#123; stat = sftp.stat(finalServerDirectory); System.out.println("找到了目标文件（夹）："+stat+"\n\n\n"); &#125;catch (Exception e)&#123; System.out.println("找不到目标目录"); &#125; if (stat!=null)&#123;//stat有返回值，说明文件夹存在 //进入该文件夹 sftp.cd(finalServerDirectory); System.out.println("进入文件夹"); &#125;else &#123; //创建文件夹，然后进入 sftp.mkdir(finalServerDirectory); sftp.cd(finalServerDirectory); System.out.println("自动创建"+finalServerDirectory+"文件夹，并进入"); &#125; //本地文件，存到流，不需要，因为前台会直接收到MultipartFile类型的文件，并且能获得流// File clientFile = new File(filePath);// InputStream fileInputStream = new FileInputStream(clientFile); //上传到服务器后的名字，由外部传参// serverFileName="1.avi"; System.out.println("上传ing"); //获取文件大小（字节） long size = inputStream.available(); //执行上传（断点续传方式） sftp.put(inputStream, serverFileName,new SftpMonitor(size),ChannelSftp.RESUME); System.out.println("上传完毕");//交给单独方法去断开连接// System.out.println("关闭连接"); //断开连接// sftp.disconnect();//// System.out.println("连接是否已关闭"+sftp.isClosed()); return true; &#125;else &#123; return false; &#125; &#125; /** * 关闭连接 * */ public void close() throws Exception&#123; if (sftp!=null)&#123; sftp.quit(); &#125; if (channel!=null)&#123; channel.disconnect(); System.out.println("已关闭通道"); &#125; if (sshSession!=null)&#123; sshSession.disconnect(); System.out.println("已关闭连接"); &#125; &#125; /* * 下载方法 * 未写，因为暂时用不到 * 暂定 * */// public static String download() throws JSchException, SftpException, FileNotFoundException &#123;// ChannelSftp sftp = getConnect();//// clientFileName="123.png";// File clientFile=new File(clientDirectory+clientFileName);// serverDirectory="/data/images/";// serverFileName="123.png";// sftp.get(serverDirectory+serverFileName, new FileOutputStream(clientFile));// return clientDirectory+clientFileName;//// &#125; //测试 public static void main(String[] args) throws Exception &#123; String imgServerIp="78.141.206.203"; int imgServerPort=22; String imgServerUsername="root"; String imgServerPWD="123456"; ImageSftp imageSftp=new ImageSftp(); ChannelSftp connect = imageSftp.getConnect(imgServerIp, imgServerPort, imgServerUsername, imgServerPWD);// String filePath="C:\\Users\\Shirtiny\\Downloads\\masu.jpg";//要上传的文件的路径//现在是你直接给我个输入流 //获取输入流 String filePath="D:\\MY文档\\音乐\\折戸伸治 - 潮鳴り.mp3"; File file=new File(filePath);// long fileSize = file.length();// System.out.println("文件大小"+fileSize); FileInputStream fileInputStream = new FileInputStream(file); String finalServerDirectory="/data/music";//上传到的服务器目录,调用上传方法时，若找不到该目录，则程序自动创建。代表文件最终存放的目录 String serverFileName="潮鸣.mp3";//上传到服务器的文件命名为// Vector ls = connect.ls(finalServerDirectory);// connect.put("D:\\MY文档\\音乐\\折戸伸治 - 潮鳴り.mp3","123.mp3",new SftpMonitor(),ChannelSftp.OVERWRITE); boolean flag = imageSftp.upload(connect, fileInputStream, finalServerDirectory, serverFileName); System.out.println("是否完成："+flag); //关闭连接 connect.quit(); imageSftp.close(); &#125;&#125; 下载方法未写 下载时拒绝访问的问题 实例我现在需要将一个文件（图片为例）上传到服务器，使用sftp协议，需求如下： 点击上传按钮，选择文件后即可上传 能看到上传的进度和速度 能在上传成功、异常结束时得到反馈 要求在上传后，程序自动显示该图片 图片需要按照一定分类去存储，以方便管理，减少资源消耗 图片名称不能重复，并且图片能正确显示 全程支持中文 支持断点续传 首先，进度监控、断点续传很显然我们目前的这个工具类还不能满足我们的需求，它还需要两个功能： 1.实时监控，这样我们才能知道上传的速度、进度 2.断点续传，值得高兴的是，Jsch为我们提供了这个功能。 1. 实时监控SftpProgressMonitor Jsch提供了一个SftpProgressMonitor接口，包括了初始化时执行的init()方法、每传输一个数据块就会执行一次的count()方法、以及在传输结束时执行的end()方法。 基于这个接口，我们可以写出一个简单监控类： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package IO_Utils;import com.jcraft.jsch.SftpProgressMonitor;/** * 上传进程监控 * */public class SftpMonitor implements SftpProgressMonitor &#123; private long counted;//初始字节数，已经上传的字节数 private long fileSize;//最终文件大小 private long percent;//进度百分比值 public SftpMonitor() &#123; &#125; public SftpMonitor(long fileSize) &#123; this.fileSize = fileSize; &#125; @Override public void init(int op, String src, String dest, long errfileSize) &#123; System.out.println("初始化完成"+"文件大小为："+fileSize); &#125; @Override public boolean count(long count) &#123;// System.out.println("之前已上传"+counted+"("+percent+"%)"); counted +=count;// if (percent&gt;=this.count/fileSize)&#123;// return true;// &#125; percent= counted*100/fileSize; System.out.println("进度-----已传输："+counted/1024+" kb/"+fileSize/1024+" kb"+"("+percent+"%)"); return true; &#125; @Override public void end() &#123; System.out.println("end结束"); &#125;&#125; 它的使用方式： 123long size = inputStream.available();//通过流获取文件大小 //执行上传 sftp.put(inputStream, serverFileName,new SftpMonitor(size);//在执行put方法时初始化一个监控类 很抱歉，由于时间关系，我不能像以往那样详细说明，Jsch：put方法的重载。 SftpProgressMonitor+TimerTask+Pojo 我们需要获得传输的速度，所以需要有个Timer来帮忙，对此不了解的可查看Timer的使用. 我们可以通过重写TimerTask类的run()方法，来实现我们需要的功能。我写了一个start()方法用于创建timer对象，新建计划任务，stop()方法用于终止计时。run()方法会按照我们设置的计划，每隔一段时间执行一次，用单独的线程来执行。 我把需要的信息封装到一个pojo类里，你也可以不封装。 由此便有了一个新的监控类： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156package Sftp_service;import com.jcraft.jsch.SftpProgressMonitor;import org.springframework.beans.factory.annotation.Autowired;import java.text.DecimalFormat;import java.util.Timer;import java.util.TimerTask;public class mySftpTimerMonitor extends TimerTask implements SftpProgressMonitor &#123; private long fileSize;//文件总大小 private long counted;//已传输数据，单位字节 private long counted_Before=0;//上一秒的已传输数据，单位字节 private long i_ed=0;//已计时间，单位s private Timer timer;//计时器对象 private long timeInterval=2*1000;//时间间隔，单位ms private boolean timerIsStarted;//是否已经开始计时 private DecimalFormat format = new DecimalFormat( &quot;#.##&quot;);//用于转换数据显示格式 private SftpSpeedInfo speedInfo=new SftpSpeedInfo(); public mySftpTimerMonitor() &#123; &#125; mySftpTimerMonitor(long fileSize) &#123; this.fileSize = fileSize; &#125; @Override//监视器方法重写 public boolean count(long count) &#123;//每传输一次数据块，就会执行一次count方法 if (!timerIsStarted)&#123;//只在无计时器时，开启计时器 timerStart();//开始计时 &#125; incrementCounted(count);//执行自增 return true; &#125; //Timertask run @Override//计时器方法重写 public void run() &#123;//计时器控制的方法，每多少时间执行一次，用单独的线程执行。前提是启动计时器 /* *i++; *System.out.println(counted+&quot;已用时间&quot;+this.i+&quot;s&quot;); *可以这样。不过可能是考虑到多线程的原因应该这样做： * */ //这样取值更好，其他线程需要等待这个线程取完值，才能去取值 long i1 =getI_ed();//这样就有个新问题，如何使i自增，直接在run内i++是不行的，因为getI()的值没有变 long i2 = incrementI_ed(i1);//新建个方法，用来使秒数自增一次，自憎后的值为i2 long counted_latest=getCounted();//同理拿到当前的，已传输数据量counted的值 long counted_before = getCounted_Before();//拿到上一次的已传数据量 setCounted_Before(counted_latest);//把这次的已传数据量存起来 double speed=(double)(counted_latest-counted_before)/(1024*(timeInterval/1000));//计算传输速度，单位kb/s，speed=当前已传输量-上次的已传输量/(1024*时间间隔/1000) double percent=(double)counted_latest/(double)fileSize; speedInfo.setPercent(format.format(percent*100)+&quot;%&quot;);//百分比 speedInfo.setSpeed(format.format(speed)+&quot;kb/s&quot;);//速度 speedInfo.setCounted(format.format((double)counted/1024)+&quot;kb&quot;);//已传输量 speedInfo.setTimed(i2);//用时 s System.out.println(speedInfo); &#125; private void timerStart()&#123;//自定义的计时器方法，启动计时器 if (timer!=null)&#123; timer.cancel();//终止此计时器，丢弃所有当前已安排的任务。 timer.purge();//从此计时器的任务队列中移除所有已取消的任务。 &#125;else &#123; timer=new Timer();// 这个方法是调度一个task，在delay（ms）后开始调度，每次调度完后，最少等待period（ms）后才开始调度 timer.schedule(this,1000,timeInterval); timerIsStarted=true; System.out.println(&quot;Timer is started,计时器启动完成&quot;); &#125; &#125; public void stop()&#123;//自定义的计时器方法，停止计时器 if (timer != null) &#123; timer.cancel(); timer.purge(); timer = null; timerIsStarted=false; &#125; System.out.println(&quot;stop timer,停止计时&quot;); &#125; @Override//监视器方法重写 public void init(int i, String s, String s1, long l) &#123; speedInfo.setFileSize(format.format((double)this.fileSize/1024)+&quot;kb&quot;);//文件大小 &#125; @Override//监视器方法重写 public void end() &#123;//传输结束 stop();//停止计时器，并清空数据 &#125; //使用synchronized关键字，线程排队调用，即线程同步 public synchronized long getFileSize() &#123; return fileSize; &#125; private synchronized long getCounted_Before() &#123;//取出上一秒的数据量 return counted_Before; &#125; private synchronized void setCounted_Before(long counted_latest) &#123;//把这一秒的已传输数据量记录给counted_Before，为下一秒服务 this.counted_Before = counted_latest; &#125; private synchronized long getI_ed() &#123;//上一秒i的值，已计秒数 return i_ed; &#125; private synchronized long getCounted() &#123;//此次已传数据量的值 return counted; &#125; private synchronized void incrementCounted(long count)&#123;//已传数据量自增方法 counted=counted+count; &#125; // private synchronized long incrementI_ed(long i1)&#123;//已计秒数 自增方法 i_ed=i1+(timeInterval/1000);//自增一次，自增值为间隔时间（s） return i_ed; &#125;&#125; 2.断点续传好在Jsch提供了这个功能，我们不必再费脑筋。我们只需要在执行put()时，把mode的值改为ChannelSftp.RESUME即可。 12 long size = inputStream.available();sftp.put(inputStream, serverFileName,new mySftpTimerMonitor(size),ChannelSftp.RESUME); OVERWRITE是覆盖，APPEND是扩展。 其次，文件夹分类、文件名随机直接看代码即可，这是service层： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package com.SH.Service.ServiceImpl;import ID_Utils.ID_Imghelper;import com.SH.Service.IimgService;import Sftp_service.ImageSftp;import com.jcraft.jsch.ChannelSftp;import com.jcraft.jsch.SftpException;import org.springframework.beans.factory.annotation.Value;import org.springframework.stereotype.Service;import java.io.IOException;import java.io.InputStream;import java.text.SimpleDateFormat;import java.util.Date;@Servicepublic class imgServiceImpl implements IimgService &#123; @Value("$&#123;ImgServerIp&#125;") private String ImgServerIp;//图片服务器ip @Value("$&#123;ImgServerPort&#125;") private int ImgServerPort;//端口号 @Value("$&#123;ImgServerUsername&#125;") private String ImgServerUsername;//用户名 @Value("$&#123;ImgServerPassword&#125;") private String ImgServerPassword;//密码 @Value("$&#123;ImgServerDirectory&#125;") private String ImgServerDirectory;//存储路径 @Override public boolean Imgupload(InputStream inputStream,String suffix) throws Exception &#123; boolean flag; ImageSftp imageSftp=new ImageSftp(); String fileName= ID_Imghelper.getImgID()+suffix; ChannelSftp connect = imageSftp.getConnect(ImgServerIp, ImgServerPort, ImgServerUsername, ImgServerPassword); //根据时间创建一个字符串作为文件夹的名字，方便管理 String nextDirectory = new SimpleDateFormat("yyyy-MM-dd").format(new Date()); //最终文件存放的目录名 String finalServerDirectory=ImgServerDirectory + "/" + nextDirectory; try &#123; flag= imageSftp.upload(connect,inputStream,finalServerDirectory,fileName); System.out.println("上传返回值："+flag); &#125; catch (IOException e) &#123; e.printStackTrace(); return false; &#125; catch (SftpException e) &#123; return false; &#125; imageSftp.close(); return flag; &#125;&#125; 其中用imageSftp.properties存储服务器信息，使用@Value注解获取配置文件信息。 spring配置： 12345678&lt;bean id="dbproperties" class="org.springframework.beans.factory.config.PreferencesPlaceholderConfigurer"&gt; &lt;property name="locations"&gt; &lt;array&gt; &lt;!--数据库配置文件 --&gt; &lt;value&gt;classpath:db.properties&lt;/value&gt; &lt;!--图片服务器配置文件 --&gt; &lt;value&gt;classpath:imageSftp.properties&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;/bean&gt; imageSftp.properties： 12345ImgServerIp=78.141.206.203ImgServerPort=22ImgServerUsername=rootImgServerPassword=123456ImgServerDirectory=/data/images ID_Imghelper，根据时间随机生成图片Id（文件名）的工具类： 12345678910111213141516171819202122232425262728293031package ID_Utils;import java.util.Random;public class ID_Imghelper &#123; public static String getImgID()&#123; long timeMillis = System.currentTimeMillis(); Random random = new Random(); int randomInt = random.nextInt(9999); //%X 获得数字，把它转为16进制，大写字母 //%04X 增加的04，意思是，转化后的字符串占4个字符，不够用0填充 String imgID=timeMillis+String.format("%04X",randomInt); /*其他转化： * %x - 接受一个数字并将其转化为十六进制数格式, 使用小写字母 * %d, %i - 接受一个数字并将其转化为有符号的整数格式 * %s - 接受一个字符串并按照给定的参数格式化该字符串 * %e - 接受一个数字并将其转化为科学记数法格式, 使用小写字母e */ return imgID; &#125; public static void main(String[] args) &#123; String imgID = ID_Imghelper.getImgID(); System.out.println(imgID); &#125;&#125; 最后，图片回显、结果反馈、中文支持等图片回显只需要把服务器上的文件地址拼接出来即可。 这里给个参考，Controller： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.SH.Controller;import ...@Controllerpublic class testController &#123; @Autowired private IimgService imgService; @RequestMapping(value = "/upload",produces = "text/plain;charset=UTF-8") //produces属性，设置响应格式 @ResponseBody public String upload(MultipartFile file,Map&lt;String,Object&gt; map) throws Exception &#123; InputStream inputStream = file.getInputStream(); System.out.println("文件大小"+file.getSize()); String originalFilename = file.getOriginalFilename(); //截取字符串substring(start,stop)，从下标为start值的位置（第start个字符）开始截取,省略stop会截取start以后得全部字符串 //注意stop值为要截取到字符的对应下标+1，如字符串123，下标为012，从如要截取出字符串12，比喻成区间（下标）为[0,1)，写法为substring(0,2) //lastIndexOf(".")字符串倒数第一个.的下标 String suffix = originalFilename.substring(originalFilename.lastIndexOf(".")); System.out.println(originalFilename); System.out.println(suffix); System.out.println((file.getSize()/1024.00)+"kb"); boolean flag = imgService.Imgupload(inputStream, suffix); //json转换对象 ObjectMapper MAPPER=new ObjectMapper(); if (flag)&#123; map.put("上传成功",flag); //把对象转换为json格式字符串 return MAPPER.writeValueAsString(map); &#125;else &#123; map.put("上传失败",flag); return MAPPER.writeValueAsString(map); &#125; &#125;&#125; 参考文章： https://blog.csdn.net/weixin_36910300/article/details/80532868 https://blog.csdn.net/qq_33390789/article/details/78614466 https://www.cnblogs.com/longyg/archive/2012/06/25/2556576.html https://www.cnblogs.com/ssslinppp/p/6248763.html https://blog.csdn.net/chaogewudi1/article/details/81629183 https://www.cnblogs.com/awkflf11/articles/5179156.html https://www.cnblogs.com/longyg/archive/2012/06/25/2556576.html https://blog.csdn.net/ecjtuxuan/article/details/2093757 https://blog.csdn.net/hl_java/article/details/79035237 https://blog.csdn.net/zjy15203167987/article/details/82531772 https://www.jb51.net/article/135720.htm]]></content>
      <categories>
        <category>学习经验</category>
      </categories>
      <tags>
        <tag>ftp</tag>
        <tag>上传下载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭梯子访问墙外网站]]></title>
    <url>%2F2019%2F08%2F04%2F%E6%90%AD%E6%A2%AF%E5%AD%90%E8%AE%BF%E9%97%AE%E5%A2%99%E5%A4%96%E7%BD%91%E7%AB%99%2F</url>
    <content type="text"><![CDATA[翻墙搭梯子首先你需要一个境外服务器、远程可以用Xshell 6，不熟的可以看站内linux的教程。 安卓客户端： Shadowsocks 参考文章：半醉人间、polarxiong 命令列表： 123#这里所有安装遇到选项一律输y，回车#安装python setuptoolsyum install python-setuptools 12#下载pip压缩包wget https://pypi.python.org/packages/source/p/pip/pip-1.3.1.tar.gz --no-check-certificate 123456789101112#下载完后，解压它tar -xzvf pip-1.3.1.tar.gz#进入解压出的文件夹cd pip-1.3.1#安装pythonpython setup.py install#安装shadowsockspip install shadowsocks#创建shadowsocks文件夹mkdir /etc/shadowsocks#创建并编辑shadowsocks配置文件vi /etc/shadowsocks/config.json 进入config.json文件后按I进入Insert模式，可以进行编辑。 复制粘贴以下内容，注意要填一些东西。 12345678910&#123; "server":"你的服务器的ip地址", "port_password": &#123; "8888": "123456", "8889": "123456" &#125;, "timeout":600, "method":"aes-256-cfb", "fast_open": false&#125; 这里服务器的ip地址我是设为0.0.0.0，方便快照换服务器，然后按Esc、:wq（输入冒号wq，意为保存并退出） 这里是设置服务器端的Shadowsocks，后面需要用到上面你填入的信息，对应为： 主要信息： 服务器ip：你的服务器的ip地址 配置端口：8888、8889 密码都为：123456 加密方式：aes-256-cfb 123#开启服务ssserver -c /etc/shadowsocks/config.json -d start#关闭后面改为stop 12#创建并编辑shadowsocks.service，这里是要配置开机自启动vi /etc/systemd/system/shadowsocks.service 与刚刚一样，进入了这个文件，按i可以进行编辑，把以下内容复制到里面： 123456789101112131415161718[Unit]Description=ShadowsocksAfter=network.target[Service]Type=forkingPIDFile=/run/shadowsocks/server.pidPermissionsStartOnly=trueExecStartPre=/bin/mkdir -p /run/shadowsocksExecStartPre=/bin/chown root:root /run/shadowsocksExecStart=/usr/bin/ssserver --pid-file /var/run/shadowsocks/server.pid -c /etc/shadowsocks/config.json -d startRestart=on-abortUser=rootGroup=rootUMask=0027[Install]WantedBy=multi-user.target esc，:wq 保存退出后，再输入以下命令： 1234567891011#权限chmod 755 /etc/systemd/system/shadowsocks.service#启动、启用systemctl start shadowsockssystemctl enable shadowsocks#配置防火墙开放端口firewall-cmd --zone=public --add-port=8888/tcp --permanentfirewall-cmd --zone=public --add-port=8889/tcp --permanentfirewall-cmd --reload 然后在手机上安装Shadowsocks，填入上面对应的主要信息（服务器ip、端口、密码、加密方式），就可以使用代理了，若握手成功，此时谷歌、Youtube等网站都可以访问了。 填好后，点下面的纸飞机进行连接。]]></content>
      <categories>
        <category>闲谈</category>
      </categories>
      <tags>
        <tag>vpn</tag>
        <tag>梯子</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[远程连接Linux搭建环境]]></title>
    <url>%2F2019%2F08%2F03%2F%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5Linux%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[远程连接、Linux环境搭建1. 安装工具环境准备： 各种安装包：Xshell Plus 6|Xshell 6、Xftp 5、linux版本的jdk、Linux版本的MySQL、Linux版本的Nginx 现在下载jdk需要登录Oracle：Oracle账号分享 我当时用的账号 用户名：nicabeta@email-wizard.com 密码：MQEemoh3pOsRAn2c4tjh 注册机：NetSarang_AIO_7in1_Keygen_v1.4_DFoX_URET 百度网盘（可能会失效）： Xshell Plus 6 【j5r8】 Xftp 5 【d3jq】 注册机 【6zcp】 RDM 【2m91】 Nginx-Linux 【xnno】 jdk-Linux 【bph9】 开始安装 Xshell Plus 6 或 Xshell 6 运行注册机，选择你安装的软件,点击Fix Host+Register，然后点击Generate，然后复制生成的序列号 输入上一步获得的序列号，用户名和公司名称随意，选择路径后安装即可。 Xftp同上： ​ 点下一步，安装即可。 2. 更换服务器的JDK2.1. 拿到服务器ip买的服务器会直接给你ip的，这里我用的虚拟机，桥接模式下与我本机的ip应该是一样的。 点左上角Applications，点Favorites下的 Terminal： 在弹出的命令行窗口，输入： 12ifconfig#获取ip配置信息，windows下命令是ipconfig 回车，即可看到ip信息，复制ens33里的inet后的ip地址： 2.2. 使用Xshell建立连接打开Xshell 6，新建会话，名称随意，主机是刚刚的ip地址： 点击连接，在提示框输入服务器需要的用户名密码，都正确的话会连接成功，有时候第一次连接会报错，再连一次就好了。连接成功会显示： 2.3. 卸载open JDK1.Xshell输入： 1java -version 可看到当前java版本： 2.Xshell输入： 12rpm -qa | grep jdk#抓取jdk 3.Xshell输入： 123rpm -e --nodeps #加要删除对象的完整名称（上面抓取时显示了），需要root身份，这里是：rpm -e --nodeps java-1.8.0-openjdk-1.8.0.181-7.b13.el7.x86_64rpm -e --nodeps java-1.8.0-openjdk-headless-1.8.0.181-7.b13.el7.x86_64 不报错，并且输入java -version提示找不到文件，即卸载成功： 2.4. 安装准备的JDK1.Xshell输入： 12pwd#获取当前所在的目录（文件夹）路径 此时在/root目录下。 2.Xshell输入： 123456cd /usr/local#进入指定目录，可用pwd确认当前所在的目录mkdir java#在当前目录 创建java文件夹cd java#进入java文件夹内，可用pwd确认当前所在的目录 点击帮助正下方的绿色按钮，打开Xftp，右边一般会自动定位到服务器的当前目录，左边是本机电脑，把下载好的jdk拖到右边就行了，注意目录： 3.Xshell输入 123456789101112131415ls#列出当前目录的文件名称ll#列出当前目录文件的详细信息tar -zxvf 文件名#解压tar包压缩文件，此处为：tar -zxvf jdk-8u221-linux-x64.tar.gzls#列出当前目录的文件名称cd jdk1.8.0_221#进入jdk解压后的文件夹ls#列出当前目录的文件名称 4.Xshell输入 12vim /etc/profile#编辑指定的文件，这里是配置环境变量 5.键盘按I键，进入Insert编辑，按方向键把光标移到最下方： 输入（##是注释）： 1234##jdk1.8export JAVA_HOME=/usr/local/java/jdk1.8.0_221export PATH=$JAVA_HOME/bin:$PATHexport CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar 键盘按esc，输入冒号wq（意为保存并退出），回车。 此处输入： 12:wq#保存并退出 扩展知识： 12:q!#不保存强制退出s 6.Xshell输入： 123456cat /etc/profile#将指定文件显示出来，这里是看一下刚刚的文件是否已保存source /etc/profile#使刚刚的配置文件生效java -version#验证jdk 正常的结果： 到此JDK安装配置结束。 3. 安装MySQL环境准备 卸载mariadb 12rpm -qa | grep mariadbrpm -e maria.... 安装mysql yum安装方式： 123456#下载rpm文件wget https://dev.mysql.com/get/mysql80-community-release-el7-3.noarch.rpm#yum安装yum -y install mysql80-community-release-el7-3.noarch.rpm#安装mysqlyum -y install mysql-community-server 官网下载mysql-8.0.17-1.el7.x86_64.rpm-bundle.tar安装包的方式 解压安装包，会得到common、server、client等rpm文件，依次安装即可。 安装common 1234#rpm -ivh rpm文件名 --nodeps --force#--nodeps就是安装时不检查依赖关系#--force就是强制安装rpm -ivh mysql-c...-common... --nodeps --force 同样的命令再去装libs、client、server 配置mysql 检查数据包 1rpm -qa | grep mysql 初始化 1mysqld --initialize 防火墙授权 123456#赋予myslq操作文件夹的权限chown mysql:mysql /var/lib/mysql -R;#启动mysql服务systemctl start mysqld.service;#设置开启启动systemctl enable mysqld; 查看密码 1cat /var/log/mysqld.log | grep password 登录 1mysql -u root -p 修改密码 1ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY '123456'; 退出 1exit 再用自己密码登录就行了 开启远程访问，新建用户然后授权 1234567#创建新用户，地址是任意地址#@后面可以填ipcreate USER 'sh'@'%' IDENTIFIED WITH mysql_native_password BY '123456';#授权grant all privileges on *.* to 'root'@'%' with grant option;flush privileges; 开放防火墙端口 12345678#查看防火墙状态systemctl status firewalld#开启systemctl start firewalld#防火墙开放xxxx端口，xxx是端口号firewall-cmd --zone=public --add-port=xxx/tcp --permanent#重启防火墙firewall-cmd --reload 注意，linux严格区分大小写，查询语句也是如此，配置mysql忽略大小写的方法： 修改mysql配置文件 123vim /etc/my.cnf[mysqld]lower_case_table_names=1 若没找到该文件，用which看下mysql的安装位置 1which mysqld 然后用得到的路径： 1路径 --verbose --help |grep -A 1 'Default options' 会显示几个默认的文件位置，都没有的话，在这几个位置建个cnf文件就行了： 12#参考的cnf文件：安装路径/mysql/support-files/my-default.cnf mysql日志位置： 123cat /var/log/mysqld.log#G跳到最后一行vim /var/log/mysqld.log 4. 安装Redis非关系型数据库，Redis是一个开源的使用C语言编写(3万多行代码)，支持网络，可基于内存亦可持久化的日志型，Key-Value数据库，并提供多种语言的API。 持久化 Redis是内存数据库，数据都是存储在内存中，为了避免进程退出导致数据的永久丢失，需要定期将Redis中的数据以某种形式（数据或命令）从内存保存到硬盘。 RDB模式，默认启用，每隔一段时间，达到指定操作次数后，将数据存为文件。 AOF模式，默认不用，根据设置的条件，每秒或每次操作或由系统决定，将数据经历的指令保存为文件。 AOF重写，Redis会根据AOF的体积进行AOF重写，重写是将指令重新执行，然后把等价于最后结果的指令替换原来的一堆指令。 持久化文件损坏修复，会把文件损坏的部分切掉，会牺牲部分数据，相当于截肢，之后数据会有所偏差。 两种模式都启用时，以AOF为准。 通常，Redis将数据存储于内存中，或被配置为使用虚拟内存。通过两种方式可以实现数据持久化：使用快照（snapshot）的方式，将内存中的数据不断写入磁盘，或使用类似MySQL的binlog日志（aof但并不用于主从同步）方式，记录每次更新的日志。前者性能较高，但是可能会引起一定程度的数据丢失；后者相反。 数据类型 作为Key-value型存储系统数据库，Redis提供了键（Key）和值（value）映射关系。但是，除了常规的数值或字符串，Redis的键值还可以是以下形式之一，下面为最为常用的数据类型： 123456&gt; String 字符串&gt; Hash 哈希表&gt; List 列表&gt; Set 集合&gt; Sorted set 有序集合&gt; 4.1. 准备安装包或wget下载离线下载 或 服务器上选个存放安装包的目录，用wget下载 1234#进入存放目录cd /usr/local#wget加下载地址wget http://download.redis.io/releases/redis-5.0.5.tar.gz 4.2. 准备安装环境安装需要gcc编译，所以安装前需要看一下gcc的版本 12#查看gcc版本gcc -v 确认gcc版本是不是4.2以上，若没有gcc或版本不够，需要再安装gcc 12#安装gccyum install gcc 装好后确认一下gcc版本。 4.3. Redis安装解压下载好的Redis的压缩包 1234#解压tar -zxvf redis-5.0.5.tar.gz#进入解压出的文件夹cd redis-5.0.5 尝试安装测试（必要） 1234#若报错，去百度对应提示make MALLOC=libc#测试安装，不管有没有错误，都会回滚。出错的话，根据错误提示去百度解决make test 我这里错误是提示需要tcl支持，所以要安装tcl 1234#安装tclyum install tcl#继续make测试，直到无错误提示make test 正式安装 12cd srcmake install 无错，即成功。 4.4. 运行Redis前台运行在Redis安装目录下 12#前台运行redis./redis-server 前台运行的话，不能关闭那个界面，关闭的话就会关闭服务。 后台运行配置服务 应该使用后台运行的方式，需要进行如下配置： ①修改redis配置文件为后台模式启动 12#修改redis配置文件vi /usr/local/redis-5.0.5/redis.conf 按i进入编辑模式，将daemonize no改为daemonize yes，esc，:wq保存退出。 daemonize意思为：是否守护线程启动（是否后台模式启动） 修改ip绑定，将bind 127.0.0.1 修改为bind 0.0.0.0 （4个0），表示所有ip都可以连接。注意别改错了，是没有#号的bind 127.0.0.1。（这个时指定redis的客户端地址，安全考虑） 123#bind 127.0.0.1#-&gt;bind 0.0.0.0 设置密码（可选） esc退出编辑模式，输入/require（搜索require），把#号去掉，然后requirepass后的值就是你的密码 1requirepass password ②将redis配置文件redis.conf复制到/etc/redis目录下，并改名为6379.conf 12345678cd /etcmkdir rediscd redis#把目标文件复制到当前目录cp /usr/local/redis-5.0.5/redis.conf ./#把目标文件移动到本目录，并重命名为mv redis.conf 6379.conf#tips：把目标文件覆盖复制到当前目录并改名为（cp -f 目标目录 6379.conf） ③复制启动脚本到/etc/rc.d/init.d/，并改名为redisd 启动脚本为：/usr/local/redis-5.0.5/utils/redis_init_script 123456#把目标文件复制到指定目录下，并命名为redisdcp /usr/local/redis-5.0.5/utils/redis_init_script /etc/rc.d/init.d/redisd#或手动改名：#cd /etc/rc.d/init.d/#ls#mv redis_init_script redisd ④修改刚刚重命名的redisd文件，让它成为服务 12cd /etc/rc.d/init.d/vim redisd 按i进入编辑模式 老版本需要在脚本文件的第一行后，加入一行（包括#号）： 1#chkconfig:2345 80 90 新版不用加。 然后，修改EXEC、CLIEXEC的路径： 1234567#原内容EXEC=/usr/local/bin/redis-serverCLIEXEC=/usr/local/bin/redis-cli#修改后的内容EXEC=/usr/local/redis-5.0.5/src/redis-serverCLIEXEC=/usr/local/redis-5.0.5/src/redis-cli 最后，找到case**in什么的那一块代码，在$EXEC $CONF 后面加上 &amp;（空格+&amp;符号+空格） 启动Redis 12345#添加开机启动chkconfig redisd on#防火墙开放6379端口firewall-cmd --zone=public --add-port=6379/tcp --permanentfirewall-cmd --reload 123456789101112#运行redisservice redisd start#停止redisservice redisd stop#修改redis配置文件vi /etc/redis/6379.conf#查看运行状态ps -ef | grep redis#强行kill进程，14399是目标进程的idkill -9 14399 #移除pid文件rm -f /var/run/redis_6379.pid 4.5. Redis使用1234cd /usr/local/redis-5.0.5/src/ls#redis客户端redis-cli redis的一些命令，自行百度 123456#设置set abc 123#取值get abc#显示全部keykeys * Redis命令表 RDM 提取码：【2m91】 5. 安装Nginx5.1. 准备安装包把安装文件传到服务器。 或者使用weget方式在服务器内下载也行： 123cd /usr/localweget http://nginx.org/download/nginx-1.17.1.tar.gz#下载安装包到usr/local 解压 1234tar -zxvf nginx-1.17.1.tar.gz#解压，z表示gzip压缩格式，x表示提取文件，v表示显示解压过程，f指定文件ll#显示当前文件夹的文件 5.2. 准备安装环境安装前必须安装nginx所需的依赖库。 安装依赖，仔细执行： 12345678yum install gcc-c++yum install pcreyum install pcre-develyum install zlibyum install zlib-develyum install opensslyum install openssl-devel#遇到选项输y即可 5.3. Nginx安装1234567ll#显示当前文件夹的文件cd nginx-1.17.1ll#显示当前文件夹的文件./configure#执行configure文件，输一半名字按tab会自动补全文件名的 执行make安装 12345678910make install#注意在nginx-1.17.1目录下执行#它会将nginx安装到/usr/local/nginx目录下cd ..#返回上一目录ll#显示当前文件夹的文件cd nginxpwd#显示当前所在的目录 配置Nginx开机启动 1234cd /lib/systemd/systemvim nginx.service#创建nginx.service文件并编辑，也可以用touch命令创建。#vim不行就vi 按I，添加如下内容： 12345678910111213[Unit]Description=nginxAfter=network.target[Service]Type=forkingExecStart=/usr/local/nginx/sbin/nginxExecReload=/usr/local/nginx/sbin/nginx reloadExecStop=/usr/local/nginx/sbin/nginx quitPrivateTmp=true[Install]WantedBy=multi-user.target esc :wq 保存并退出，用cat检查下刚刚的文件。 接着输入： 12systemctl enable nginx.service#使其开机启动 安装配置，到此就完成了。 5.4. Nginx指令、运行检查12345678systemctl start nginx.service#启动systemctl stop nginx.service#停止systemctl restart nginx.service#重启 启动Nginx，浏览器输入ip，若访问不到： 1234#添加80端口配置防火墙firewall-cmd --zone=public --add-port=1422/tcp --permanent#重新加载firewall-cmd --reload 再去访问即可。 12chmod a+x /usr/local/nginx#访问权限,a+x ==&gt; all user can execute 所有用户可执行 关于路径 nginx根目录是/nginx/html文件夹。我的是：/usr/local/nginx/html 比如在html文件夹下建images文件夹，里面放张图片123.png，那么图片的路径就是：http://ip地址/images/123.png 路径配置 比如在根部吗建立data文件夹，在data下建立www和images两个文件夹： 123456mkdir /datacd /datamkdir wwwcd ..mkdir imagesll 然后打开nginx的配置文件/usr/local/nginx/conf/nginx.conf 注释掉原文http｛｝代码块，或者再其基础上修改成: 123456789101112131415161718http&#123;server &#123; #root的路径实际是nginx文件夹内的相对路径,/是主机根目录 #把访问时的ip地址/，设置为本机根目录下的/data/www文件夹 # 首页设为其文件夹下的index.html或index.htm location / &#123; root /data/www; index index.html index.htm; &#125; #地址栏里"/"后的路径是直接匹配目录/data下的路径 #如访问ip地址/images时,配匹配/data/images #把访问时的ip/images路径，设置为 location /images/ &#123; root /data; &#125;&#125;&#125; 关于SSL证书 6.Tomcat&amp;Maven热部署Tomcat准备 Tomcat的安装与Windows一致，解压相应的tomcat-*.tar.gz文件即可 端口号的修改在conf/server.xml配置文件中改 增加角色和权限，修改conf/tomcat-user.xml： 123&lt;role rolename="manager-gui" /&gt;&lt;role rolename="manager-script" /&gt;&lt;user username="tomcat" password="tomcat" roles="manager-gui, manager-script"/&gt; 然后在tomcat-manager界面，deploy你的war包即可，热部署无需重启服务器。 Maven插件配置 增加Pom.xml中的tomcat7插件 123456789101112&lt;!-- 配置Tomcat插件 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;port&gt;8081&lt;/port&gt; &lt;path&gt;/&lt;/path&gt; &lt;!--对应tomcat中的ROOT文件夹--&gt; &lt;url&gt;http://yourIpAndPort/manager/text&lt;/url&gt; &lt;!--其中/manager/text是固定写法--&gt; &lt;username&gt;tomcat&lt;/username&gt; &lt;!--你的tomcat角色用户名和密码--&gt; &lt;password&gt;tomcat&lt;/password&gt; &lt;/configuration&gt; &lt;/plugin&gt; 路径为/时，由于tomcat中ROOT目录已经存在，所以使用tomcat7:redeploy命令，若path为其他值，直接deploy即可，建议先clean，-Dskiptest可以跳过测试阶段，-X输出debug信息。]]></content>
      <categories>
        <category>学习经验</category>
      </categories>
      <tags>
        <tag>开发知识</tag>
        <tag>Linux系统</tag>
        <tag>远程连接</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[虚拟机、Linux系统(CentOs)的安装]]></title>
    <url>%2F2019%2F08%2F03%2F%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%81Linux%E7%B3%BB%E7%BB%9F-CentOs-%E7%9A%84%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[虚拟机、Linux系统环境准备： 虚拟机工具：VMwear安装包【提取码：8k77】 Linux系统：CentOS7镜像 1. 安装虚拟机1.1. 安装VMwear运行VMwear安装包，过程很简单。 1.2. 创建虚拟机 VMwear安装完成后，打开它: 选择创建新的虚拟机，若选典型会自动为新手配置一些东西，这里选自定义： 兼容性问题，VMwear是高版本兼容低版本的，低版本不兼容高版本，这里选当前VMwear的版本就好，我给的资源版本号是12： 下一步，选稍后安装系统： 选择Linux系统，版本是CentOs 64位： 为虚拟机指定名称和位置，我新建了一个目录来存放，方便自己以后查找： 根据自己的实际需求来分配cpu，以后使用中CPU不够的话可以加，这里我选的11： 分配内存，要考虑到本机的空闲内存： 我计算机是8G内存，日常使用中，除开系统占用，开了几个浏览器、视频，只剩余了3G内存。 又考虑到会模拟多台服务器的运行，所以分配内存不能太大，也不能过低。 我选的1G内存，装了半天的系统，不过没关系，后面在设置里可以改的。 选择网络类型，这里选桥接： tips： 桥接：选择桥接模式的话虚拟机和宿主机在网络上就是平级的关系，相当于连接在同一交换机上。 NAT：NAT模式就是虚拟机要联网得先通过宿主机才能和外面进行通信。 仅主机：虚拟机与宿主机直接连起来 I/O控制器类型&amp;和磁盘类型选默认的即可： 由于是第一次使用虚拟机，选择创建新的虚拟磁盘： 磁盘空间分配： 我在VMwear下新建了一个VsFile文件夹，用来保存虚拟磁盘的文件： tips: 磁盘容量暂时分配50G即可后期可以随时增加，不要勾选立即分配所有磁盘，否则虚拟机会将50G直接分配给CentOS，会导致宿主机所剩硬盘容量减少。 勾选将虚拟磁盘拆分成多个文件，这样可以使虚拟机方便用储存设备拷贝复制。 自定义硬件： 移除不需要的硬件，如声卡、打印机。 然后点击完成，即可创建一个虚拟机。 2. 安装Linux系统(CentOs)2.1. 连接光盘右击刚创建的虚拟机，选择设置，选择下载好的CentOS映像，注意勾选启动时链接 2.2. 运行虚拟机虚拟机创建完成后，点开启此虚拟机即可。 2.3. 安装系统 安装向导 启动后会看到以下选项： Install CentOS 7 安装CentOS 7 Test this media &amp; install CentOS 7 测试安装文件并安装CentOS 7 Troubleshooting 修复故障 选择选项：Install CentOS 7，回车。 选择语言English、时间、时区，这个按自己需要选，不再赘述。 在Software selection里面选Server with GUI，然点左上角的done，就行了。 设置主机名与网卡信息 暂时选自动挂载分区（实际开发中需要仔细配置） 点击右下角开始安装，设置密码（用户可不设置），以后用Root登录 等待安装即可。 完毕后会让你点Reboot重启： 重启后，需要同意协议 点finish,到此Linux系统就安装完成了。 关于更多的配置，我找到一个很详细的文章，可以参照。]]></content>
      <categories>
        <category>学习经验</category>
      </categories>
      <tags>
        <tag>开发知识</tag>
        <tag>Linux系统</tag>
        <tag>虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lombok插件]]></title>
    <url>%2F2019%2F08%2F01%2FIdea%E5%A2%9E%E5%8A%A0Lombok%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[为IDE装上Lombok插件Lombok提供了一套注解，可以大量的简化java代码。 Lombok支持Eclipse或Idea，需要先下载zip文件：下载地址 IDEA主要介绍下插件在Idea的使用 下载插件后在IDEA界面，右下角Configure，选Plugins 进入插件界面后，点齿轮设置,选Install Plugin from Disk… 选刚刚下载插件的zip文件 点重启IDEA。 重启后在Setting里设置：勾选Enable annotation processing 最后，在项目中引入Lombok的jar包即可使用@Data等lombok注解 1234567&lt;!-- lombok --&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.10&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; Lombok的文档 Introduction Installation Lombok Annotations @Getter and @Setter @NonNull @ToString @EqualsAndHashCode @Data @Cleanup @Synchronized @SneakyThrows Costs and Benefits What are we missing? Limitations Controversy Summary References 详情： Introduction“Boilerplate” is a term used to describe code that is repeated in many parts of an application with little alteration. One of the most frequently voiced criticisms of the Java language is the volume of this type of code that is found in most projects. This problem is frequently a result of design decisions in various libraries, but is exacerbated by limitations in the language itself. Project Lombok aims to reduce the prevalence of some of the worst offenders by replacing them with a simple set of annotations. While it is not uncommon for annotations to be used to indicate usage, to implement bindings or even to generate code used by frameworks, they are generally not used for the generation of code that is directly utilized by the application. This is partly because doing so would require that the annotations be eagerly processed at development time. Project Lombok does just that. By integrating into the IDE, Project Lombok is able to inject code that is immediately available to the developer. For example, simply adding the @Data annotation to a data class, as below, results in a number of new methods in the IDE: InstallationProject Lombok is available as a single jar file on the project site. It includes the APIs for development as an installer for IDE integration. On most systems, simply double-clicking the jar file will launch the installer. If the system is not configured to correctly launch jar files, it can also be run from the command line as follows: 1java -jar lombok.jar The installer will attempt to detect the location of a supported IDE. If it cannot correctly determine where the IDE is installed, the location can be specified manually. Simply click “Install/Update” and IDE integration is complete. At the time of this article’s writing, only Eclipse and NetBeans are supported. However, the release of the IntelliJ IDEA source code has placed IDEA support as a possibility for future releases, and limited success has already been reported with JDeveloper. The jar file will still need to be included in the classpath of any projects that will use Project Lombok annotations. Maven users can include Lombok as a dependency by adding this to the project pom.xml file: 12345678910111213&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;0.9.2&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;projectlombok.org&lt;/id&gt; &lt;url&gt;http://projectlombok.org/mavenrepo&lt;/url&gt; &lt;/repository&gt;&lt;/repositories&gt; Lombok AnnotationsIt is not uncommon for a typical Java project to devote hundreds of lines of code to the boilerplate required for defining simple data classes. These classes generally contain a number of fields, getters and setters for those fields, as well as equals and hashCode implementations. In the simplest scenarios, Project Lombok can reduce these classes to the required fields and a single @Data annotation. Of course, the simplest scenarios are not necessarily the ones that developers face on a day-to-day basis. For that reason, there are a number of annotations in Project Lombok to allow for more fine grained control over the structure and behavior of a class. @Getter and @SetterThe @Getter and @Setter annotations generate a getter and setter for a field, respectively. The getters generated correctly follow convention for boolean properties, resulting in an isFoo getter method name instead of getFoofor any boolean field foo. It should be noted that if the class to which the annotated field belongs contains a method of the same name as the getter or setter to be generated, regardless of parameter or return types, no corresponding method will be generated. Both the @Getter and @Setter annotations take an optional parameter to specify the access level for the generated method. Lombok annotated code: 12@Getter @Setter private boolean employed = true;@Setter(AccessLevel.PROTECTED) private String name; Equivalent Java source code: 1234567891011121314private boolean employed = true;private String name;public boolean isEmployed() &#123; return employed;&#125;public void setEmployed(final boolean employed) &#123; this.employed = employed;&#125;protected void setName(final String name) &#123; this.name = name;&#125; @NonNullThe @NonNull annotation is used to indicate the need for a fast-fail null check on the corresponding member. When placed on a field for which Lombok is generating a setter method, a null check will be generated that will result in a NullPointerException should a null value be provided. Additionally, if Lombok is generating a constructor for the owning class then the field will be added to the constructor signature and the null check will be included in the generated constructor code. This annotation mirrors @NotNull and @NonNull annotations found in IntelliJ IDEA and FindBugs, among others. Lombok is annotation agnostic with regards to these variations on the theme. If Lombok comes across any member annotated with any annotation of the name @NotNull or @NonNull, it will honor it by generating the appropriate corresponding code. The authors of Project Lombok further comment that, in the event that annotation of this type is added to Java, then the Lombok version will be subject to removal. Lombok annotated code from the class Family: 12@Getter @Setter @NonNullprivate List&lt;Person&gt; members; Equivalent Java source code: 1234567891011121314151617@NonNullprivate List&lt;Person&gt; members;public Family(@NonNull final List&lt;Person&gt; members) &#123; if (members == null) throw new java.lang.NullPointerException(&quot;members&quot;); this.members = members;&#125; @NonNullpublic List&lt;Person&gt; getMembers() &#123; return members;&#125;public void setMembers(@NonNull final List&lt;Person&gt; members) &#123; if (members == null) throw new java.lang.NullPointerException(&quot;members&quot;); this.members = members;&#125; @ToStringThis annotation generates an implementation of the toString method. By default, any non-static fields will be included in the output of the method in name-value pairs. If desired, the inclusion of the property names in the output can be suppressed by setting the annotation parameter includeFieldNames to false. Specific fields can be excluded from the output of the generated method by including their field names in the exclude parameter. Alternatively, the of parameter can be used to list only those fields which are desired in the output. The output of the toString method of a superclass can also be included by setting the callSuper parameter to true. Lombok annotated code: 123456@ToString(callSuper=true,exclude=&quot;someExcludedField&quot;)public class Foo extends Bar &#123; private boolean someBoolean = true; private String someStringField; private float someExcludedField;&#125; Equivalent Java source code: 123456789101112public class Foo extends Bar &#123; private boolean someBoolean = true; private String someStringField; private float someExcludedField; @java.lang.Override public java.lang.String toString() &#123; return &quot;Foo(super=&quot; + super.toString() + &quot;, someBoolean=&quot; + someBoolean + &quot;, someStringField=&quot; + someStringField + &quot;)&quot;; &#125;&#125; @EqualsAndHashCodeThis class level annotation will cause Lombok to generate both equals and hashCode methods, as the two are tied together intrinsically by the hashCode contract. By default, any field in the class that is not static or transient will be considered by both methods. Much like @ToString, the exclude parameter is provided to prevent field from being included in the generated logic. One can also use the of parameter to list only those fields should be considered. Also like @ToString, there is a callSuper parameter for this annotation. Setting it to true will cause equals to verify equality by calling the equals from the superclass before considering fields in the current class. For thehashCode method, it results in the incorporation of the results of the superclass’s hashCode in the calculation of the hash. When setting callSuper to true, be careful to make sure that the equals method in the parent class properly handles instance type checking. If the parent class checks that the class is of a specific type and not merely that the classes of the two objects are the same, this can result in undesired results. If the superclass is using a Lombok generated equals method, this is not an issue. However, other implementations may not handle this situation correctly. Also note that setting callSuper to true cannot be done when the class only extends Object, as it would result in an instance equality check that short-circuits the comparison of fields. This is due to the generated method calling the equals implementation on Object, which returns false if the two instances being compared are not the same instance. As a result, Lombok will generate a compile time error in this situation. Lombok annotated code: 12345678910111213@EqualsAndHashCode(callSuper=true,exclude=&#123;&quot;address&quot;,&quot;city&quot;,&quot;state&quot;,&quot;zip&quot;&#125;)public class Person extends SentientBeing &#123; enum Gender &#123; Male, Female &#125; @NonNull private String name; @NonNull private Gender gender; private String ssn; private String address; private String city; private String state; private String zip;&#125; Equivalent Java source code: 12345678910111213141516171819202122232425262728293031323334353637383940public class Person extends SentientBeing &#123; enum Gender &#123; /*public static final*/ Male /* = new Gender() */, /*public static final*/ Female /* = new Gender() */; &#125; @NonNull private String name; @NonNull private Gender gender; private String ssn; private String address; private String city; private String state; private String zip; @java.lang.Override public boolean equals(final java.lang.Object o) &#123; if (o == this) return true; if (o == null) return false; if (o.getClass() != this.getClass()) return false; if (!super.equals(o)) return false; final Person other = (Person)o; if (this.name == null ? other.name != null : !this.name.equals(other.name)) return false; if (this.gender == null ? other.gender != null : !this.gender.equals(other.gender)) return false; if (this.ssn == null ? other.ssn != null : !this.ssn.equals(other.ssn)) return false; return true; &#125; @java.lang.Override public int hashCode() &#123; final int PRIME = 31; int result = 1; result = result * PRIME + super.hashCode(); result = result * PRIME + (this.name == null ? 0 : this.name.hashCode()); result = result * PRIME + (this.gender == null ? 0 : this.gender.hashCode()); result = result * PRIME + (this.ssn == null ? 0 : this.ssn.hashCode()); return result; &#125;&#125; @DataThe @Data annotation is likely the most frequently used annotation in the Project Lombok toolset. It combines the functionality of @ToString, @EqualsAndHashCode, @Getter and @Setter. Essentially, using @Data on a class is the same as annotating the class with a default @ToString and @EqualsAndHashCode as well as annotating each field with both @Getter and @Setter. Annotation a class with @Data also triggers Lombok’s constructor generation. This adds a public constructor that takes any @NonNull or final fields as parameters. This provides everything needed for a Plain Old Java Object (POJO). While @Data is extremely useful, it does not provide the same granularity of control as the other Lombok annotations. In order to override the default method generation behaviors, annotate the class, field or method with one of the other Lombok annotations and specify the necessary parameter values to achieve the desired effect. @Data does provide a single parameter option that can be used to generate a static factory method. Setting the value of the staticConstructor parameter to the desired method name will cause Lombok to make the generated constructor private and expose a a static factory method of the given name. Lombok annotated code: 123456@Data(staticConstructor=&quot;of&quot;)public class Company &#123; private final Person founder; private String name; private List&lt;Person&gt; employees;&#125; Equivalent Java source code: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class Company &#123; private final Person founder; private String name; private List&lt;Person&gt; employees; private Company(final Person founder) &#123; this.founder = founder; &#125; public static Company of(final Person founder) &#123; return new Company(founder); &#125; public Person getFounder() &#123; return founder; &#125; public String getName() &#123; return name; &#125; public void setName(final String name) &#123; this.name = name; &#125; public List&lt;Person&gt; getEmployees() &#123; return employees; &#125; public void setEmployees(final List&lt;Person&gt; employees) &#123; this.employees = employees; &#125; @java.lang.Override public boolean equals(final java.lang.Object o) &#123; if (o == this) return true; if (o == null) return false; if (o.getClass() != this.getClass()) return false; final Company other = (Company)o; if (this.founder == null ? other.founder != null : !this.founder.equals(other.founder)) return false; if (this.name == null ? other.name != null : !this.name.equals(other.name)) return false; if (this.employees == null ? other.employees != null : !this.employees.equals(other.employees)) return false; return true; &#125; @java.lang.Override public int hashCode() &#123; final int PRIME = 31; int result = 1; result = result * PRIME + (this.founder == null ? 0 : this.founder.hashCode()); result = result * PRIME + (this.name == null ? 0 : this.name.hashCode()); result = result * PRIME + (this.employees == null ? 0 : this.employees.hashCode()); return result; &#125; @java.lang.Override public java.lang.String toString() &#123; return &quot;Company(founder=&quot; + founder + &quot;, name=&quot; + name + &quot;, employees=&quot; + employees + &quot;)&quot;; &#125;&#125; @CleanupThe @Cleanup annotation can be used to ensure that allocated resources are released. When a local variable is annotated with @Cleanup, any subsequent code is wrapped in a try/finally block that guarantees that the cleanup method is called at the end of the current scope. By default @Cleanup assumes that the cleanup method is named “close”, as with input and output streams. However, a different method name can be provided to the annotation’svalue parameter. Only cleanup methods which take no parameters are able to be used with this annotation. There is also a caveat to consider when using the @Cleanup annotation. In the event that an exception is thrown by the cleanup method, it will preempt any exception that was thrown in the method body. This can result in the actual cause of an issue being buried and should be considered when choosing to use Project Lombok’s resource management. Furthermore, with automatic resource management on the horizon in Java 7, this particular annotation is likely to be relatively short-lived. Lombok annotated code: 123456789public void testCleanUp() &#123; try &#123; @Cleanup ByteArrayOutputStream baos = new ByteArrayOutputStream(); baos.write(new byte[] &#123;&apos;Y&apos;,&apos;e&apos;,&apos;s&apos;&#125;); System.out.println(baos.toString()); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; Equivalent Java source code: 12345678910111213public void testCleanUp() &#123; try &#123; ByteArrayOutputStream baos = new ByteArrayOutputStream(); try &#123; baos.write(new byte[]&#123;&apos;Y&apos;, &apos;e&apos;, &apos;s&apos;&#125;); System.out.println(baos.toString()); &#125; finally &#123; baos.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; @SynchronizedUsing the synchronized keyword on a method can result in unfortunate effects, as any developer who has worked on multi-threaded software can attest. The synchronized keyword will lock on the current object (this) in the case of an instance method or on the class object for a static method. This means that there is the potential for code outside of the control of the developer to lock on the same object, resulting in a deadlock. It is generally advisable to instead lock explicitly on a separate object that is dedicated solely to that purpose and not exposed in such a way as to allow unsolicited locking. Project Lombok provides the @Synchronized annotation for that very purpose. Annotating an instance method with @Synchronized will prompt Lombok to generate a private locking field named $lock on which the method will lock prior to executing. Similarly, annotating a static method in the same way will generate a private static object named $LOCK for the static method to use in an identical fashion. A different locking object can be specified by providing a field name to the annotation’s value parameter. When a field name is provided, the developer must define the property as Lombok will not generate it. Lombok annotated code: 123456private DateFormat format = new SimpleDateFormat(&quot;MM-dd-YYYY&quot;);@Synchronizedpublic String synchronizedFormat(Date date) &#123; return format.format(date);&#125; Equivalent Java source code: 12345678private final java.lang.Object $lock = new java.lang.Object[0];private DateFormat format = new SimpleDateFormat(&quot;MM-dd-YYYY&quot;);public String synchronizedFormat(Date date) &#123; synchronized ($lock) &#123; return format.format(date); &#125;&#125; @SneakyThrows@SneakyThrows is probably the Project Lombok annotation with the most detractors, since it is a direct assault on checked exceptions. There is a lot of disagreement with regards to the use of checked exceptions, with a large number of developers holding that they are a failed experiment. These developers will love @SneakyThrows. Those developers on the other side of the checked/unchecked exception fence will most likely view this as hiding potential problems. Throwing IllegalAccessException would normally generate an “Unhandled exception” error if IllegalAccessException, or some parent class, is not listed in a throws clause: When annotated with @SneakyThrows, the error goes away. By default, @SneakyThrows will allow any checked exception to be thrown without declaring in the throws clause. This can be limited to a particular set of exceptions by providing an array of throwable classes ( Class&lt;? extends Throwable&gt;) to the value parameter of the annotation. Lombok annotated code: 1234@SneakyThrowspublic void testSneakyThrows() &#123; throw new IllegalAccessException();&#125; Equivalent Java source code: 1234567public void testSneakyThrows() &#123; try &#123; throw new IllegalAccessException(); &#125; catch (java.lang.Throwable $ex) &#123; throw lombok.Lombok.sneakyThrow($ex); &#125;&#125; A look at the above code and the signature of Lombok.sneakyThrow(Throwable) would lead most to believe that the exception is being wrapped in a RuntimeException and re-thrown, however this is not the case. ThesneakyThrow method will never return normally and will instead throw the provided throwable completely unaltered. Costs and BenefitsAs with any technology choice, there are both positive and negative effects of using Project Lombok. Incorporating Lombok’s annotations in a project can greatly reduce the number of lines of boilerplate code that are either generated in the IDE or written by hand. This results in reduced maintenance overhead, fewer bugs and more readable classes. That is not to say that there are not downsides to using Project Lombok annotations in your project. Project Lombok is largely aimed at filling gaps in the Java language. As such, there is the possibility that changes to the language will take place that preclude the use of Lombok’s annotations, such as the addition of first class property support. Additionally, when used in combination with annotation-based object-relational mapping (ORM) frameworks, the number of annotations on data classes can begin to get unwieldy. This is largely offset by the amount of code that is superseded by the Lombok annotations. However, those who shun the frequent use of annotations may choose to look the other way. What is missing?Project Lombok provides the delombok utility for replacing the Lombok annotations with equivalent source code. This can be done for an entire source directory via the command line. 1java -jar lombok.jar delombok src -d src-delomboked Alternatively, an Ant task is provided for incorporation into a build process. 1234567&lt;target name=&quot;delombok&quot;&gt; &lt;taskdef classname=&quot;lombok.delombok.ant.DelombokTask&quot; classpath=&quot;WebRoot/WEB-INF/lib/lombok.jar&quot; name=&quot;delombok&quot; /&gt; &lt;mkdir dir=&quot;src-delomboked&quot; /&gt; &lt;delombok verbose=&quot;true&quot; encoding=&quot;UTF-8&quot; to=&quot;src-delomboked&quot; from=&quot;src&quot; /&gt;&lt;/target&gt; Both delombok and the corresponding Ant task come packaged in the core lombok.jar download. Along with allowing Lombok annotations to be useful in applications built using Google Web Toolkit (GWT) or other incompatible frameworks, running delombok on the Person class makes it easy to contrast the class as written using the Lombok annotations against code that includes the equivalent boilerplate inline. 123456789101112131415161718192021222324package com.ociweb.jnb.lombok;import java.util.Date;import lombok.Data;import lombok.EqualsAndHashCode;import lombok.NonNull;@Data@EqualsAndHashCode(exclude=&#123;&quot;address&quot;,&quot;city&quot;,&quot;state&quot;,&quot;zip&quot;&#125;)public class Person &#123; enum Gender &#123; Male, Female &#125; @NonNull private String firstName; @NonNull private String lastName; @NonNull private final Gender gender; @NonNull private final Date dateOfBirth; private String ssn; private String address; private String city; private String state; private String zip;&#125; The code utilizing the Project Lombok annotations is significantly more concise than the equivalent class with the boilerplate included. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167package com.ociweb.jnb.lombok;import java.util.Date;import lombok.NonNull;public class Person &#123; enum Gender &#123; /*public static final*/ Male /* = new Gender() */, /*public static final*/ Female /* = new Gender() */; &#125; @NonNull private String firstName; @NonNull private String lastName; @NonNull private final Gender gender; @NonNull private final Date dateOfBirth; private String ssn; private String address; private String city; private String state; private String zip; public Person(@NonNull final String firstName, @NonNull final String lastName, @NonNull final Gender gender, @NonNull final Date dateOfBirth) &#123; if (firstName == null) throw new java.lang.NullPointerException(&quot;firstName&quot;); if (lastName == null) throw new java.lang.NullPointerException(&quot;lastName&quot;); if (gender == null) throw new java.lang.NullPointerException(&quot;gender&quot;); if (dateOfBirth == null) throw new java.lang.NullPointerException(&quot;dateOfBirth&quot;); this.firstName = firstName; this.lastName = lastName; this.gender = gender; this.dateOfBirth = dateOfBirth; &#125; @NonNull public String getFirstName() &#123; return firstName; &#125; public void setFirstName(@NonNull final String firstName) &#123; if (firstName == null) throw new java.lang.NullPointerException(&quot;firstName&quot;); this.firstName = firstName; &#125; @NonNull public String getLastName() &#123; return lastName; &#125; public void setLastName(@NonNull final String lastName) &#123; if (lastName == null) throw new java.lang.NullPointerException(&quot;lastName&quot;); this.lastName = lastName; &#125; @NonNull public Gender getGender() &#123; return gender; &#125; @NonNull public Date getDateOfBirth() &#123; return dateOfBirth; &#125; public String getSsn() &#123; return ssn; &#125; public void setSsn(final String ssn) &#123; this.ssn = ssn; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(final String address) &#123; this.address = address; &#125; public String getCity() &#123; return city; &#125; public void setCity(final String city) &#123; this.city = city; &#125; public String getState() &#123; return state; &#125; public void setState(final String state) &#123; this.state = state; &#125; public String getZip() &#123; return zip; &#125; public void setZip(final String zip) &#123; this.zip = zip; &#125; @java.lang.Override public java.lang.String toString() &#123; return &quot;Person(firstName=&quot; + firstName + &quot;, lastName=&quot; + lastName + &quot;, gender=&quot; + gender + &quot;, dateOfBirth=&quot; + dateOfBirth + &quot;, ssn=&quot; + ssn + &quot;, address=&quot; + address + &quot;, city=&quot; + city + &quot;, state=&quot; + state + &quot;, zip=&quot; + zip + &quot;)&quot;; &#125; @java.lang.Override public boolean equals(final java.lang.Object o) &#123; if (o == this) return true; if (o == null) return false; if (o.getClass() != this.getClass()) return false; final Person other = (Person)o; if (this.firstName == null ? other.firstName != null : !this.firstName.equals(other.firstName)) return false; if (this.lastName == null ? other.lastName != null : !this.lastName.equals(other.lastName)) return false; if (this.gender == null ? other.gender != null : !this.gender.equals(other.gender)) return false; if (this.dateOfBirth == null ? other.dateOfBirth != null : !this.dateOfBirth.equals(other.dateOfBirth)) return false; if (this.ssn == null ? other.ssn != null : !this.ssn.equals(other.ssn)) return false; return true; &#125; @java.lang.Override public int hashCode() &#123; final int PRIME = 31; int result = 1; result = result * PRIME + (this.firstName == null ? 0 : this.firstName.hashCode()); result = result * PRIME + (this.lastName == null ? 0 : this.lastName.hashCode()); result = result * PRIME + (this.gender == null ? 0 : this.gender.hashCode()); result = result * PRIME + (this.dateOfBirth == null ? 0 : this.dateOfBirth.hashCode()); result = result * PRIME + (this.ssn == null ? 0 : this.ssn.hashCode()); return result; &#125;&#125; Keep in mind that this is not just code that normally has to be written, but must also be read by maintaining developers. This means that, when using the annotations provided by Project Lombok, developers do not have to wade through countless lines of code in order to determine if the class in question is a simple data class or something more sinister. LimitationsWhile Project Lombok does some dramatic things to make a developer’s life easier, it has its limitations. Browsing the issues list will quickly illuminate some of the current shortcomings, most of which are minor. One important problem is the inability to detect the constructors of a superclass. This means that if a superclass has no default constructor any subclasses cannot use the @Data annotation without explicitly writing a constructor to make use of the available superclass constructor. Since Project Lombok respects any methods that match the name of a method to be generated, the majority of its feature shortcomings can be overcome using this approach. ControversyA number of issues have been raised against the use of Project Lombok. The most common argument holds that annotations were intended for “meta” information and are not to be used in such a way that would leave the codebase unable to be compiled were they removed. This is certainly the situation with Lombok annotations. New methods result from these annotations that are intended to be used not only by a framework, but by other parts of the application. Project Lombok’s development-time support is its bread and butter, but this does have consequences, not the least of which is limited IDE support. As previously stated, @SneakyThrows is bound to stir up the age-old argument over checked and unchecked exceptions. Opinions on this debate are often almost religious in their ferocity. As such, the arguments against the use of @SneakyThrows are also sure to excite fervor among the passionate. Another point of contention is the implementation of both the code supporting IDE integration as well as the javac annotation processor. Both of these pieces of Project Lombok make use of non-public APIs to accomplish their sorcery. This means that there is a risk that Project Lombok will be broken with subsequent IDE or JDK releases. Here is how one of the project founders, Reinier Zwitserloot described the situation: 12345678910111213It&apos;s a total hack. Using non-public API. Presumptuous casting (knowing that anannotation processor running in javac will get an instance of JavacAnnotationProcessor,which is the internal implementation of AnnotationProcessor (an interface), whichso happens to have a couple of extra methods that are used to get at the live AST).On eclipse, it&apos;s arguably worse (and yet more robust) - a java agent is used to injectcode into the eclipse grammar and parser class, which is of course entirely non-publicAPI and totally off limits.If you could do what lombok does with standard API, I would have done it that way, butyou can&apos;t. Still, for what its worth, I developed the eclipse plugin for eclipse v3.5running on java 1.6, and without making any changes it worked on eclipse v3.4 runningon java 1.5 as well, so it&apos;s not completely fragile. SummaryProject Lombok is a powerful tool for the pragmatic developer. It provides a set of useful annotations for eliminating a tremendous amount of boilerplate code from your Java classes. In the best cases, a mere five characters can replace hundreds of lines of code. The result is Java classes that are clean, concise and easy to maintain. These benefits do come with a cost however. Using Project Lombok in an IntelliJ IDEA shop is simply not yet a viable option. There is a risk of breakage with IDE and JDK upgrades as well as controversy surrounding the goals and implementation of the project. What all this translates to is no different than what must be considered for any technology choice. There are always gains to be made and losses to be had. The question is simply whether or not Project Lombok can provide more value than cost for the project at hand. If nothing else, Project Lombok is sure to inject some new life into the discussion of language features that have withered on the vine thus far and that is a win from any perspective. References Project Lombok -http://projectlombok.org Lombok API Documentation -http://projectlombok.org/api/index.html Project Lombok Issues List -http://code.google.com/p/projectlombok/issues/list Use Lombok via Maven -http://projectlombok.org/mavenrepo/index.html Project Lombok Google Group -http://groups.google.com/group/project-lombok Reviewing Project Lombok or the Right Way to Write a Library -http://www.cforcoding.com/2009/11/reviewing-project-lombok-or-right-way.html Morbok: Extensions for Lombok -http://code.google.com/p/morbok Using Project Lombok with JDeveloper -http://kingsfleet.blogspot.com/2009/09/project-lombok-interesting-bean.html Example Code -LombokExample.zip Thanks to Mark Volkmann, Eric Burke, Mario Aquino and Lance Finney for reviewing and providing suggestions for this article, and a special thanks to Mark Volkmann for introducing me to Project Lombok. http://jnb.ociweb.com/jnb/jnbJan2010.html]]></content>
      <categories>
        <category>学习经验</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>开发知识</tag>
        <tag>IntelliJ IDEA</tag>
        <tag>Lombok插件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Idea Maven父子工程+多模块创建]]></title>
    <url>%2F2019%2F07%2F31%2FIdea-%E7%88%B6%E5%AD%90%E5%B7%A5%E7%A8%8B-%E5%A4%9A%E6%A8%A1%E5%9D%97%E5%88%9B%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[使用IDEA创建Maven聚合工程Zero. 工作空间我新建了一个名为Idea_SSM04_WebProject的文件夹，用于存放这个项目： 1. 创建一个Maven工程新建一个Maven工程，作为项目的父工程，可不勾选骨架，用于统一版本号。 将pom依赖导入 2. 创建子工程在上一步建好的工程上右键，新建Module，注意在后续选项中把add as Module改为None： 新工程名：WebShop-Common 修改路径为：E:\Idea_SSM04_WebProject\WebShop-Common （然后再创建第二个子工程，与上步骤一样。） 第二个子工程名：WebShop-SysManager 修改路径为：E:\Idea_SSM04_WebProject\WebShop-SysManager 3. 子工程之间的依赖使用dependency来指定依赖关系 如WebShop-SysManager的pom文件中增加： 12345678910&lt;artifactId&gt;WebShop-SysManager&lt;/artifactId&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.SH&lt;/groupId&gt; &lt;artifactId&gt;WebShop-Common&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 4. 创建模块接着在子工程里创建模块，直接在子工程右键新建Module即可。 新建模块路径默认即可： SysManager-Dao SysManager-Service SysManager-Pojo SysManager-Web 其中Web模块需要勾选webapp骨架，其他模块无需勾选骨架。 5. 运行Maven项目在含有webapp的工程pom里，这里是WebShop-SysManager，增加Tomcat7插件： 12345678910111213&lt;build&gt; &lt;!-- 配置插件 --&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;port&gt;8080&lt;/port&gt; &lt;path&gt;/&lt;/path&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 在右侧点击Maven，可查看当前项目的Maven详情： 在Add Configuration中点击加号，选Maven： 配置如下，名字随便起： 运行前，需要先把被依赖的工程install，接着install其他工程，install前请clean。webapp模块不需要安装，每次运行前最好都这样重复清理安装:]]></content>
      <categories>
        <category>学习经验</category>
      </categories>
      <tags>
        <tag>开发知识</tag>
        <tag>IntelliJ IDEA</tag>
        <tag>Maven聚合工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[改回来用Gitment评论系统]]></title>
    <url>%2F2019%2F07%2F29%2F%E6%94%B9%E5%9B%9E%E6%9D%A5%E7%94%A8Gitment%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[先前使用Gitment评论系统，由于作者证书失效，跨域服务不可用，改用了一段时间的Valine。Valine不需要登录，昵称和邮箱都是自定义的，身份只能靠浏览器、ip来识别。评论起来方便是方便，不过可读性不高，头像也比较单一。 相比起来，Gitment是使用Github账户登录的，身份唯一，在github互动也方便，可读性强。 今天偶然看到一篇文章，写得很详细，加上同样都是next主题（我比较懒，没怎么搞主题）可以傻瓜式操作，直接cv大法把js链接copy来了，感谢。 修改内容： 关闭valine,开启gitment,修改mint为false 路径 D:\HexoBlog\ShirtinyBlog\themes\next\_config.yml 123456789101112131415# Gitment# Introduction: https://github.com/imsun/gitmentgitment: enable: true mint: false # RECOMMEND, A mint on Gitment, to support count, language and proxy_gateway count: true # Show comments count in post meta area lazy: false # Comments lazy loading with a button cleanly: true # Hide 'Powered by ...' on footer, and more language: # Force language, or auto switch by theme github_user: Shirtiny # MUST HAVE, Your Github Username github_repo: Shirtiny.github.io # MUST HAVE, The name of the repo you use to store Gitment comments client_id: &#123;id（保密）&#125; # MUST HAVE, Github client id for the Gitment client_secret: &#123;密钥（保密）&#125; # EITHER this or proxy_gateway, Github access secret token for the Gitment proxy_gateway: # Address of api proxy, See: https://github.com/aimingoo/intersect redirect_protocol: # Protocol of redirect_uri with force_redirect_protocol when mint enabled 修改引入的CSS、Js的url 路径 D:\HexoBlog\ShirtinyBlog\themes\next\layout\_third-party\comments\gitment.swing 1234567891011121314151617&lt;!-- LOCAL: You can save these files to your site and update links --&gt;&#123;% if theme.gitment.mint %&#125; &#123;% set CommentsClass = 'Gitmint' %&#125; &lt;link rel="stylesheet" href="https://aimingoo.github.io/gitmint/style/default.css"&gt; &lt;script src="https://aimingoo.github.io/gitmint/dist/gitmint.browser.js"&gt;&lt;/script&gt;&#123;% else %&#125; &#123;% set CommentsClass = 'Gitment' %&#125; &lt;!--修改前 &lt;link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"&gt; --&gt; &lt;!-- &lt;script src="https://imsun.github.io/gitment/dist/gitment.browser.js"&gt;&lt;/script&gt; --&gt;&lt;!--改后 --&gt; &lt;link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/theme-next/theme-next-gitment@1/default.css"&gt; &lt;script src="https://cdn.jsdelivr.net/gh/theme-next/theme-next-gitment@1/gitment.browser.js"&gt;&lt;/script&gt; &#123;% endif %&#125;&lt;link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/theme-next/theme-next-gitment@1/default.css"/&gt;&lt;!-- END LOCAL --&gt; 也可使用： 12&lt;link rel="stylesheet" href="https://jjeejj.github.io/css/gitment.css"&gt;&lt;script src="https://jjeejj.github.io/js/gitment.js"&gt;&lt;/script&gt; 或 12&lt;link rel="stylesheet" href="https://jjeejj.github.io/css/gitment.css"&gt;&lt;script src="https://www.wenjunjiang.win/js/gitment.js"&gt;&lt;/script&gt; 我的Giment样式、js（最终修改） 12&lt;link rel="stylesheet" href="https://shirtiny.cn/css/myGitment.css"&gt;&lt;script src="https://shirtiny.cn/js/myGitment.js"&gt;&lt;/script&gt;]]></content>
      <categories>
        <category>系统维护</category>
      </categories>
      <tags>
        <tag>博客维护</tag>
        <tag>评论系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSM_SysManager_Security]]></title>
    <url>%2F2019%2F07%2F15%2FSSM-Security%2F</url>
    <content type="text"><![CDATA[SSM_后台数据管理+安全认证数据列表1. 商品表Product 变量名 类型 备注 id String 主键 productNum String 商品编号 productName String 商品名 cityName String 出发城市 departureTime Date 出发时间 departureTimeStr String 出发时间的字符串，不在数据库中 productPrice double 商品价格 productDesc String 商品描述 productStatus Integer 值0为关闭状态，值1为打开状态 productStatusStr String 商品状态的字符串，不在数据库中 1.1. Date与String之间的类型转换 赋值 Controller接收参数时，需要把用户输入的String类型的departureTime转为date类型，这里我设置了全局的类型转换器，由springMVC处理转换： 12345678910111213public class StringToDate implements Converter&lt;String, Date&gt; &#123; @Override public Date convert(String string) &#123; SimpleDateFormat sdf=new SimpleDateFormat("yyyy-MM-dd HH:mm"); Date date = null; try &#123; date = sdf.parse(string); &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; return date; &#125;&#125; springMVC配置： 12345678910111213141516171819&lt;!-- 配置类型转换器de固定步骤--&gt; &lt;!-- 01、 先将写好的转换器类放入IOC容器--&gt; &lt;bean id="SToDateConvertor" class="com.SH.Converters.StringToDate"&gt;&lt;/bean&gt; &lt;bean id="DToStringConvertor" class="com.SH.Converters.DateToString"&gt;&lt;/bean&gt; &lt;!-- 02、 再将自定义的转换器设置到springMVC中的转换器里 --&gt; &lt;!-- &lt;bean id="springConvertors" class="org.springframework.context.support.ConversionServiceFactoryBean"&gt;这是转换器的类--&gt; &lt;!-- 由于数据格式化的类是.format.support.FormattingConversionServiceFactoryBean包括了转换器的类，所以可以用格式化的类同时实现两个功能--&gt; &lt;bean id="springConvertors" class="org.springframework.format.support.FormattingConversionServiceFactoryBean"&gt; &lt;property name="converters" &gt; &lt;set&gt; &lt;ref bean="SToDateConvertor"/&gt; &lt;ref bean="xxx"/&gt; ... &lt;/set&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 03、 在&lt;mvc:annotation-driven&gt;里的conversion-service注册 02的bean --&gt; &lt;!-- 开启SpringMVC注解支持 --&gt; &lt;mvc:annotation-driven conversion-service="springConvertors"/&gt; 取值 输出时，可以使用事先定义的departureTimeStr，这样可以保持departureTime不变，需要对departureTimeStr赋值，在get方法中写： 1234567public String getDepartureTimeStr() &#123; if (departureTime!=null)&#123; String pattern="yyyy-MM-dd HH:mm"; departureTimeStr = DateAndString.DateToString(departureTime, pattern); &#125; return departureTimeStr; &#125; DateAndString是自定义的工具类，将date转为string，详情： 1234567public class DateAndString &#123; public static String DateToString(Date date,String pattern)&#123; SimpleDateFormat sdf=new SimpleDateFormat(pattern); return sdf.format(date); &#125;&#125; 注解方式 详情：@DateTimeFormat与@JsonFormat 2. 订单表Orders 变量名 类型 备注 id String 无意义，主键id orderNum String 订单编号 不为空 且唯一 orderTime Date 下单时间 orderTimeStr String 用于输出下单时间，不在数据库中 peopleCount int 出行人数 orderDesc String 订单备注和描述信息 payType int 支付方式（0支付宝，1微信，2其他） payTypeStr String 用于输出支付方式，不在数据库中 orderStatus int 订单的状态（0未支付 1已支付） orderStatusStr; String 用于输出下单状态，不在数据库中 productId int 产品的id，外键 memberid int 会员（联系人）id外键 travellers List 旅客 member Member 会员 2.1. 订单查询一个订单对应一个产品、一个会员（联系人）、多个旅客，使用注解方式查询数据时，使用@Results指定关系，一对一多对一使用@One指定方法，一对多多对多使用@Many指定方法 123456789101112131415//查询一个订单的具体信息@Select("select * from orders where id=#&#123;orderId&#125;") @Results(&#123; @Result(column = "id",property = "id",id = true), @Result(column = "orderNum",property = "orderNum"), @Result(property = "orderTime",column = "orderTime",javaType = Date.class,jdbcType =JdbcType.TIMESTAMP), @Result(property = "orderStatus",column = "orderStatus"), @Result(property = "peopleCount",column = "peopleCount"), @Result(property = "product",column = "productId",javaType = Product.class,one = @One(select = "com.SH.Dao.IproductDao.selectByid")), @Result(property = "travellers",column = "id",javaType = List.class,many = @Many(select = "com.SH.Dao.ItravellerDao.selectByid")), @Result(property = "member",column = "memberId",javaType = Member.class,one = @One(select = "com.SH.Dao.ImemberDao.selectById")), @Result(property = "payType",column = "payType"), @Result(property = "orderDesc",column = "orderDesc") &#125;) Orders selectById(String orderId) throws Exception; 3. 会员表Member 变量名 类型 备注 id String 无意义、主键id name String 姓名 nickName String 昵称 phoneNum String 电话号码 email String 邮箱 3.1. 单个会员查询：12@Select("select * from member where id=#&#123;id&#125;") Member selectById(String id); 4. 旅客表Traveller 变量名 类型 备注 id String 无意义、主键id name String 姓名 sex String 性别 phoneNum String 电话号码 credentialsType int 证件类型 0身份证 1护照 2军官证 credentialsTypeStr String 用于输出证件类型，不在数据库中 credentialsNum String 证件号码 travellerType int 旅客类型(人群) 0 成人 1 儿童 travellerTypeStr String 用于输出旅客类型，不在数据库中 5. 旅客与订单之间的多对多关系，order_traveller中间表 字段名 字段类型 字段描述 orderId varchar(32) 订单id，与对应表绑定外键 travellerId varchar(32) 旅客id，与对应表绑定外键 5.1. 根据指定订单号，多个旅客的查询：1234@Select("select * from traveller where id in( select travellerId from order_traveller where orderId=#&#123;orderId&#125; )") List&lt;Traveller&gt; selectByid(String orderId); 6. 用户表Users 变量名 类型 备注 id String 无意义，主键id email String 非空，唯一 username String 用户名 password String 密码（加密) phoneNum String 电话 status int 状态0 未开启 1 开启 roles List 角色集 6.1. 用户的查询：123456789101112//查询所有用户 @Select("select * from users") @Results(&#123; @Result(id = true,property = "id",column = "id"), @Result(property = "email",column = "email"), @Result(property = "username",column = "username"), @Result(property = "password",column = "password"), @Result(property = "phoneNum",column = "phoneNum"), @Result(property = "status",column = "status"), @Result(property = "roles",column = "id",javaType = List.class,many = @Many(select = "com.SH.Dao.IroleDao.selectByUserid")) &#125;) List&lt;UserInfo&gt; selectAllUser() throws Exception; 7. 角色表Role 变量名 类型 备注 id String 无意义，主键id roleName String 角色名 roleDesc String 角色描述 UserInfos List 用户集 permissions List 权限集 8. 用户与角色的多对多关系，user_role中间表 变量名 类型 备注 userId String 用户id,与用户id外键关联 roleId String 角色id，与角色id外键关联 8.1. 根据用户查询角色集合：123//根据用户id查询角色集 @Select("select * from role where id in(select roleId from user_role where userId=#&#123;userid&#125;)") List&lt;Role&gt; selectByUserid(String userid); 9. 权限表Permission 变量名 类型 备注 id String 无意义，主键id permissionName String 权限名 url String 资源路径 roles List 角色集 10. 角色与权限多对多关系，role_permission中间表 变量名 类型 备注 permissionId String 权限id，与权限id关联外键 roleId String 角色id，与角色id关联外键 Spring Security安全框架Spring Security是一种基于 Spring AOP 和 Servlet 过滤器的安全框架,它提供全面的安全性解决方案，同时在 Web 请求级和方法调用级处理认证和授权。 1.Pom依赖12345678910111213141516171819202122232425&lt;properties&gt; &lt;spring.security.version&gt;5.0.1.RELEASE&lt;/spring.security.version&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.security.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-config&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.security.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-core&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.security.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-taglibs&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.security.version&#125;&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 2. spring-Security.xml配置文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:security="http://www.springframework.org/schema/security" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/security http://www.springframework.org/schema/security/spring-security.xsd"&gt;&lt;!-- 不拦截的资源--&gt; &lt;security:http pattern="/css/**" security="none"/&gt; &lt;security:http pattern="/img/**" security="none"/&gt; &lt;security:http pattern="/plugins/**" security="none"/&gt; &lt;security:http pattern="/page/login.jsp" security="none"/&gt; &lt;security:http pattern="/page/fail.jsp" security="none"/&gt; &lt;!-- 配置具体的规则 auto-config="true" 不用自己编写登录的页面，框架提供默认登录页面 use-expressions="false" 是否使用SPEL表达式 --&gt; &lt;security:http auto-config="true" use-expressions="false"&gt; &lt;!-- 配置具体的拦截的规则, 限制用户添加页面的访问角色 ，小范围在前，大范围在后 --&gt; &lt;security:intercept-url pattern="/page/user-add.jsp" access="ROLE_GM"/&gt; &lt;!-- pattern="请求路径的规则" access="访问系统的人，必须有USER或GM的角色，ROLE_ 是框架需要的前缀" --&gt; &lt;security:intercept-url pattern="/**" access="ROLE_USER,ROLE_GM"/&gt; &lt;!-- 设置跳转的页面 --&gt; &lt;security:form-login login-page="/page/login.jsp" login-processing-url="/login.action" default-target-url="/page/main.jsp" authentication-failure-url="/page/fail.jsp" authentication-success-forward-url="/page/main.jsp" username-parameter="username" password-parameter="password" /&gt; &lt;!-- 关闭跨域请求，csrf主要是为了防止攻击 --&gt; &lt;security:csrf disabled="true"/&gt; &lt;!-- 用户注销，退出 --&gt; &lt;security:logout invalidate-session="true" logout-url="/logout.action" logout-success-url="/page/login.jsp" /&gt; &lt;/security:http&gt; &lt;!-- 切换成数据库中的用户名和密码 --&gt; &lt;security:authentication-manager&gt; &lt;!--配置userService类，它实现了继承了UserDetailsService的IuserService接口，重写了loadUserByUsername(String username)方法，返回一个UserDetails类对象，使用security提供的User对象封装数据库查询到的userinfo信息 --&gt; &lt;security:authentication-provider user-service-ref="userService"&gt; &lt;!-- 配置加密的方式，引用上面配置的加密类，指定密码被加密的方式，框架才能识别，以便找到合适的密码验证方式，不然会报There is no PasswordEncoder mapped for the id "null", 注意！若在xml中配置了加密类，&#123;id&#125;(密码前加&#123;noop&#125;、&#123;bcrypt&#125;等)将不可用，框架会直接使用指定加密类匹配字符串，不会再判断字符串加密类型 --&gt;&lt;!-- &lt;security:password-encoder ref="passwordEncoder"/&gt;--&gt; &lt;/security:authentication-provider&gt;&lt;/security:authentication-manager&gt; &lt;!-- 配置加密类，存储密码明文的加盐哈希 hash(m+salt)，不可逆加密，验证时匹配哈希值,注意，此项放在 &lt;security:authentication-manager&gt;前会在密码验证时影响&#123;id&#125;是否使用--&gt; &lt;bean id="passwordEncoder" class="org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder"/&gt; &lt;!-- 提供了入门的方式，在内存中存入用户名和密码 --&gt;&lt;!-- &lt;security:authentication-manager&gt;--&gt;&lt;!-- &lt;security:authentication-provider&gt;--&gt;&lt;!-- &lt;security:user-service&gt;--&gt;&lt;!-- &lt;security:user name="sh" password="&#123;noop&#125;123" authorities="ROLE_USER"/&gt;--&gt;&lt;!-- &lt;/security:user-service&gt;--&gt;&lt;!-- &lt;/security:authentication-provider&gt;--&gt;&lt;!-- &lt;/security:authentication-manager&gt;--&gt;&lt;/beans&gt; 3. Web.xml配置文件1234567891011121314151617181920212223&lt;!--监听器 --&gt;&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt;&lt;!--指定spring配置文件与security配置文件的位置 --&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:ApplicationContext.xml,classpath:spring- Security.xml&lt;/param-value&gt; &lt;/context-param&gt;&lt;!-- 过滤器,filter-name值必须为springSecurityFilterChain--&gt; &lt;filter&gt; &lt;filter-name&gt;springSecurityFilterChain&lt;/filter-name&gt; &lt;filter-class&gt; org.springframework.web.filter.DelegatingFilterProxy &lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;springSecurityFilterChain&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 4. 密码加密流程由于用户注册时，数据库中的用户密码需要加密保存，以保护用户信息安全。Spring Security提供的加密方式里，有一种为BCryptPasswordEncoder类，使用BCrypt强哈希方法来加密密码。这是种加盐哈希方式，每次加密产生的密文都不同，密码验证时通过匹配hash值来进行认证，可以抵御彩虹表，提高破解难度。 使用时，只需在接收用户信息后，调用BCryptPasswordEncoder对象的encode方法，对用户密码进行加密，然后将加密后的用户信息放入数据库即可,由于加密后数据比较长，注意数据库字符长度。如： 12345678910111213141516171819202122232425262728@Service("userService")@Transactionalpublic class userServiceImpl implements IuserService &#123; @Autowired private IuserDao userDao; @Autowired private BCryptPasswordEncoder passwordEncoder; @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123;...&#125;//添加用户，加密测试 @Override public void addUser(UserInfo userInfo) throws Exception &#123; //获取用户密码 String password=userInfo.getPassword(); //加密密码 String encode = passwordEncoder.encode(password); //修改用户密码 userInfo.setPassword(encode); //打印，以查看加密结果 System.out.println(encode); //插入数据库 userDao.insertOne(userInfo); &#125; 5. 登录认证流程5.1. 创建UserInfo类，用来封装数据库返回的用户信息1234567891011121314public class UserInfo &#123; private String id; private String email; private String username; private String password; private String phoneNum; private int status; private String statusStr; private List&lt;Role&gt; roles; .... //省略setter、getter、构造器 &#125; 5.2. Dao层查询出用户信息123456789101112//按照用户名查找单个用户，验证登录 @Select("select * from users where username=#&#123;username&#125;") @Results(&#123; @Result(id = true,property = "id",column = "id"), @Result(property = "email",column = "email"), @Result(property = "username",column = "username"), @Result(property = "password",column = "password"), @Result(property = "phoneNum",column = "phoneNum"), @Result(property = "status",column = "status"), @Result(property = "roles",column = "id",javaType = List.class,many = @Many(select = "com.SH.Dao.IroleDao.selectByUserid")) &#125;) UserInfo selectUserByName(String username); 5.3. 创建IuserService接口，继承UserDetailsService接口123public interface IuserService extends UserDetailsService &#123;&#125; 5.4. 创建userServiceImpl类，实现IuserService接口12345678910111213141516171819202122232425262728293031323334353637383940//放入IOC容器，取名为userService，供xml中配置@Service("userService")//事务管理@Transactionalpublic class userServiceImpl implements IuserService &#123; @Autowired private IuserDao userDao; //重写loadUserByUsername方法 @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123; //查询出对应用户信息 UserInfo userInfo = userDao.selectUserByName(username); //获取用户的角色集合 List&lt;Role&gt; roles = userInfo.getRoles(); //遍历权限并放入SimpleGrantedAuthority集合 SimpleGrantedAuthority authority; List&lt;SimpleGrantedAuthority&gt; authorities = new ArrayList&lt;&gt;(); for (Role role : roles) &#123; String roleName = role.getRoleName(); authority = new SimpleGrantedAuthority("ROLE_" + roleName); authorities.add(authority); &#125; //获取用户密码 String uPwd = userInfo.getPassword(); //使用Security提供的User类，至少需要用户名、密码、权限 User user; if (uPwd.length() &lt;= 50) &#123;//判断密码长度，以区分是否是加密的密码，因为加密后的密码比较长 //此时密码未进行加密，所以要加"&#123;noop&#125;"前缀，让框架识别 user = new User(userInfo.getUsername(), "&#123;noop&#125;" + uPwd, authorities); &#125; else &#123; //此时密码已经加密(正常情况下密码用户的密码应该不会大于50吧)，加"&#123;bcrypt&#125;"前缀，因为加密方式为bcrypt，让框架识别 user = new User(userInfo.getUsername(), "&#123;bcrypt&#125;" + uPwd, authorities); //若在xml中配置了加密方式，&#123;id&#125;就会失效，只使用配置的加密方式匹配密码，加密类的bean也不能靠前 &#125; //直接返回User类对象，因为User类实现了UserDetails return user; &#125; tips： 5.4.1. 关于”{noop}”前缀在spring5.0之后，springsecurity存储密码的格式发生了改变，新的密码存储格式为：加密方式和加密后的密码，{id}encodedPassword 1234567891011//均为字符串&#123;noop&#125;password//无加密，明文密码，前缀使用&#123;noop&#125;让框架识别，noop是no operate的意思 //各种加密方式的前缀，和对应的密文样式&#123;bcrypt&#125;$2a$10$dXJ3SW6G7P50lGmMkkmwe.20cQQubK3.HZWzG3YB1tlRy.fqvM/BG //BCryptPasswordEncoder类加密&#123;pbkdf2&#125;5d923b44a6d129f3ddf3e3c8d29412723dcbde72445e8ef6bf3b508fbf17fa4ed4d6b99ca763d8dc &#123;scrypt&#125;$e0801$8bWJaSu2IKSn9Z9kM+TPXfOc/9bdYSrN1oD9qfVThWEwdRTnO7re7Ei+fUZRJ68k9lTyuTeUp4of4g24hHnazw==$OAOec05+bXxvuu/1qZ6NUR+xQYvYv7BeL1QxwRpY5Pc= &#123;sha256&#125;97cde38028ad898ebc02e690819fa220e88c62e0699403e94fff291cfffaf8410849f27605abcbc0 5.4.2. 关于框架提供的User类Security的User类，提供了两个构造方法： 12345678910111213141516171819202122232425262728//Security提供的User类public class User implements UserDetails, CredentialsContainer &#123; private static final long serialVersionUID = 500L; private String password; private final String username; private final Set&lt;GrantedAuthority&gt; authorities; private final boolean accountNonExpired; private final boolean accountNonLocked; private final boolean credentialsNonExpired; private final boolean enabled; public User(String username, String password, Collection&lt;? extends GrantedAuthority&gt; authorities) &#123; this(username, password, true, true, true, true, authorities); &#125; public User(String username, String password, boolean enabled, boolean accountNonExpired, boolean credentialsNonExpired, boolean accountNonLocked, Collection&lt;? extends GrantedAuthority&gt; authorities) &#123; if (username != null &amp;&amp; !"".equals(username) &amp;&amp; password != null) &#123; this.username = username; this.password = password; this.enabled = enabled; this.accountNonExpired = accountNonExpired; this.credentialsNonExpired = credentialsNonExpired; this.accountNonLocked = accountNonLocked; this.authorities = Collections.unmodifiableSet(sortAuthorities(authorities)); &#125; else &#123; throw new IllegalArgumentException("Cannot pass null or empty values to constructor"); &#125; &#125; 三参构造（用户名，密码，权限集合 ），如： 1user = new User(userInfo.getUsername(), "&#123;bcrypt&#125;" + uPwd, authorities); 七參构造（用户名，密码，是否启用，账号是否过期，认证信息是否过期，是否被锁定，权限集合），如： 12User user = new User(userInfo.getUsername(), "&#123;bcrypt&#125;" + userInfo.getPassword(),userInfo.getStatus() == 0 ? false : true, true, true, true, authoritys); 5.5. 在Security的xml文件配置userService即可1234567 &lt;security:authentication-manager&gt; &lt;!--配置userService类，它实现了继承了UserDetailsService的IuserService接口，重写了loadUserByUsername(String username)方法，返回一个UserDetails类对象，使用security提供的User对象封装数据库查询到的userinfo信息 --&gt; &lt;security:authentication-provider user-service-ref="userService"&gt; &lt;/security:authentication-provider&gt;&lt;/security:authentication-manager&gt; 6. 注解方式的权限控制注解都默认关闭,使用前均需开启，在Spring-Security.xml中配置: 123&lt;!-- 启用注解,用于进行权限控制--&gt;&lt;!-- 开启JSR250注解、secured注解,支持spel表达式的注解--&gt;&lt;security:global-method-security jsr250-annotations="enabled" secured-annotations="enabled" pre-post-annotations="enabled"/&gt; 6.1. JSR250注解依赖、jar包: 12345&lt;dependency&gt; &lt;groupId&gt;javax.annotation&lt;/groupId&gt; &lt;artifactId&gt;jsr250-api&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt;&lt;/dependency&gt; @RolesAllowed注解，指定类、或方法需要的角色，无需加ROLE_前缀，使用： 1234567891011121314151617181920212223242526272829303132@Controller@RequestMapping(value = "/userController")//指定类内方法都默认需要GM的身份@RolesAllowed("GM")public class userController &#123; @Autowired private IuserService userService; //添加用户@RequestMapping(value = "/addUser") public String addUser(UserInfo userInfo) throws Exception &#123; userService.addUser(userInfo); return "redirect:/userController/findAll.action"; &#125; //查询所有用户 @RequestMapping(value = "/findAll") //指定此方法GM和USER都可以访问 @RolesAllowed(&#123;"GM","USER"&#125;) public ModelAndView findAllUser() throws Exception &#123; List&lt;UserInfo&gt; users = userService.selectAllUser(); ModelAndView mv=new ModelAndView(); mv.addObject("userList",users); mv.setViewName("user-list"); return mv; &#125;&#125; @PermitAll注解，表示允许所有的角色进行访问，也就是说不进行权限控制 @DenyAll注解，是和PermitAll相反的，表示无论什么角色都不能访问 6.2. @Secured注解此注解为Spring Security自带注解,用法与@RolesAllowed大致相同，不过角色要加ROLE_前缀,如: 123456789101112131415161718192021222324252627282930@Controller@RequestMapping(value = "/userController")//指定类内方法都默认需要GM的身份@Secured("ROLE_GM")public class userController &#123; @Autowired private IuserService userService; //添加用户@RequestMapping(value = "/addUser") public String addUser(UserInfo userInfo) throws Exception &#123; userService.addUser(userInfo); return "redirect:/userController/findAll.action"; &#125; //查询所有用户 @RequestMapping(value = "/findAll") //指定此方法GM和USER都可以访问 @Secured(&#123;"ROLE_USER","ROLE_GM"&#125;) public ModelAndView findAllUser() throws Exception &#123; List&lt;UserInfo&gt; users = userService.selectAllUser(); ModelAndView mv=new ModelAndView(); mv.addObject("userList",users); mv.setViewName("user-list"); return mv; &#125;&#125; 6.3. 支持SPEL表达式的注解常用的权限表达式： 表达式 说明 permitAll 永远返回true denyAll 永远返回false anonymous 当前用户是anonymous时返回true rememberMe 当前用户是rememberMe用户时返回true authenticated 当前用户不是anonymous时返回true fullAuthenticated 当前用户既不是anonymous也不是rememberMe用户时返回true hasRole（role） 用户拥有指定的角色权限时返回true hasAnyRole（[role1，role2]） 用户拥有任意一个指定的角色权限时返回true hasAuthority（authority） 用户拥有指定的权限时返回true hasAnyAuthority（[authority1,authority2]） 用户拥有任意一个指定的权限时返回true hasIpAddress（’192.168.1.0’） 请求发送的Ip匹配时返回true @PreAuthorize注解， 在方法调用之前,基于表达式的计算结果来限制对方法的访问如： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950@Controller@RequestMapping(value = "/userController")/*指定类内方法都默认需要GM的身份* @PreAuthorize("hasRole('ROLE_GM')") * 或 * @PreAuthorize("hasAuthority('ROLE_GM')") */public class userController &#123; @Autowired private IuserService userService; //添加用户@RequestMapping(value = "/addUser") public String addUser(UserInfo userInfo) throws Exception &#123; userService.addUser(userInfo); return "redirect:/userController/findAll.action"; &#125; //查询所有用户 @RequestMapping(value = "/findAll")/* * 指定此方法GM和USER都可以访问* @PreAuthorize("hasAnyRole('ROLE_GM','ROLE_USER')")* 或 * @PreAuthorize("hasAnyAuthority('ROLE_GM','ROLE_USER')")**/ public ModelAndView findAllUser() throws Exception &#123; List&lt;UserInfo&gt; users = userService.selectAllUser(); ModelAndView mv=new ModelAndView(); mv.addObject("userList",users); mv.setViewName("user-list"); return mv; &#125; //修改密码（测试） @RequestMapping(value = "/changeP") //取方法形参中的username，如果传入参数的值与登录用户的值相同，或者拥有GM权限，便可访问 @PreAuthorize("#username == authentication.principal.username or hasAuthority('ROLE_GM')") public String changeP(@P("username") String username) throws Exception&#123; return "ok"; &#125;&#125; @PostAuthorize 注解，允许方法调用,但是如果表达式计算结果为false,将抛出一个安全性异常示例： 123@PostAuthorizeUser getUser("returnObject.userId == authentication.principal.userId orhasPermission(returnObject, 'ADMIN')"); @PostFilter 注解，允许方法调用,但必须按照表达式来过滤方法的结果@PreFilter 注解，允许方法调用,但必须在进入方法之前过滤输入值 7. 权限控制标签依赖、jar（已有）： 1234567891011&lt;properties&gt; &lt;spring.security.version&gt;5.0.1.RELEASE&lt;/spring.security.version&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-taglibs&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.security.version&#125;&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; jsp页面引入taglib: 1&lt;%@taglib prefix="security" uri="http://www.springframework.org/security/tags" %&gt; 常用标签: authentication 允许访问当前的Authentication对象，获得属性的值，用来取值和获取对象。 1&lt;security:authentication property="" htmlEscape="" scope="" var=""/&gt; property： 只允许指定Authentication所拥有的属性，可以进行属性的级联获取 如“principle.username”，不允许直接通过方法进行调用 htmlEscape：表示是否需要将html进行转义。默认为true。 scope：与var属性一起使用，用于指定存放获取的结果的属性名的作用范围，默认我pageContext。Jsp中拥有的作用范围都进行进行指定 var： 用于指定一个属性名，这样当获取到了authentication的相关信息后会将其以var指定的属性名进行存放，默认是存放在pageConext中 实例： 1234567891011121314151617&lt;%@ page contentType="text/html;charset=UTF-8" language="java" isELIgnored="false" %&gt;&lt;%@ taglib prefix="security" uri="http://www.springframework.org/security/tags" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;用户属性&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;%--将用户对象在session中命名为user--%&gt;&lt;security:authentication property="principal" var="user" scope="session"/&gt; &lt;p&gt;$&#123;user&#125;&lt;/p&gt; &lt;p&gt;$&#123;user.username&#125;&lt;/p&gt; &lt;%--或直接输出值--%&gt;&lt;security:authentication property="principal.username"/&gt;&lt;/body&gt;&lt;/html&gt; 当然，你可以在你的MVC控制器中访问Authentication对象 （通过调用SecurityContextHolder.getContext().getAuthentication()） 然后直接在模型中添加数据，来渲染视图: 1234// Authentication authentication = SecurityContextHolder.getContext().getAuthentication();//User principal = (User)authentication.getPrincipal();//principal.getUsername(); authorize authorize是用来判断普通权限的，通过判断用户是否具有对应的权限而控制其所包含内容的显示。 1&lt;security:authorize access="" method="" url="" var=""&gt;&lt;/security:authorize&gt; access： 需要使用表达式来判断权限，当表达式的返回结果为true时表示拥有对应的权限 method：是配合url属性一起使用的，表示用户应当具有指定url指定method访问的权限，method的默认值为GET，可选值为http请求的7种方法 url：表示如果用户拥有访问指定url的权限即表示可以显示authorize标签包含的内容 var：用于指定将权限鉴定的结果存放在pageContext的哪个属性中 accesscontrollist accesscontrollist标签是用于鉴定ACL权限的。其一共定义了三个属性：hasPermission、domainObject和var，其中前两个是必须指定的。 1&lt;security:accesscontrollist hasPermission="" domainObject="" var=""&gt;&lt;/security:accesscontrollist&gt; hasPermission：用于指定以逗号分隔的权限列表 domainObject：用于指定对应的域对象 var：则是用以将鉴定的结果以指定的属性名存入pageContext中，以供同一页面的其它地方使用 操作日志记录每个用户的操作详情，方便管理和监控。这里使用Spring AOP的前置通知、后置通知，来控制日志的生成。 1. 日志表sysLog1.1. 数据库表 字段名称 字段类型 字段描述 id VARCHAR 无意义，完成时间的字符串 visitTime timestamp 访问时间 username VARCHAR 操作者用户名 ip VARCHAR 访问ip url VARCHAR 访问资源url executionTime int 执行时长 method VARCHAR 访问方法 1.1.1. 插入日志12@Insert("insert into syslog(id,visitTime,username,ip,url,executionTime,method) values(#&#123;id&#125;,#&#123;visitTime&#125;,#&#123;username&#125;,#&#123;ip&#125;,#&#123;url&#125;,#&#123;executionTime&#125;,#&#123;method&#125;)") boolean insertOne(SysLog sysLog); 1.1.2. 查询日志12345678910111213@Select("select * from syslog") @Results(&#123; @Result(id = true,property = "id",column = "id"), @Result(property = "visitTime",column = "visitTime",javaType = Date.class,jdbcType = JdbcType.TIMESTAMP), @Result(property = "username",column = "username"), @Result(property = "ip",column = "ip"), @Result(property = "url",column = "url"), @Result(property = "executionTime",column = "executionTime",javaType = long.class,jdbcType = JdbcType.INTEGER), @Result(property = "method",column = "method") &#125;) List&lt;SysLog&gt; selectAll() throws Exception; 1.2. 实体类123456789101112public class SysLog &#123;private String id;private Date visitTime;private String visitTimeStr;private String username;private String ip;private String url;private Long executionTime;private String method; //setter&amp;getter｝ 1.3. AOP生成数据开启spring-MVC对AOP的注解支持 123456&lt;!-- 支持AOP的注解支持，AOP底层使用代理技术 JDK动态代理，要求必须有接口 cglib代理，生成子类对象，proxy-target-class="true" 默认使用cglib的方式--&gt;&lt;aop:aspectj-autoproxy proxy-target-class="true"/&gt; 创建sysLogAOP类，使用aop的前置通知、后置通知，生成需要的数据，详细如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148package com.SH.AOP;import ...@Component@Aspectpublic class sysLogAOP &#123; @Autowired private HttpServletRequest request; @Autowired private IsysLogService sysLogService; private Class aClass; private Method method; private Date visitTime; private String visitTimeStr=""; private String ip=""; private String url=""; private String username=""; /* * 前置通知 * 生成访问方法时的时间 *获取操作者的信息 *获取ip *获取访问方法的类、类名、方法、方法名 *利用方法、类获取requestMapping的valueof[0]，拼接成url * 单个方法作为切入点 * @Before("execution(public String com.SH.Controller.productController.findAll(java.util.Map&lt;java.lang.String,java.lang.Object&gt;))") * */// 全部类型的 com.SH.Controller包下 全部类的全部方法 @Before("execution(* com.SH.Controller.*.*(..))")//前置通知 public void BeforeAd(JoinPoint joinPoint) throws NoSuchMethodException,SecurityException &#123;//异常由Class对象中的getMethod方法产生 //当前访问时间 visitTime = new Date(); //转为年-月-日 时:分:秒字符串 visitTimeStr = DateAndString.DateToString(visitTime, "yyyy-MM-dd HH:mm:ss"); //获取操作者信息 SecurityContext context = SecurityContextHolder.getContext(); User user = (User) context.getAuthentication().getPrincipal(); username = user.getUsername();//用户名 Collection&lt;GrantedAuthority&gt; authorities = user.getAuthorities();//角色 //获取操作者IP地址 ip = request.getRemoteAddr(); //获取访问的类和方法，拼接成url //获取切入对象的类 aClass = joinPoint.getTarget().getClass(); //★获取方法 //1. 获取切入对象（方法）的名字 String methodName=joinPoint.getSignature().getName(); //2. 获得方法的参数 Object[] args = joinPoint.getArgs(); //3. 判断要获取的方法是否有参数 if (args==null||args.length==0)//没有参数 &#123; //通过方法名获取方法//无参方法获取 method = aClass.getMethod(methodName); &#125;else &#123;//有参数 //创建一个argsClass数组 Class[] argsClass=new Class[args.length]; //循环，获取args数组里每个参数的类，并且装入argsClass数组 for (int i=0;i&lt;args.length;i++)&#123; argsClass[i]= args[i].getClass(); &#125; //通过方法名+参数类型获取方法//有参方法获取 method= aClass.getMethod(methodName,argsClass);//有的方法，参数是基本数据类型如int，方法内int参数换成Integer包装类 &#125; //拼接url String classURL="";//类路径 String methodURL="";//类后方法路径// class和method都拿到后，就可以拿到requestMapping注解里的值 if (aClass!=null&amp;&amp;method!=null&amp;&amp;aClass!=sysLogAOP.class)&#123;//防止空指针，并且class不为自身（？看有人这么写）//获取类和方法的RequestMapping对象 RequestMapping classAnnotation =(RequestMapping) aClass.getAnnotation(RequestMapping.class); RequestMapping methodAnnotation =(RequestMapping) method.getAnnotation(RequestMapping.class); if (classAnnotation!=null)&#123; classURL=classAnnotation.value()[0]; &#125; if (methodAnnotation!=null)&#123; methodURL=methodAnnotation.value()[0]; &#125;//.value()值为数组 url=classURL+methodURL; &#125; //打印输出，方便测试 System.out.println("访问时间"+ visitTimeStr); System.out.println("用户："+username+"；身份："+authorities+"IP地址："+ip); System.out.println("访问的类"+aClass+"；方法"+methodName+"\n；URL："+url); System.out.println("传递参数值："+ Arrays.toString(args)); &#125; /* * 后置通知 * 生成方法的完成时间 * 计算耗时 * 封装日志数据 * 调用service处理 * */ @After("execution(* com.SH.Controller.*.*(..))") public void AfterAd() throws Exception&#123; //记录方法完成的时间 Date completeTime=new Date(); //转换成指定格式字符串 String completeTimeStr =DateAndString.DateToString(completeTime,"yyyy-MM-dd HH:mm:ss"); //计算耗时 Long usedTime=completeTime.getTime()-visitTime.getTime(); //封装数据 SysLog sysLog=new SysLog(); sysLog.setId(completeTimeStr); sysLog.setVisitTime(visitTime); sysLog.setVisitTimeStr(visitTimeStr); sysLog.setUsername(username); sysLog.setIp(ip); sysLog.setUrl(url); sysLog.setExecutionTime(usedTime); sysLog.setMethod(method.getName()); //存入数据库 boolean flag = sysLogService.insertOne(sysLog); //打印输出，方便测试 System.out.println("完成时间："+completeTimeStr+"；耗时："+usedTime+"毫秒"); System.out.println("封装日志："+sysLog); System.out.println("将日志，存入数据库结果："+flag); &#125;&#125; tips： 1.3.1. 关于获取IPspring提供了一个RequestContextListener，可以在spring中直接使用（先注入）HttpServletRequest对象。在web.xml中配置监听器： 123456&lt;!-- 为spring提供 request对象,监听器--&gt;&lt;listener&gt; &lt;listener-class&gt; org.springframework.web.context.request.RequestContextListener &lt;/listener-class&gt;&lt;/listener&gt; 1.3.2. 关于获取用户信息可以通过SecurityContextHolder.getContext()获取sercurity上下文对象，从而可以getAuthentication().getPrincipal()获得用户对象，这个上文在权限控制标签中说过。 12SecurityContext context = SecurityContextHolder.getContext();//获取Security上下文对象User user = (User) context.getAuthentication().getPrincipal();//获取用户对象 创建sysLogAOP类，使用aop的前置通知、后置通知，详细如下： 1.3.3. 关于获取URL这里的url是拼接Controller类&amp;方法的@RequestMapping值得到的。 首先需要获取类、方法。 类使用JoinPoint获取： 1234//获取对象的类aClass = joinPoint.getTarget().getClass();//或dClass = joinPoint.getSignature().getDeclaringType(); 至于方法，因为将调用的Class对象的getMethod方法为： 12345678910@CallerSensitive public Method getMethod(String name, Class&lt;?&gt;... parameterTypes) throws NoSuchMethodException, SecurityException &#123; checkMemberAccess(Member.PUBLIC, Reflection.getCallerClass(), true); Method method = getMethod0(name, parameterTypes, true); if (method == null) &#123; throw new NoSuchMethodException(getName() + "." + name + argumentTypesToString(parameterTypes)); &#125; return method; &#125; 所以要按有无参数分开获取： 先使用JoinPoint得到方法名和方法的参数： 1234//1. 获取切入对象（方法）的名字String methodName=joinPoint.getSignature().getName();//2. 获得方法的参数（一个Object数组）Object[] args = joinPoint.getArgs(); 通过判断参数是否为空，来确认方法是否有參。 若无参数： 12345//3. 判断要获取的方法是否有参数 if (args==null||args.length==0)//没有参数 &#123; //通过方法名获取方法//无参方法获取 method = aClass.getMethod(methodName); 若有参数： 123456789101112&#125;else &#123;//有参数 //创建一个argsClass数组 Class[] argsClass=new Class[args.length]; //循环，获取args数组里每个参数的类，并且装入argsClass数组 for (int i=0;i&lt;args.length;i++)&#123; argsClass[i]= args[i].getClass();//这里会将int等基础数据类型获取成Integer包装类型// System.out.println("参数："+args[i]); &#125; //通过方法名+参数类型获取方法//有参方法获取 method= aClass.getMethod(methodName,argsClass);//有的方法，参数是基本数据类型如int，需要将方法内int参数换成Integer包装类,也就Controller层形参都使用Inter类型 &#125; 此处参数类型问题的详情： 这里参数获取类型（arg.getClass()），会把基本数据类型（如int等）获取成包装类型（如Integer等），而实际上是基本数据类型，这会使class.getMethod(String name, Class&lt;?&gt;... parameterTypes)执行时找不到匹配的方法对象，报NoSuchMethodException异常，以及后续的空指针异常。因为获取时便是Integer，使用isPrimitive()（确认是否为基本数据类型）的结果始终为false，目前我并未找到完美的解决方法。 临时的解决方式： ①让Controller内方法的参数类型只使用Integer等包装类，不能使用int等基本数据类型。直接把Controller内的int、char等类型改成Integer、Char就行了，不再用代码举例了。 ②创建一个HashMap用来存放包装类型与基本类型的&lt;K、V&gt;对，将获取的包装类型转换为基本类型。这样做就会使Controller类内方法的参数类型只能用int等基本数据类型，不能使用Integer等包装类型。当然，其他类型是不影响的。详细代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364@Component@Aspectpublic class sysLogAOP &#123; //创建一个HashMap，存放包装类与基本类型的KV对，用来将包装类型转为基本数据类型private static HashMap&lt;String, Class&gt; map = new HashMap&lt;String, Class&gt;() &#123; &#123; put("java.lang.Integer", int.class); put("java.lang.Double", double.class); put("java.lang.Float", float.class); put("java.lang.Long", long.class); put("java.lang.Short", short.class); put("java.lang.Boolean", boolean.class); put("java.lang.Char", char.class); &#125; &#125;; //获取切入对象的类 aClass = joinPoint.getTarget().getClass(); //★获取方法 String methodName=joinPoint.getSignature().getName();//1. 获取切入对象（方法）的名字 Object[] args = joinPoint.getArgs();//2. 获得方法的参数 //3. 判断要获取的方法是否有参数 Class[] argsClass=null;//参数类型数组 if (args==null||args.length==0)//没有参数 &#123; //通过方法名获取方法//无参方法获取 method = aClass.getMethod(methodName);//获取指定的方法，第二个参数可以不传 &#125;else &#123;//有参数 argsClass=new Class[args.length];//创建一个argsClass数组,长度与参数数组相同 for (int i=0;i&lt;args.length;i++)&#123;//循环 argsClass[i]= args[i].getClass();//获取args数组里每个参数的类，并且装入argsClass数组 //打印，以供观察 System.out.println("遍历出的参数的类名为："+args[i].getClass().getName()); if (map.get(args[i].getClass().getName())!=null)&#123;//能根据参数的类名在自定义的hashMap中找到对应的基本类型 argsClass[i]=map.get(args[i].getClass().getName());//则放入class数组,覆盖掉之前的class数组值，此时通过map将参数类型转为了基本数据类型 //打印，以供观察 System.out.println("参数类型转换为："+argsClass[i]); &#125;else &#123;//如果根据参数的类名在自定义的map集合中取不到值，则说明参数是其他类型 //打印，以供观察 System.out.println("参数是其他类型，或者是基本类型，保持class不变"); &#125; &#125; //打印出最终参数类型 System.out.println("最终参数类型："+ Arrays.toString(argsClass)); //通过方法名+参数类型获取方法//有参方法获取 method= aClass.getMethod(methodName,argsClass);//此时Controller类内方法参数类型就不能为包装类型了，只能用int、char等基本数据类型 &#125; 补充：还有个同样的问题，它有时还会把其他类型的参数获取成特定类型，如java.util.Map会获取成org.springframework.validation.support.BindingAwareModelMap。我将Controller类内方法的Map类型替换为BindingAwareModelMap类型，暂时避免异常。 BindingAwareModelMap类的信息如图所示，目前使用中尚未出现其他问题。 获取类和方法后，就可获取需要的注解（需要转换），这里是@RequestMapping注解 12RequestMapping classAnnotation =(RequestMapping) aClass.getAnnotation(RequestMapping.class);//类的RequestMapping注解 RequestMapping methodAnnotation =(RequestMapping) method.getAnnotation(RequestMapping.class);//方法的RequestMapping注解 当然前提是类和方法不为null 1if (aClass!=null&amp;&amp;method!=null) 然后就可以通过获得的RequestMapping对象，获得需要的属性。 注意： 虽然是Controller类，但类和方法不能保证都一定有@RequestMapping注解，并且value属性是数组 123456if (classAnnotation!=null)&#123; classURL=classAnnotation.value()[0]; &#125; if (methodAnnotation!=null)&#123; methodURL=methodAnnotation.value()[0]; &#125; 将两个RequestMapping的value值拼接起来，就拿到一个Controller-方法的URL了 1String URL=classURL+methodURL; 1.3.4. 关于获取参数值和参数名先获取参数 12//获得方法的参数（一个Object数组）Object[] args = joinPoint.getArgs(); 1.参数值 for循环打印出参数值 1234//循环，打印args数组里的值 for (int i=0;i&lt;args.length;i++)&#123; System.out.println("参数："+args[i]); &#125; 利用Array的toString方法打印参数值 1System.out.println("传递参数值："+ Arrays.toString(args)); 参考：数组输出的三种方式 2.参数名 123ParameterNameDiscoverer dpnd = new DefaultParameterNameDiscoverer();String[] argsNames = dpnd.getParameterNames(method);//method是之间获取方法时，得到的Method对象System.out.println("参数名："+ Arrays.toString(argsNames)); 然后做个数据分页即可，操作日志就完成了 2. 登录足迹loginLog我的做法是：在上文Security登录流程中的userServiceImpl类里，获取用户登录时间、ip。将数据拿到后封装，插入到数据库即可。 12345678910111213141516171819202122232425262728package com.SH.Service.ServiceImpl;import ...@Service("userService")//起个名字，供xml中配置@Transactionalpublic class userServiceImpl implements IuserService &#123; @Autowired private HttpServletRequest request; ... @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123; ... //获取用户ip、登录时间 String ip = request.getRemoteAddr();// Date logintime=new Date(); String logintime=DateAndString.DateToString(new Date(),"yyyy-MM-dd HH:mm:ss"); //打印以观察 System.out.println("用户："+username+"登陆ip"+ip+"；时间："+logintime); //将数据插入数据库即可 ... &#125; @Override public void addUser(UserInfo userInfo) throws Exception &#123;... &#125; 3. 日志数据分页依然是使用MyBatis的分页插件PageHelper，分页上次说过，这里简要复习，有一些知识的更新。 3.1. 依赖、Jar包12345&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;5.1.2&lt;/version&gt;&lt;/dependency&gt; 3.2. 分页后台这里使用了@RequestParam注解，属性name是前端参数名、required为是否必要、defaultValue为默认值。 分页插件的使用： 分页需要pageNum、pageSize两个参数，int或Integer类型。 PageHelper.startPage(int pageNum,int pageSize)方法后直接跟需要分页的方法即可，在service层写好后调用service也是可以的。 将查询方法返回的List集合交给PageInfo封装 在request域放入PageInfo对象即可 12345678910111213141516@RequestMapping("/selectBypage") public ModelAndView selectBypage(@RequestParam(name = "pageNum",required = true,defaultValue = "1") int pageNum, @RequestParam(name = "pageSize",required = true,defaultValue = "10") int pageSize) throws Exception &#123; //分页 PageHelper.startPage(pageNum,pageSize); List&lt;SysLog&gt; sysLogList = sysLogService.selectAll(); //pageInfo封装 PageInfo pageInfo=new PageInfo&lt;&gt;(sysLogList); ModelAndView mv=new ModelAndView(); mv.setViewName("syslog-list"); mv.addObject("pageInfo",pageInfo); return mv; &#125; PageInfo包装类的属性： 12345678910111213141516171819202122232425262728293031323334353637383940414243//当前页private int pageNum;//每页的数量private int pageSize;//当前页的数量private int size;//排序private String orderBy;//可以在页面中"显示startRow到endRow 共size条数据"//当前页面第一个元素在数据库中的行号private int startRow;//当前页面最后一个元素在数据库中的行号private int endRow;//总记录数private long total;//总页数private int pages;//结果集private List&lt;T&gt; list;//第一页private int firstPage;//前一页private int prePage;//下一页private int nextPage;//最后一页private int lastPage;//是否为第一页private boolean isFirstPage = false;//是否为最后一页private boolean isLastPage = false;//是否有前一页private boolean hasPreviousPage = false;//是否有下一页private boolean hasNextPage = false;//导航页码数private int navigatePages;//所有导航页号private int[] navigatepageNums; 3.3. 分页前端3.3.1. 环境准备EL表达式 前端Jsp页面使用EL表达式较为方便，要使用EL表达式注意将isELIgnored设为false，是否需要设置，要根据web.xml文件的声明部分的xsd版本而定，因为有的版本默认这个属性是true，会将EL表达式当字符串处理。 .jsp页面设置isELIgnored=”false”： 12&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8" isELIgnored="false" %&gt; web.xml，一个默认开启EL的版本： 12345&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://xmlns.jcp.org/xml/ns/javaee" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd" version="3.1"&gt; JSTL标签 在jsp页面头部引入JSP标准标签库 1&lt;%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core"%&gt; 3.3.2. 功能实现 数据展示 1234567891011121314151617&lt;!--数据列表--&gt;...前略&lt;!--使用jstl的forEach标签，进行数据遍历，items是要遍历的集合--&gt;&lt;c:forEach items="$&#123;pageInfo.list&#125;" var="syslog"&gt; &lt;tr&gt; &lt;td&gt;&lt;input name="ids" type="checkbox"&gt;&lt;/td&gt; &lt;td&gt;$&#123;syslog.id&#125;&lt;/td&gt; &lt;td&gt;$&#123;syslog.visitTimeStr &#125;&lt;/td&gt; &lt;td&gt;$&#123;syslog.username &#125;&lt;/td&gt; &lt;td&gt;$&#123;syslog.ip &#125;&lt;/td&gt; &lt;td&gt;$&#123;syslog.url&#125;&lt;/td&gt; &lt;td&gt;$&#123;syslog.executionTime&#125;毫秒&lt;/td&gt; &lt;td&gt;$&#123;syslog.method&#125;&lt;/td&gt; &lt;/tr&gt;&lt;/c:forEach&gt;...后略&lt;!--数据列表/--&gt; 分页按钮 1234567891011121314151617 &lt;a href="$&#123;pageContext.request.contextPath&#125;/sysLogController/selectBypage.action?pageNum=1&amp;pageSize=$&#123;pageInfo.size&#125;" &gt;首页&lt;/a&gt;&lt;a href="$&#123;pageContext.request.contextPath&#125;/sysLogController/selectBypage.action?pageNum=$&#123;pageInfo.pageNum-1&#125;&amp;pageSize=$&#123;pageInfo.size&#125;"&gt;上一页&lt;/a&gt; &lt;!-- 第一页、第二页、第三页...--&gt;&lt;ul&gt;&lt;c:forEach begin="1" end="$&#123;pageInfo.pages&#125;" var="num"&gt; &lt;li&gt;&lt;a href="$&#123;pageContext.request.contextPath&#125;/sysLogController/selectBypage.action?pageNum=$&#123;num&#125;&amp;pageSize=$&#123;pageInfo.size&#125;"&gt;$&#123;num&#125;&lt;/a&gt;&lt;/li&gt; &lt;/c:forEach&gt; &lt;/ul&gt; &lt;a href="$&#123;pageContext.request.contextPath&#125;/sysLogController/selectBypage.action?pageNum=$&#123;pageInfo.pageNum+1&#125;&amp;pageSize=$&#123;pageInfo.size&#125;"&gt;下一页&lt;/a&gt; &lt;a href="$&#123;pageContext.request.contextPath&#125;/sysLogController/selectBypage.action?pageNum=$&#123;pageInfo.pages&#125;&amp;pageSize=$&#123;pageInfo.size&#125;"&gt;尾页&lt;/a&gt; 改变每页容量 123456789101112131415161718&lt;div class="form-group form-inline"&gt;总共$&#123;pageInfo.pages&#125; 页，共$&#123;pageInfo.total&#125; 条数据。 每页 &lt;select id="selectSize" class="form-control" onchange="checkChange()"&gt; &lt;option&gt;10&lt;/option&gt; &lt;option&gt;15&lt;/option&gt; &lt;option&gt;20&lt;/option&gt; &lt;option&gt;50&lt;/option&gt; &lt;option&gt;80&lt;/option&gt; &lt;/select&gt; 条&lt;/div&gt;&lt;script&gt;//改变每页条数jsfunction checkChange()&#123;var size=$("#selectSize").val();location.href= "$&#123;pageContext.request.contextPath&#125;/sysLogController/selectBypage.action?pageNum=$&#123;pageInfo.pageNum&#125;&amp;pageSize="+size;&#125;&lt;/script&gt; 项目中使用了AdminLTE来美化页面。 AdminLTE：一款建立在bootstrap和jquery之上的开源的模板主题工具，它提供了一系列响应的、可重复使用的组件，并内置了多个模板页面；同时自适应多种屏幕分辨率，兼容PC和移动端。]]></content>
      <categories>
        <category>学习经验</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Maven聚合工程</tag>
        <tag>SSM</tag>
        <tag>用户关系管理项目</tag>
        <tag>Spring-security</tag>
        <tag>权限安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSM基础整合]]></title>
    <url>%2F2019%2F07%2F08%2FSSM%E5%9F%BA%E7%A1%80%E6%95%B4%E5%90%88%2F</url>
    <content type="text"><![CDATA[SSM基础整合Zero. 创建Maven项目， pom依赖： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.SH&lt;/groupId&gt; &lt;artifactId&gt;SSM_01Project&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;name&gt;SSM_01Project Maven Webapp&lt;/name&gt; &lt;!-- FIXME change it to the project's website --&gt; &lt;url&gt;http://www.example.com&lt;/url&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt; &lt;spring.version&gt;4.3.3.RELEASE&lt;/spring.version&gt; &lt;slf4j.version&gt;1.6.6&lt;/slf4j.version&gt; &lt;log4j.version&gt;1.2.12&lt;/log4j.version&gt; &lt;mysql.version&gt;5.1.6&lt;/mysql.version&gt; &lt;mybatis.version&gt;3.4.5&lt;/mybatis.version&gt; &lt;jackson.version&gt;2.6.1&lt;/jackson.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.6.8&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;$&#123;mysql.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- log start --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;$&#123;log4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- log end --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;c3p0&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.1.2&lt;/version&gt; &lt;type&gt;jar&lt;/type&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-dbcp&lt;/groupId&gt; &lt;artifactId&gt;commons-dbcp&lt;/artifactId&gt; &lt;version&gt;1.4&lt;/version&gt; &lt;/dependency&gt;&lt;!--json数据格式--&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;$&#123;jackson.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;$&#123;jackson.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--sql 解析工具依赖,配合分页使用--&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.jsqlparser&lt;/groupId&gt; &lt;artifactId&gt;jsqlparser&lt;/artifactId&gt; &lt;version&gt;0.9.5&lt;/version&gt; &lt;/dependency&gt; &lt;!--myBatis分页插件 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;5.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;SSM_01Project&lt;/finalName&gt; &lt;pluginManagement&gt;&lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/plugin&gt; &lt;!-- see http://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_war_packaging --&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.8.0&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;version&gt;2.22.1&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;version&gt;3.2.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-install-plugin&lt;/artifactId&gt; &lt;version&gt;2.5.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt; &lt;version&gt;2.8.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.2&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;showWarnings&gt;true&lt;/showWarnings&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;/build&gt;&lt;/project&gt; 1. ApplicationContext.xml 新建db.properties，写数据库配置需要的数据 加载db.properties，class为：PreferencesPlaceholderConfigurer，属性locations下用array，value，classpath引用db.properties datasource，class为：BasicDatasource，property下配置数据库链接信息 sqlSessionFactory，Class为：SqlSessionFactroyBean，属性需要引用datasource和mapperlocations值为classpath：*.xml加载mybatis的mapperxml mappers批量生成mapper接口的对象，class为：MapperScannerConfigurer，注意属性basePackage的值用value，而不是ref 开启注解扫描，component-scan，并且使用排除Controller注解（annotation），（org.springframework.stereotype.Controller） 配置事务管理，DataSourceTransactionManager，其属性中引入datasource，开启事务注解支持:&lt;tx:annotation-driven,空格后配置transaction-manager属性将上面bean的id值输入 代码： db.properties 1234driver=com.mysql.jdbc.Driverurl=jdbc:mysql://localhost:3306/databaseusername=rootpassword=123456 log4j.properties 123456789101112131415161718# Set root category priority to INFO and its only appender to CONSOLE.#log4j.rootCategory=INFO, CONSOLE debug info warn error fatallog4j.rootCategory=info, CONSOLE, LOGFILE# Set the enterprise logger category to FATAL and its only appender to CONSOLE.log4j.logger.org.apache.axis.enterprise=FATAL, CONSOLE# CONSOLE is set to be a ConsoleAppender using a PatternLayout.log4j.appender.CONSOLE=org.apache.log4j.ConsoleAppenderlog4j.appender.CONSOLE.layout=org.apache.log4j.PatternLayoutlog4j.appender.CONSOLE.layout.ConversionPattern=%d&#123;ISO8601&#125; %-6r [%15.15t] %-5p %30.30c %x - %m\n# LOGFILE is set to be a File appender using a PatternLayout.log4j.appender.LOGFILE=org.apache.log4j.FileAppenderlog4j.appender.LOGFILE.File=d:\axis.loglog4j.appender.LOGFILE.Append=truelog4j.appender.LOGFILE.layout=org.apache.log4j.PatternLayoutlog4j.appender.LOGFILE.layout.ConversionPattern=%d&#123;ISO8601&#125; %-6r [%15.15t] %-5p %30.30c %x - %m\n ApplicationContext.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd"&gt;&lt;!-- 数据源--&gt;&lt;bean id="dbproperties" class="org.springframework.beans.factory.config.PreferencesPlaceholderConfigurer"&gt; &lt;property name="locations"&gt; &lt;array&gt; &lt;value&gt;classpath:db.properties&lt;/value&gt; &lt;/array&gt; &lt;/property&gt;&lt;/bean&gt; &lt;bean id="datasource" class="org.apache.commons.dbcp.BasicDataSource"&gt; &lt;property name="driverClassName" value="$&#123;driver&#125;"/&gt; &lt;property name="url" value="$&#123;url&#125;"/&gt; &lt;property name="username" value="$&#123;username&#125;"/&gt; &lt;property name="password" value="$&#123;password&#125;"/&gt;&lt;/bean&gt;&lt;bean id="sqlsessionFactroy" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;property name="dataSource" ref="datasource"/&gt; &lt;property name="mapperLocations" value="classpath:MapperXml/*.xml"/&gt;&lt;!-- 插件列表--&gt; &lt;property name="plugins"&gt; &lt;array&gt;&lt;!-- myBatis分页--&gt; &lt;bean class="com.github.pagehelper.PageInterceptor"&gt; &lt;property name="properties"&gt; &lt;value&gt;helperDialect=mysql&lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/array&gt; &lt;/property&gt;&lt;/bean&gt;&lt;!-- 批量生成mapper对象--&gt;&lt;bean id="mappers" class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;property name="basePackage" value="com.SH.mapper"/&gt;&lt;/bean&gt;&lt;!-- 注解扫描，不扫描Controller--&gt; &lt;context:component-scan base-package="com.SH"&gt; &lt;context:exclude-filter type="annotation" expression="org.springframework.stereotype.Controller"/&gt; &lt;/context:component-scan&gt;&lt;!--事务管理--&gt; &lt;bean id="transManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="datasource"/&gt; &lt;/bean&gt;&lt;!-- 事务注解支持--&gt; &lt;tx:annotation-driven transaction-manager="transManager"/&gt;&lt;/beans&gt; 2. mpper.xml 配置mybaitis的mpper.xml 代码： MapperXml/VocaloidMapper.xml（放置在resources/MapperXml包下） 12345678910111213&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.SH.mapper.VocaloidMapper"&gt; &lt;select id="selectAll" resultType="com.SH.bean.Vocaloid"&gt; select * from vocaloid &lt;/select&gt;&lt;/mapper&gt; 3. 建立数据库表的对应类 生成set、get方法，构造器，重写toString 代码： com.SH.bean.Vocaloid 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package com.SH.bean;public class Vocaloid &#123;private Integer id;private String name;private Integer sex;private String color;private Integer team_id; public Vocaloid() &#123; &#125; @Override public String toString() &#123; return "Vocaloid&#123;" + "id=" + id + ", name='" + name + '\'' + ", sex=" + sex + ", color='" + color + '\'' + ", team_id=" + team_id + '&#125;'; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getSex() &#123; return sex; &#125; public void setSex(Integer sex) &#123; this.sex = sex; &#125; public String getColor() &#123; return color; &#125; public void setColor(String color) &#123; this.color = color; &#125; public Integer getTeam_id() &#123; return team_id; &#125; public void setTeam_id(Integer team_id) &#123; this.team_id = team_id; &#125; public Vocaloid(Integer id, String name, Integer sex, String color, Integer team_id) &#123; this.id = id; this.name = name; this.sex = sex; this.color = color; this.team_id = team_id; &#125;&#125; 3. Mapper接口 建立mapper.xml对应的接口 代码： com.SH.mapper.VocaloidMapper 123456789101112package com.SH.mapper;import com.SH.bean.Vocaloid;import java.util.HashMap;import java.util.List;public interface VocaloidMapper &#123; List&lt;Vocaloid&gt; selectAll();&#125; 4. springMVC.xml 开启mvc注解支持，annotation-driven 开启注解扫描component-scan，使用base-package只扫描Controller包 配置视图解析器InternalResourceViewResolver,prefix前缀，suffix后缀 代码： springMVC.xml 1234567891011121314151617181920212223242526272829303132&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt;&lt;!-- 配置组件扫描，注解扫描，只扫描Controller包--&gt;&lt;context:component-scan base-package="com.SH.controller"/&gt;&lt;!-- 开启mvc注解驱动，处理器映射器，处理器解析器--&gt; &lt;mvc:annotation-driven/&gt;&lt;!-- 视图解析器--&gt; &lt;bean id="internalviewresovler" class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/resources/jsp/"/&gt; &lt;property name="suffix" value=".jsp"/&gt; &lt;/bean&gt;&lt;!--释放静态资源，对静态资源使用原生态servlet--&gt;&lt;mvc:default-servlet-handler/&gt;&lt;!-- 配置放置静态资源的路径--&gt;&lt;!-- &lt;mvc:resources mapping="/resources/**" location="/resources/"/&gt;--&gt;&lt;/beans&gt; 5. web.xml 配置spring，使用listener,class为ContextLoaderListener,再使用Context-Param指定spring配置文件的位置 配置springMVC，使用servlet标签，class为DispatcherServlet,使用init-param初始化参数，使用load-on-start配置随服务器加载，最后再servlet-mapping设置需要拦截的请求，如*.action 配置解决中文的过滤器(filter)，class为：CharacterEncodingFilter,使用init-param初始化参数（参数名为encoding，值为utf-8） ,在filter-mapping里拦截所有请求（/*） classPath的使用 代码： web.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE web-app PUBLIC "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN" "http://java.sun.com/dtd/web-app_2_3.dtd" &gt;&lt;web-app&gt; &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt; &lt;!--配置spring--&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:ApplicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt;&lt;!-- 配置springMVC--&gt;&lt;servlet&gt; &lt;servlet-name&gt;Dispatchservlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springMVC.xml&lt;/param-value&gt; &lt;/init-param&gt;&lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;Dispatchservlet&lt;/servlet-name&gt; &lt;url-pattern&gt;*.action&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;!-- 配置解决中文乱码的过滤器--&gt; &lt;filter&gt; &lt;filter-name&gt;charactEncoding&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;charactEncoding&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt;]]></content>
      <categories>
        <category>学习经验</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>开发知识</tag>
        <tag>SSM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[int和Integer的区别]]></title>
    <url>%2F2019%2F07%2F06%2Fint%E5%92%8CInteger%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[int和Integer的区别 int是八大基本数据类型（byte，char，short，int，long，float，double，boolean）之一，而Integer是int 包装类，所以 int的默认值是0 Integer的默认值是null 在JDK1.5以后，Integer 有自动装箱和拆箱的语法糖。 自动装箱,假如写个Integer a： 其实为：Integer a=Integer.valueOf(int a); 自动拆箱，当涉及到计算时，如a+b： 其实为：a.intValue()+b.intValue(); Integer创建对象时，若数值在[-128,127]区间，第一次声明会将值放入缓存，第二次时会直接将上次缓存里的值给对象，所以地址不变，不是重新创建一个Ingeter 对象。 public static void main(String[] args) { Integer i = 10; Integer j = 10; System.out.println(i == j); }//结果为true 分析源码我们可以知道在 i &gt;= -128 并且 i &lt;= 127 的时候，第一次声明会将 i 的值放入缓存中，第二次直接取缓存里面的数据，而不是重新创建一个Ingeter 对象。 那么第一个打印结果因为 i = 10 在缓存表示范围内，所以为 true。 当值为128时，不放入缓存,会重新创建对象，地址变化: Integer i =128; Integer j = 128; System.out.println(i == j); }//结果为false 两个Integer对象比较时，使用equals 定义泛型时，必须使用Integer，而不是int，泛型参数必须是一个类，即Object的子类 Map&lt;String,Object&gt; map1 Map&lt;Integer,Object&gt; map2]]></content>
      <categories>
        <category>学习经验</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>开发知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSM+easyUI分页查询]]></title>
    <url>%2F2019%2F07%2F06%2F%E6%95%B0%E6%8D%AE%E5%88%86%E9%A1%B5%2F</url>
    <content type="text"><![CDATA[使用mybatis分页插件1. jar包和依赖： jsqlparser-0.9.5.jar（sql 解析工具） 123456&lt;!--sql 解析工具依赖,配合分页使用--&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.jsqlparser&lt;/groupId&gt; &lt;artifactId&gt;jsqlparser&lt;/artifactId&gt; &lt;version&gt;0.9.5&lt;/version&gt;&lt;/dependency&gt; pagehelper-5.1.2.jar 123456&lt;!--myBatis分页插件 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;5.1.2&lt;/version&gt;&lt;/dependency&gt; 2. spring配置文件ApplicatonContext.xml的sqlSessionFactory里配置一个载入插件的属性，名为plugins，用array来配置多个插件。 增加一个插件（拦截器），用标签 用bean，class为pagehelper的jar包中的PageInterceptor类。 此类中有个名为properties的属性，使用value对其赋值 value内填写：helperDialect=mysql（设置连接的是什么数据库,如mysql、Oracle） 如: 1234567891011121314 &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;property name="plugins"&gt; &lt;array&gt; &lt;bean class="com.github.pagehelper.PageInterceptor"&gt; &lt;property name="properties"&gt; &lt;value&gt; helperDialect=mysql &lt;/value&gt; &lt;/property&gt;&lt;/bean&gt; &lt;/array&gt; &lt;/property&gt; &lt;/bean&gt; 3. Controller在你需要进行分页的 MyBatis 查询方法前调用 PageHelper.startPage 静态方法即可，该方法需要两个参数pageNum、pageSize，紧跟在这个方法后的第一个MyBatis 查询方法会被进行分页。 12345678//request: url?pageNum=1&amp;pageSize=10//支持 ServletRequest,Map,POJO 对象，需要配合 params 参数PageHelper.startPage(request);//紧跟着的第一个select方法会被分页List&lt;Country&gt; list = countryMapper.selectIf(1);//后面的不会被分页，除非再次调用PageHelper.startPageList&lt;Country&gt; list2 = countryMapper.selectIf(null); 使用： 1234567891011121314151617181920 /** 使用pagehelper+PageInfo进行分页查询 *///private Map&lt;String,Object&gt; result= new HashMap&lt;String,Object&gt;(); @RequestMapping(value = "/selectBypage") @ResponseBody//将返回值转为json数据格式 public Map&lt;String,Object&gt; selectBypage(Integer page,Integer rows,HashMap&lt;String,Object&gt; map)&#123; //使紧跟其后的mybatis查询分页 PageHelper.startPage(page,rows); List&lt;Vocaloid&gt; vocaloidsBypage=vocaloidService.selectAll(); //将查询结果封装 PageInfo&lt;Vocaloid&gt; pageInfo=new PageInfo&lt;&gt;(vocaloidsBypage); long total = pageInfo.getTotal(); List&lt;Vocaloid&gt; list = pageInfo.getList(); map=new HashMap&lt;&gt;(); map.put("rows",list); map.put("total",total); //其实直接把查询结果vocaloidsBypage放到rows就可以了 return map; &#125; 4. 什么时候会导致不安全的分页？12345678//获取第1页，10条内容，默认查询总数countPageHelper.startPage(1, 10);List&lt;Country&gt; list;if(param1 != null)&#123; list = countryMapper.selectIf(param1);&#125; else &#123; list = new ArrayList&lt;Country&gt;();&#125; 这种情况下由于 param1 存在 null 的情况，就会导致 PageHelper 生产了一个分页参数，但是没有被消费，这个参数就会一直保留在这个线程上。当这个线程再次被使用时，就可能导致不该分页的方法去消费这个分页参数，这就产生了莫名其妙的分页。 上面这个代码，应该写成下面这个样子： 12345678List&lt;Country&gt; list;if(param1 != null)&#123; //获取第1页，10条内容，默认查询总数count PageHelper.startPage(1, 10); list = countryMapper.selectIf(param1);&#125; else &#123; list = new ArrayList&lt;Country&gt;();&#125; 这种写法就能保证安全。 5. 跳转页面过界如果你分页插件使用于类似分页查看列表式的数据，如新闻列表，软件列表， 你希望用户输入的页数不在合法范围（第一页到最后一页之外）时能够正确的响应到正确的结果页面， 那么你可以配置 reasonable 为 true，这时如果 pageNum&lt;=0 会查询第一页，如果 pageNum&gt;总页数 会查询最后一页。 1234567891011121314151617181920212223242526 &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;property name="mapperLocations"&gt; &lt;array&gt; &lt;value&gt;classpath:mapper/*.xml&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;property name="typeAliasesPackage" value="com.isea533.mybatis.model"/&gt; &lt;property name="plugins"&gt; &lt;array&gt; &lt;bean class="com.github.pagehelper.PageInterceptor"&gt; &lt;!-- 这里的几个配置主要演示如何使用，如果不理解，一定要去掉下面的配置 --&gt; &lt;property name="properties"&gt; &lt;value&gt; helperDialect=mysql reasonable=true supportMethodsArguments=true params=count=countSql autoRuntimeDialect=true &lt;/value&gt; &lt;/property&gt;&lt;/bean&gt; &lt;/array&gt; &lt;/property&gt; &lt;/bean&gt; 了解更多… 使用easyUI1. 启用easyui-datagrideasyui-datagrid下设置：pagination:true 显示分页菜单： 整体代码如： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!--数据网络--&gt;&lt;table id="vstable"&gt;&lt;/table&gt;&lt;script type="text/javascript" &gt; $(function () &#123; $("#vstable").datagrid(&#123; fitcolumns:true, url:"$&#123;pageContext.request.contextPath&#125;/vocaloidController/vSelectAll.action", columns:[[ &#123; field:"null", checkbox:true &#125;, &#123; field:"id", title:"ID", width:100 &#125;, &#123; field:"name", title:"Name", width:100 &#125;, &#123; field:"sex", title:"Sex", width:100 &#125;, &#123; field:"color", title:"Color", width:100 &#125;, &#123; field:"team_id", title:"Team_ID", width:100 &#125; ]], //显示分页栏 pagination:true, //工具条 toolbar:"#tb" &#125;); &#125;);&lt;/script&gt; 2. 参数解析easyUI会向后台发送两个参数,page和rows： 传参形式为： 而后台不仅需要给easyUI传递json格式的查询结果，而且还需要传递total和rows： 3. easyUI配合controller的增删改查 添加： Controller: 123456789101112131415@RequestMapping(value = "/InsertBypage")@ResponseBodypublic Map&lt;String,Object&gt; InsertBypage(Vocaloid vocaloid,HashMap&lt;String,Object&gt; map)&#123; boolean b = vocaloidService.insertOne(vocaloid); map=new HashMap&lt;&gt;(); System.out.println(b); if (b)&#123; map.put("success",b); return map; &#125;else&#123; map.put("success",b); return map; &#125;&#125; Service: 123456789101112131415 @Override public boolean insertOne(Vocaloid vocaloid) &#123; boolean b; //将插入成功的返回值设为true，异常的返回值为false try &#123; b = vocaloidMapper.insertOne(vocaloid); &#125;catch (Exception e)&#123; b=false; e.printStackTrace(); &#125;// int e=11/0;//异常测试 System.out.println("新增一行vocaloid,返回：" + b); return b; &#125; html&amp;Js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;%--easyUI按钮，增删改查工具条，iconCls是图标，plain:true是按钮3d感？--%&gt;&lt;div id="CRUDbutton"&gt; &lt;a id="addButton" href="#" class="easyui-linkbutton" data-options="iconCls:'icon-add'"&gt;添加&lt;/a&gt; &lt;a id="updateButton" href="#" class="easyui-linkbutton" data-options="iconCls:'icon-edit',plain:true"&gt;修改&lt;/a&gt; &lt;a id="deleteButton" href="#" class="easyui-linkbutton" data-options="iconCls:'icon-remove',plain:true"&gt;删除&lt;/a&gt;&lt;/div&gt;&lt;%--编辑窗口，默认关闭状态，用js控制打开--%&gt;&lt;%--div--%&gt;&lt;div id="Edit_window" class="easyui-window" title="客户数据编辑" style="width:500px;height:300px" data-options="modal:true,closed:true"&gt; &lt;form id="insertForm" method="post"&gt; &lt;label&gt;ID&lt;/label&gt;&lt;input type="text" name="id" class="easyui-validatebox" data-options="required:true"&gt;&lt;br&gt; &lt;label&gt;Name&lt;/label&gt;&lt;input type="text" name="name" class="easyui-validatebox"&gt;&lt;br&gt; &lt;label&gt;Sex&lt;/label&gt;&lt;input type="text" name="sex"&gt;&lt;br&gt; &lt;label&gt;Color&lt;/label&gt;&lt;input type="text" name="color"&gt;&lt;br&gt; &lt;label&gt;Team_ID&lt;/label&gt;&lt;input type="text" name="team_id"&gt;&lt;br&gt; &lt;a id="insert_Button" href="#" class="easyui-linkbutton"&gt;确定&lt;/a&gt; &lt;/form&gt;&lt;/div&gt;&lt;%--增加按钮的事件--%&gt;&lt;script type="text/javascript"&gt; $(function () &#123; // 点击“添加”按钮时，打开窗口 $("#addButton").click(function () &#123; //打开窗口前清空里面的表单 $("#insertForm").form("clear"); //打开窗口 $("#Edit_window").window("open") &#125;); //点击确定按钮（上面的a标签）触发controller和事件 $("#insert_Button").click(function () &#123; $("#insertForm").form( "submit", &#123;url:"$&#123;pageContext.request.contextPath&#125;/vocaloidController/InsertBypage.action", //success:服务器执行完毕回调函数 success:function(data)&#123; //data: 服务器返回的数据，类型字符串类，此时我在InsertBypage方法返回值里放入了success变量 //把data字符串类型转换对象类型 data = eval("("+data+")"); if (data.success) &#123; //关闭窗口 $("#Edit_window").window("close"); //刷新datagrid $("#vstable").datagrid("reload"); $.messager.alert("提示"+data.success,"增加成功"); &#125;else &#123; //关闭窗口 $("#Edit_window").window("close"); //刷新datagrid $("#vstable").datagrid("reload"); $.messager.alert("提示"+data.success+"增加失败：","可能是id重复"); &#125; &#125; &#125; ); &#125;); &#125;);&lt;/script&gt;]]></content>
      <categories>
        <category>学习经验</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>开发知识</tag>
        <tag>mybatis分页插件</tag>
        <tag>数据分页</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL Error记录]]></title>
    <url>%2F2019%2F07%2F05%2FMySQL-Error-2013%2F</url>
    <content type="text"><![CDATA[MySQL 提示：1. Lost connection to MySQL server at ‘waiting for initial communication packet’,system error:0 错误产生经过：昨天试加速器试用，改了硬件信息，隔天上午数据库运行正常，下午重启后mysql连接时就出错了。 解决方法： 找到mysql安装目录下的my.ini文件(我mysql安装目录是在D:\SP GAME),记事本打开my.ini, 找到[mysqld],在末尾添加一行： skip-name-resolve 记得保存。 在“计算机管理-服务和应用程序-服务”找到MySQL， 重启该服务。 2. Lost connection to MySQL server at ‘reading initial communication packet’, system error: 0 重启MySQL服务 3. 2059错误 Authentication plugin ‘caching_sha2_password’ cannot be loaded : *** 原因 mysql8 之前的版本中加密规则是mysql_native_password,而在mysql8之后,加密规则是caching_sha2_password 解决 12345678910mysql -uroot -ppassword #登录use mysql; #选择数据库# 远程连接请将'localhost'换成'%'ALTER USER 'root'@'localhost' IDENTIFIED BY '123456' PASSWORD EXPIRE NEVER; #更改加密方式ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY '123456'; #更新用户密码FLUSH PRIVILEGES; #刷新权限 Mysql2059错误 4. 1273错误 1273 - Unknown collation: ‘utf8mb4_0900_ai_ci’ 情景 将mysql8.0的结构数据转储为sql文件，然后在mysql5.6运行时报错。 原因 编码排序规则不同，不止数据库，还有每张表。 解决将sql文件内对应的编码排序规则，比如utf8mb4_0900_ai_ci，批量替换为mysql5.6能用的规则，比如utf8mb4_unicode_ci，然后再运行。 5. 1071 (42000) 错误 ERROR 1071 (42000): Specified key was too long; max key length is 767 bytes 情景 高版本数据库向低版本数据库迁移时，修改InnoDB表字段长度时出现了此错误。 原因 错误是指超出索引字节的限制，并不是指字段长度限制。文档： 如果启用了系统变量innodb_large_prefix（默认启用，注意实验版本为MySQL 5.6.41,默认是关闭的，MySQL 5.7默认开启），则对于使用DYNAMIC或COMPRESSED行格式的InnoDB表，索引键前缀限制为3072字节。如果禁用innodb_large_prefix，则对于任何行格式的表，索引键前缀限制为767字节。 innodb_large_prefix将在以后的版本中删除、弃用。在MySQL 5.5中引入了innodb_large_prefix，用来禁用大型前缀索引，以便与不支持大索引键前缀的早期版本的InnoDB兼容。 对于使用REDUNDANT或COMPACT行格式的InnoDB表，索引键前缀长度限制为767字节。例如，您可能会在TEXT或VARCHAR列上使用超过255个字符的列前缀索引达到此限制，假设为utf8mb3字符集，并且每个字符最多包含3个字节。 尝试使用超出限制的索引键前缀长度会返回错误。要避免复制配置中出现此类错误，请避免在主服务器上启用enableinnodb_large_prefix（如果无法在从服务器上启用）。 适用于索引键前缀的限制也适用于全列索引键。 解决 启用系统变量innodb_large_prefix，然后满足以下条件 1： 系统变量innodb_large_prefix为ON 2： 系统变量innodb_file_format为Barracuda 3： ROW_FORMAT为DYNAMIC或COMPRESSED 第3条为可选项，sql如下： 123set global innodb_large_prefix=on;set global innodb_file_format=Barracuda;ALTER TABLE TEST ROW_FORMAT=DYNAMIC; 参照ERROR 1074错误解决方式 6. 时区错误 Server returns invalid timezone. Go to ‘Advanced’ tab and set ‘serverTimezone’ property manually. 原因时区值无效 解决 12show variables like '%time_zone%';set global time_zone='+8:00';]]></content>
      <categories>
        <category>开发问题</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>mysql</tag>
        <tag>error</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JQuery EasyUI入门]]></title>
    <url>%2F2019%2F07%2F03%2FEasyUI%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[EasyUI入门使用简 介easyui是一种基于jQuery、Angular.、Vue和React的用户界面插件集合，可简单快速的搭建页面布局，方便后台人员制作简易的管理界面，节省网页开发的时间和规模，现在开始学习easyUI的jquery版本的入门使用。 引入资源文件在官网下载jQuery版的easyUI后，在项目的webapp中建立一个文件夹，用于存放easyUI的资源文件，如图所示： 分别选择themes、jquery.easyui.min.js和jquery.min.js，导入到项目中，如图所示： 新建html或jsp，在&lt; head&gt;里引用项目中的资源文件，如下所示： 1234567891011&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;easyUI.html-class&lt;/title&gt; &lt;link rel="stylesheet" type="text/css" href="easyUI/themes/default/easyui.css"&gt; &lt;link rel="stylesheet" type="text/css" href="easyUI/themes/icon.css"&gt; &lt;script type="text/javascript" src="easyUI/jquery.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="easyUI/jquery.easyui.min.js"&gt;&lt;/script&gt; &lt;!-- 新增 --&gt; &lt;script type="text/javascript" src="easyUI/locale/easyui-lang-zh_CN.js"&gt;&lt;/script&gt;&lt;/head&gt; 功能和使用1、树（tree）easyui-tree：树形菜单 效果如图： 使用： easyui-tree 、 .tree() 属性： checkbox：true（可开启复选框） 可直接在标签中用class=“easyui-tree”来使用，注意&lt; span&gt;标签，data-options中配置属性，多个属性之间用逗号隔开： 12345678&lt;ul class="easyui-tree" data-options="checkbox:true"&gt; &lt;li&gt;&lt;span&gt;菜单a&lt;/span&gt; &lt;ul &gt; &lt;li&gt;&lt;span&gt;菜单1&lt;/span&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt;&lt;span&gt;菜单b&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt; 推荐使用普通html标签+js的方式来实现。这样能处理更复杂的样式。 具体写法为在标签设置一个id或class，接下来在js写$(function(){ }),大括号中使用$(&quot;#id&quot;)或是class用$(&quot;.class&quot;)来指定对象。 接着对象后.tree();即可设置树应用到对象，关于.tree()里的属性的设置，直接在（）中使用｛｝大括号将属性包括即可，多个属性用逗号隔开，与data-options相同。 如 $(&quot;#uitree&quot;).tree( { checkbox:true ，... } ); ， 整体代码如下： 1234567891011121314151617&lt;%--树形菜单 可设置checkbox属性--%&gt; &lt;ul id="uitree"&gt; &lt;li&gt;&lt;span&gt;菜单a&lt;/span&gt; &lt;ul&gt; &lt;li&gt;&lt;span&gt;菜单a-1&lt;/span&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt;&lt;span&gt;菜单b&lt;/span&gt;&lt;/li&gt; &lt;/ul&gt; &lt;script type="text/javascript"&gt; $(function () &#123; $("#uitree").tree(&#123; checkbox:true &#125;); &#125;) &lt;/script&gt; .tree()应用tree功能，tree()的属性如checkbox设为true可开启选择框，部分其他功能用法与tree一样，非必要时不再赘述。 2、拖动和放置easyui-draggable：可拖动 easyui-droppable：可放置 效果如图： 使用： easyui-draggable 、 .draggable()；easyui-droppable 、 .droppable()； 拖动和放置两个功能，可同时作用于一个对象。 拖动 handle:&#39;&#39;#xxx&#39;（指定只有拖住’#xxx‘时，才可拖动整个div） proxy proxy:&#39;clone&#39;（拖动时创建复制的副本，拖动时拖动副本，松手时本体位置改变，副本消失） proxy:function(source){}（自定义一个副本） revert:true（拖动时松手，元素将返回原来位置） disabled:true（停用拖动）更多… 放置 accept:&quot;#xx1,#xx2&quot; （指定可放置的对象） disabled:true（停用可放置） onDrop:function (e, source) { $(this).append(source);}（将对象放置区域内部） 更多… class方式使用： 1234&lt;!--可拖动的div draggable, 在data-options将属性handle进行下例的设置，就可设置只有拖动id为title的div才会生效--&gt;&lt;div class="easyui-draggable" data-options="handle:'#title'" style="width: 200px;height: 100px;background-color: #00bbee"&gt; &lt;div id="title" style="width: auto;height: 20px"&gt;div的标题title&lt;/div&gt;&lt;/div&gt; JS方式（css+html+js代码如下）： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;%--拖动和放置div的CSS--%&gt; &lt;style type="text/css"&gt; .DDbox &#123; width: 700px; height: 200px; border: 1px solid black; &#125; #Div_draggable &#123; width: 300px; height: 100px; background-color: #00ee00; margin-right: 100px; border: 1px solid black; float: left; &#125; .content &#123; height: 20px; width: 100px; background-color: #00bbee; margin: 5px; &#125; #Div_droppable &#123; width: 200px; height: 100px; border: 1px solid black; float: left; &#125; &lt;/style&gt; &lt;%--可拖动div 可设置handle属性、proxy代理属性（clone或自定义新对象(传递一个function)）,revert设置为true可在鼠标释放时复原，其他也可设置拖拽范围--%&gt; &lt;div class="DDbox"&gt; &lt;div id="Div_draggable" &gt; &lt;div id="title" style="width: auto;height: 20px"&gt;拖拽我 才可拖动整个div &lt;/div&gt; &lt;div class="content" id="drag1"&gt;内容1&lt;/div&gt; &lt;div class="content" id="drag2"&gt;内容2&lt;/div&gt; &lt;div class="content" id="drag3"&gt;内容3&lt;/div&gt; &lt;/div&gt; &lt;%--与draggable组合，可放置元素的容器--%&gt; &lt;div id="Div_droppable"&gt; &lt;div id="title2" style="width: auto;height: 20px"&gt;可放置的容器&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;%--拖动和放置的js, 可拖动和可放置 能同时作用于同一个div--%&gt; &lt;script type="text/javascript"&gt; &lt;%-- （注意大小写） 左： 拖动--%&gt; $(function () &#123; $("#Div_draggable").draggable(&#123; handle:'#title',proxy:'clone' &#125;).droppable(&#123; onDrop:function (e,source) &#123; $(this).append(source); &#125; &#125;); $(".content").draggable(&#123; proxy:'clone',revert:true &#125;) &#125;); &lt;%--右： 放置 --%&gt; $(function () &#123; $("#Div_droppable").droppable(&#123; accept:"#drag1,#drag2", onDrop:function (e, source) &#123; $(this).append(source); &#125; &#125;).draggable(&#123; proxy:'clone',handle:'#title2' &#125;); &#125;) &lt;/script&gt; 3、调节尺寸easyui-resizable：可调节尺寸大小，注意单词是resizable ，不是resize，没有e。效果如图： 鼠标放置区域的边框上即可调节长宽。 【属性】（区分大小写，像素不用带px）： minWidth：最小宽度 minHeight：最小高度 maxWidth：最大宽度 maxHeight：最大高度 更多… 使用1： 123&lt;!--可缩放的div区域 resizable,有minWidth、minHeight、maxWidth等属性，注意像素直接写数字不要带px，逗号隔开--&gt;&lt;div class="easyui-resizable" data-options="minWidth:100,minHeight:100,maxWidth:500" style="border: solid;width: 100px;height: 150px"&gt;&lt;/div&gt; 使用2： 12345678910&lt;%--可缩放调整大小的div resizable--%&gt; &lt;div id="resize" style="height: 50px;width: 50px;border: solid"&gt;&lt;/div&gt; &lt;script type="text/javascript"&gt; $(function () &#123; $("#resize").resizable(&#123; minWidth:25,minHeight:25 &#125;) &#125;) &lt;/script&gt; 博主：(╯﹏╰)给自己挖个大坑，这样写太耗时间了，后面会有个easyUI实际运用的文章。]]></content>
      <categories>
        <category>学习经验</category>
      </categories>
      <tags>
        <tag>javaScript</tag>
        <tag>easyUI</tag>
        <tag>开发知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[宫泽贤治]]></title>
    <url>%2F2019%2F06%2F23%2F%E5%AE%AB%E6%B3%BD%E8%B4%A4%E6%B2%BB%2F</url>
    <content type="text"><![CDATA[童话作家所有人的童话宫泽贤治写的故事里，常常有会说话、会像人一样行走的动物（废话，因为是童话啊），虽说是童话，但有的故事我依然还没能看明白，比如为什么山猫会消失，黑熊为什么2年后死去？不过他的故事并不难读，有孩童能看到的结局，有大人能看懂的深意。记得作者在自序中写道： 因此，这些故事当中，也许有些会对您有益处，有的没有，关于这一点我自己也无法分辨其中的差别。其中有些部分，或许您读了会觉得一头雾水，其实我也不知道为什么会写出这些内容。 看到这段话时我不由笑起来，觉得作者坦白得可爱，让我想起了曾经高中的语文。 澄净透明的文字宫泽贤治的文字充满自然的气息，纯净又真挚，总是有着丰富的想象力，诗一样精致，绘出浪漫唯美的景象。就如同他在自序中所说： 我所写的故事，全都来自森林、原野、铁道线路、彩虹或月光。 《文少》中这样评价宫泽贤治的作品： 「贤治的作品是非常质朴的，散发着大地、风和阳光一样的香味，透明又真切，让人不禁产生一种怀念的感觉呢。就好比，在吹着爽朗的微风的田间，穿着沾着泥土的围裙，低着头作业的感觉——散发着青草的气味，有点酸，有点苦，又有点甜的感觉，在口中渐渐融开，喉咙也好像被滋润了一样。又像是用冰冷河水洗过的黄瓜味，像是嚼着生茄子般带着的新鲜和甜味，像是祭典的夜里喝下的橘子汽水——不光是贤治写下的故事，连他的行文方式，文章的节奏，甚至语言本身都有着独特的味道呢！」 银河铁道之夜 宫泽贤治写的童话有很多，作者也说过“其实我也不知道为什么会写出这些内容”。但我相信《银河铁道之夜》的每一个字都有其特别的用意。宫泽贤治在病床不断修改着《银河铁道之夜》的原稿，直到去世时也没有最终版本。 乔班尼才刚听见某处传来奇异的声音：”银河站——银河站——“ 眼前倏地一片亮光。仿佛数以亿万计的荧光鱿鱼瞬间成为化石，沉入天空； 这篇童话描述了一段在银河铁道上从北十字星站到南十字星站的旅途，一段神奇美丽的星星之旅，可却让读者在故事里感受到一种强烈的孤独。 乔班尼像子弹一样奋力起身。为了不让其他人听见，他将身子伸出窗外，接着激动地吼叫、用力的捶胸，最后失声痛苦。他的世界仿佛陷入一片黑暗。 志同道合的妹妹（宫泽登志|敏子）的病逝，是宫泽贤治创作《银河铁道之夜》的契机. 「有传闻说，乔班尼和柯贝内拉在现实中是有其原形的。内向又孤独的乔班尼就是贤治自己，而柯贝内拉的原形虽然有很多种不同的说法，但是最为大家接受的则是贤治的妹妹登志。 登志比贤治还要小两岁，在学校里也经常是第一名，是一个优等生。贤治一直都为登志感到非常自豪，登志也一直仰慕着自己的哥哥。两人的感情非常的好，就连登志去东京上学的时候，两人的信件也不曾间断过。十八岁的时候，因为法华经而深受感悟的贤治，和热心于净土真宗的父亲产生了深刻的对立。而登志却相信了那样的贤治，成了贤治以外家中唯一信仰法华经的人，一直在背后支持着贤治。对于贤治来说，登志不仅仅是他的妹妹，还是与他共有思想和世界观的唯一的存在吧。」 在贤治二十六岁的冬天，他如此喜爱着的妹妹登志，因为疾病而过世了……贤治把当时所受到的打击，在『永诀的早晨』、『松之针』、『无声恸哭』等几首诗中写了出来。那是连灵魂都流出鲜血，连声音都发不出来的绝望哀叫，让人觉得胸口也要崩溃了一样……然后，在失去了『唯一一个拥有相同信仰的同伴』之后的两年里，贤治写下了《银河铁道之夜》的初稿…… 他竭力去创作一个“能让所有人幸福”的乌托邦、一幅人类的“永恒世界”，并且自己为此“宁愿舍弃这一切的幸福”。失去亲伴的悲痛让他产生无比强烈的愿望、舍弃一切的冲动、生与死的思考，”蝎之火“、因沉船遇难的青年、主人公“乔班尼(Giovanni )”以及故事的另一个主人公“柯贝内拉(Campanella)”都能体现出作者自己的愿望。 宫泽贤治在诗歌《永诀之朝》中写道： 面对你所渴求的那两碗雪， 我衷心的祈祷着。 愿它变成上天的赐予， 为你和大家， 得到神圣的粮食 我宁愿舍弃这一切的幸福 到底大家真正的幸福是什么？这是《银河铁道之夜》中宫泽贤治对幸福的探究与心中的迷惘。乔班尼的幸福，是和最好的朋友“无论到哪里，我们都要一起去”，而柯贝内拉的幸福，仅是做好事，牺牲自己奉献他人吗？ 《文少》中这样提问： 「……你觉得柯贝内拉的愿望，是什么呢？」 乔班尼和柯贝内拉的愿望相互纠缠，或许他们是同一个人也说不定，而贤治和登志，谁是乔班尼，谁又是柯贝内拉呢，或许二者没有关联，但总能从这童话里看到他们模糊的影子。 诗人与作词家败北少年之歌(败れし少年の歌へる) 是咏叹宫泽贤治在海边看到破晓时分的景象的一首诗，改编自贤治在三陆旅行时写下的《对晓穹之嫉妒》，这首诗收录在《春与修罗》的第二集里。 如下： 闪耀在拂晓的星光 「 ひかりわななくあけぞらに 」犹如蓝宝石般散发着光芒 「 清丽サフィアのさまなして 」可与你相比的它 「 きみにたぐへるかの惑星(ほし)の 」给人即将消失于天空的悲伤 「 いま融け行くぞかなしけれ 」 覆盖在松柏上的白雪 「 雪をかぶれるびゃくしんや 」与无数的海峡被黎明点亮 「 百の海岬いま明けて 」一望无际的深蓝大海 「 あをうなばらは万叶の 」被悠远的曲调所吸引 「 古きしらべにひかれるを 」 夜晚被层层乌云覆盖 「 夜はあやしき积云の 」却从中闪耀出星星的光辉 「 なかより生れてかの星ぞ 」就如你那动人的语句 「 さながらきみのことばもて 」在我内心燃烧 「 われをこととひ燃えけるを 」 就如最美丽的宝石 「 よきロダイトのさまなして 」却在拂晓的天空中 「 ひかりわなゝくかのそらに 」慢慢消失 「 溶け行くとしてひるがへる 」正因为你是星星才更让人悲伤 「 きみが星こそかなしけれ 」 《败北少年之歌》名字有些奇怪，似乎与内容并没有什么关联。不过，读过后确实发现其中宁静的败北，可能真如文少中提及，是首失恋的诗吧。（结合贤治本人的恋爱经历，这难道是写妹妹的？嗯哼？[#破事水]） 看到《败北少年之歌》这样的标题的时，虽然会让人有一种心跳的感觉，但读过之后就会明白，其实诗里并非是对伤痛和绝望的悲叹，而是又宁静又美丽的诗喔。遥望群星渐渐消失，远方天际缓缓发白，还带着一种悲伤的感觉……也有人说这是首失恋的诗歌。 不畏风雨(雨ニモマケズ) 大学毕业后，宫泽贤治任教四年，做农业指导，后来却辞职务农，离家在郊外独居，过着普通农民生活，乐在其中。 《文少》中关于宫泽贤治务农的介绍： 宫泽贤治是1896年出生在岩手县的诗人和童话作家。而且，他还有着农业指导家的身份，不仅开发了新的肥料，还经常在农村指导农民科学的农业和种植方法，又引进了当时岩手很少看到的郁金香、花椰菜、土豆等新品种。而且他还自学了风琴和大提琴，在当地举办一些演奏会，为当地文化的兴盛而努力着。 诗歌内容： 不怕风 不怕雨 不畏寒冬酷暑 总有强健的体魄 没有欲望 不生气 一直静静地笑着 每天只吃一些糙米、酱汤以及少于的蔬菜 对于包括自己在内的任何事情都无动于衷 耳闻目睹就已足够 然后不会忘记 在山野的松树林下的树荫里的小茅草屋里 就已足够安身 假若东边有生病的孩子 我便会前去看望 西边人家的母亲因干活而劳累 我会上前帮她背着成捆的稻草 南边若要有垂死之人 我便会给他说不用害怕 假若北边居住的人发生争执 我便会耐心劝解他们 太阳高照，大旱成灾时我会因此而伤心落泪 在酷暑炎夏里遇见寒潮我会因此而心急如焚 大家都叫我傻瓜 可我却不求赞扬 也不会将苦恼挂在心头 我想成为这样的人 永诀之朝(永诀の朝) 妹妹冬日病逝，这应当是宫泽贤治一生最痛苦的事情，他在这之后的1922年，写下了《永诀之朝》。 诗歌的部分如下： 我小心翼翼地站在那上面， 保持着雪与水那纯洁的联系， 满载着透明的冰冷安静的雪水， 从这闪烁着残微光亮的脆嫩松枝上， 为我那心爱的善良美好的妹妹取下那最后的渴求。 在伴随着我们一起长大的岁月里， 早已熟悉了这陶瓷碗上的蓝色花纹。 如是今朝却也要与你永诀， （我将独自前行） 在那封闭了的病房里， 在那昏暗的屏风和帐子里， 你正面色苍白温情脉脉地燃尽着生命 这首诗歌有些长，详见百度百科：永诀の朝 巡星之歌(星めぐりの歌) *星めぐりの歌 *(ほしめぐりのうた)是宫泽贤治创作的一首童谣，由宫泽贤治作词作曲，歌曲描绘在银河遨游看到的景色，星座与星座之间构成的美丽图画，在其作品《双子之星》和《银河铁路之夜》有出现，现在也常在各种影像作品中被引用。这首歌我最早在《星之梦》中就有所接触，虽说是个Galgame，当时并不知道宫泽贤治，也没读过《银河铁道之夜》。 *歌词如下：* あかいめだまの さそり 天蝎闪烁著红眼睛（天蝎座 Scorpio） ひろげた鷲の つばさ 天鹰展翅翱翔天际（天鹰座 Aquila） あをいめだまの 小いぬ、 小犬眨著蓝色眼眸（小犬座 Canis Minor） ひかりのへびの とぐろ。 蜷曲巨蛇隐隐透出光芒（蛇夫座 Ophiuchus） オリオンは高く うたひ 当猎户在天上高声歌唱时（猎户座 Orion） つゆとしもとを おとす、 地上便降下了露水和冰霜（猎户座的最佳观测时间在冬季） アンドロメダの くもは 仙女座中的云气（仙女座 Andromedae） さかなのくちの かたち。 宛如鱼的嘴形（仙女座大星云，椭圆形螺旋星云） 大ぐまのあしを きたに 从大熊前脚向北（大熊座 Ursae Majoris） 五つのばした ところ。 延伸五倍之处 小熊のひたいの うへは 在那小熊额顶（小熊座 Ursa Minor） そらのめぐりの めあて。 正是巡星游天的枢轴（北极星 Polaris） 宫泽贤治​ 宫泽贤治生前埋头文学，可写的童话无人问津，死后却声名显赫，这不禁让人联想到同样遭遇的梵高。他生前创作了94篇童话和一千多首诗歌，可只有《渡雪原》获得过稿费，出版的童话集《要求很多的餐馆》和诗歌集《春与修罗》还是自费出版的，并且沒卖出几本，贤治自己不忍心，向父亲借钱，自掏腰包买了两百本自己的书 ​ 关于贤治死后的成功，就要归功于弟弟宫泽清六的推动，弟弟与诗人草野心平等人编写了《追悼宫泽贤治》一书，并全部由宫泽家出资，将书出版，之后宫泽贤治的作品才被文坛所重视，引起世人瞩目。 ​ “父亲啊父亲，您为何故意要在舍监面前转动那块银表的发条呢？”，宫泽贤治身为富家子弟，却十分不满自家对穷人的剥削，身为长子，却并不想顺从父亲的意愿继承家业，虽说如此，父亲依然是他生前支持他文学创作的“出资人”。 ​ 大学毕业后就开始任教指导农民科学种田,之后又辞职务农，边与大自然接触边写童话诗歌，其实贤治早在盛冈高等农林学校读大三时便到岩手县种山平原进行过地质考察。当时贤治刚和朋友们一起创办了同人志『杜鹃花』，满怀着对与未来的理想和希望，每天都过着充实的生活。在这个人生最幸福的时期里感受到的美丽大自然，深深地印刻在贤治的心底，在贤治以后的作品中，也能看到很多与种山平原相关的痕迹。也有种说法，《银河铁道之夜》的星空便出自这个地方。 ​ 贤治一生未娶，高中时曾要与一名同年龄的护士结婚，被父亲拒绝，后又对大学同学以及妹妹敏子有疑似恋爱的情结，三十岁后拒绝女方两次，三十七岁因肺病早逝。]]></content>
      <categories>
        <category>闲谈</category>
      </categories>
      <tags>
        <tag>银河铁道之夜</tag>
        <tag>宫泽贤治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown练习（html版）]]></title>
    <url>%2F2019%2F06%2F13%2Fmarkdown%E8%AF%AD%E6%B3%95%E7%BB%83%E4%B9%A02%2F</url>
    <content type="text"><![CDATA[markdown语法练习html {overflow-x: initial !important;}:root { --bg-color:#ffffff; --text-color:#333333; --select-text-bg-color:#B5D6FC; --select-text-font-color:auto; --monospace:"Lucida Console",Consolas,"Courier",monospace; } html { font-size: 14px; background-color: var(--bg-color); color: var(--text-color); font-family: "Helvetica Neue", Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; } body { margin: 0px; padding: 0px; height: auto; bottom: 0px; top: 0px; left: 0px; right: 0px; font-size: 1rem; line-height: 1.42857; overflow-x: hidden; background: inherit; tab-size: 4; } iframe { margin: auto; } a.url { word-break: break-all; } a:active, a:hover { outline: 0px; } .in-text-selection, ::selection { text-shadow: none; background: var(--select-text-bg-color); color: var(--select-text-font-color); } #write { margin: 0px auto; height: auto; width: inherit; word-break: normal; word-wrap: break-word; position: relative; white-space: normal; overflow-x: visible; padding-top: 40px; } #write.first-line-indent p { text-indent: 2em; } #write.first-line-indent li p, #write.first-line-indent p * { text-indent: 0px; } #write.first-line-indent li { margin-left: 2em; } .for-image #write { padding-left: 8px; padding-right: 8px; } body.typora-export { padding-left: 30px; padding-right: 30px; } .typora-export .footnote-line, .typora-export li, .typora-export p { white-space: pre-wrap; } @media screen and (max-width: 500px) { body.typora-export { padding-left: 0px; padding-right: 0px; } #write { padding-left: 20px; padding-right: 20px; } .CodeMirror-sizer { margin-left: 0px !important; } .CodeMirror-gutters { display: none !important; } } #write li > figure:first-child { margin-top: -20px; } #write ol, #write ul { position: relative; } img { max-width: 100%; vertical-align: middle; } button, input, select, textarea { color: inherit; font-style: inherit; font-variant: inherit; font-weight: inherit; font-stretch: inherit; font-size: inherit; line-height: inherit; font-family: inherit; } input[type="checkbox"], input[type="radio"] { line-height: normal; padding: 0px; } *, ::after, ::before { box-sizing: border-box; } #write h1, #write h2, #write h3, #write h4, #write h5, #write h6, #write p, #write pre { width: inherit; } #write h1, #write h2, #write h3, #write h4, #write h5, #write h6, #write p { position: relative; } h1, h2, h3, h4, h5, h6 { break-after: avoid-page; break-inside: avoid; orphans: 2; } p { orphans: 4; } h1 { font-size: 2rem; } h2 { font-size: 1.8rem; } h3 { font-size: 1.6rem; } h4 { font-size: 1.4rem; } h5 { font-size: 1.2rem; } h6 { font-size: 1rem; } .md-math-block, .md-rawblock, h1, h2, h3, h4, h5, h6, p { margin-top: 1rem; margin-bottom: 1rem; } .hidden { display: none; } .md-blockmeta { color: rgb(204, 204, 204); font-weight: 700; font-style: italic; } a { cursor: pointer; } sup.md-footnote { padding: 2px 4px; background-color: rgba(238, 238, 238, 0.7); color: rgb(85, 85, 85); border-radius: 4px; cursor: pointer; } sup.md-footnote a, sup.md-footnote a:hover { color: inherit; text-transform: inherit; text-decoration: inherit; } #write input[type="checkbox"] { cursor: pointer; width: inherit; height: inherit; } figure { overflow-x: auto; margin: 1.2em 0px; max-width: calc(100% + 16px); padding: 0px; } figure > table { margin: 0px !important; } tr { break-inside: avoid; break-after: auto; } thead { display: table-header-group; } table { border-collapse: collapse; border-spacing: 0px; width: 100%; overflow: auto; break-inside: auto; text-align: left; } table.md-table td { min-width: 32px; } .CodeMirror-gutters { border-right: 0px; background-color: inherit; } .CodeMirror-linenumber { user-select: none; } .CodeMirror { text-align: left; } .CodeMirror-placeholder { opacity: 0.3; } .CodeMirror pre { padding: 0px 4px; } .CodeMirror-lines { padding: 0px; } div.hr:focus { cursor: none; } #write pre { white-space: pre-wrap; } #write.fences-no-line-wrapping pre { white-space: pre; } #write pre.ty-contain-cm { white-space: normal; } .CodeMirror-gutters { margin-right: 4px; } .md-fences { font-size: 0.9rem; display: block; break-inside: avoid; text-align: left; overflow: visible; white-space: pre; background: inherit; position: relative !important; } .md-diagram-panel { width: 100%; margin-top: 10px; text-align: center; padding-top: 0px; padding-bottom: 8px; overflow-x: auto; } #write .md-fences.mock-cm { white-space: pre-wrap; } .md-fences.md-fences-with-lineno { padding-left: 0px; } #write.fences-no-line-wrapping .md-fences.mock-cm { white-space: pre; overflow-x: auto; } .md-fences.mock-cm.md-fences-with-lineno { padding-left: 8px; } .CodeMirror-line, twitterwidget { break-inside: avoid; } .footnotes { opacity: 0.8; font-size: 0.9rem; margin-top: 1em; margin-bottom: 1em; } .footnotes + .footnotes { margin-top: 0px; } .md-reset { margin: 0px; padding: 0px; border: 0px; outline: 0px; vertical-align: top; background: 0px 0px; text-decoration: none; text-shadow: none; float: none; position: static; width: auto; height: auto; white-space: nowrap; cursor: inherit; -webkit-tap-highlight-color: transparent; line-height: normal; font-weight: 400; text-align: left; box-sizing: content-box; direction: ltr; } li div { padding-top: 0px; } blockquote { margin: 1rem 0px; } li .mathjax-block, li p { margin: 0.5rem 0px; } li { margin: 0px; position: relative; } blockquote > :last-child { margin-bottom: 0px; } blockquote > :first-child, li > :first-child { margin-top: 0px; } .footnotes-area { color: rgb(136, 136, 136); margin-top: 0.714rem; padding-bottom: 0.143rem; white-space: normal; } #write .footnote-line { white-space: pre-wrap; } @media print { body, html { border: 1px solid transparent; height: 99%; break-after: avoid; break-before: avoid; } #write { margin-top: 0px; padding-top: 0px; border-color: transparent !important; } .typora-export * { -webkit-print-color-adjust: exact; } html.blink-to-pdf { font-size: 13px; } .typora-export #write { padding-left: 32px; padding-right: 32px; padding-bottom: 0px; break-after: avoid; } .typora-export #write::after { height: 0px; } @page { margin: 20mm 0px; } } .footnote-line { margin-top: 0.714em; font-size: 0.7em; } a img, img a { cursor: pointer; } pre.md-meta-block { font-size: 0.8rem; min-height: 0.8rem; white-space: pre-wrap; background: rgb(204, 204, 204); display: block; overflow-x: hidden; } p > .md-image:only-child:not(.md-img-error) img, p > img:only-child { display: block; margin: auto; } p > .md-image:only-child { display: inline-block; width: 100%; } #write .MathJax_Display { margin: 0.8em 0px 0px; } .md-math-block { width: 100%; } .md-math-block:not(:empty)::after { display: none; } [contenteditable="true"]:active, [contenteditable="true"]:focus { outline: 0px; box-shadow: none; } .md-task-list-item { position: relative; list-style-type: none; } .task-list-item.md-task-list-item { padding-left: 0px; } .md-task-list-item > input { position: absolute; top: 0px; left: 0px; margin-left: -1.2em; margin-top: calc(1em - 10px); border: none; } .math { font-size: 1rem; } .md-toc { min-height: 3.58rem; position: relative; font-size: 0.9rem; border-radius: 10px; } .md-toc-content { position: relative; margin-left: 0px; } .md-toc-content::after, .md-toc::after { display: none; } .md-toc-item { display: block; color: rgb(65, 131, 196); } .md-toc-item a { text-decoration: none; } .md-toc-inner:hover { text-decoration: underline; } .md-toc-inner { display: inline-block; cursor: pointer; } .md-toc-h1 .md-toc-inner { margin-left: 0px; font-weight: 700; } .md-toc-h2 .md-toc-inner { margin-left: 2em; } .md-toc-h3 .md-toc-inner { margin-left: 4em; } .md-toc-h4 .md-toc-inner { margin-left: 6em; } .md-toc-h5 .md-toc-inner { margin-left: 8em; } .md-toc-h6 .md-toc-inner { margin-left: 10em; } @media screen and (max-width: 48em) { .md-toc-h3 .md-toc-inner { margin-left: 3.5em; } .md-toc-h4 .md-toc-inner { margin-left: 5em; } .md-toc-h5 .md-toc-inner { margin-left: 6.5em; } .md-toc-h6 .md-toc-inner { margin-left: 8em; } } a.md-toc-inner { font-size: inherit; font-style: inherit; font-weight: inherit; line-height: inherit; } .footnote-line a:not(.reversefootnote) { color: inherit; } .md-attr { display: none; } .md-fn-count::after { content: "."; } code, pre, samp, tt { font-family: var(--monospace); } kbd { margin: 0px 0.1em; padding: 0.1em 0.6em; font-size: 0.8em; color: rgb(36, 39, 41); background: rgb(255, 255, 255); border: 1px solid rgb(173, 179, 185); border-radius: 3px; box-shadow: rgba(12, 13, 14, 0.2) 0px 1px 0px, rgb(255, 255, 255) 0px 0px 0px 2px inset; white-space: nowrap; vertical-align: middle; } .md-comment { color: rgb(162, 127, 3); opacity: 0.8; font-family: var(--monospace); } code { text-align: left; vertical-align: initial; } a.md-print-anchor { white-space: pre !important; border-width: initial !important; border-style: none !important; border-color: initial !important; display: inline-block !important; position: absolute !important; width: 1px !important; right: 0px !important; outline: 0px !important; background: 0px 0px !important; text-decoration: initial !important; text-shadow: initial !important; } .md-inline-math .MathJax_SVG .noError { display: none !important; } .html-for-mac .inline-math-svg .MathJax_SVG { vertical-align: 0.2px; } .md-math-block .MathJax_SVG_Display { text-align: center; margin: 0px; position: relative; text-indent: 0px; max-width: none; max-height: none; min-height: 0px; min-width: 100%; width: auto; overflow-y: hidden; display: block !important; } .MathJax_SVG_Display, .md-inline-math .MathJax_SVG_Display { width: auto; margin: inherit; display: inline-block !important; } .MathJax_SVG .MJX-monospace { font-family: var(--monospace); } .MathJax_SVG .MJX-sans-serif { font-family: sans-serif; } .MathJax_SVG { display: inline; font-style: normal; font-weight: 400; line-height: normal; zoom: 90%; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; } .MathJax_SVG * { transition: none; } .MathJax_SVG_Display svg { vertical-align: middle !important; margin-bottom: 0px !important; } .os-windows.monocolor-emoji .md-emoji { font-family: "Segoe UI Symbol", sans-serif; } .md-diagram-panel > svg { max-width: 100%; } [lang="mermaid"] svg, [lang="flow"] svg { max-width: 100%; } [lang="mermaid"] .node text { font-size: 1rem; } table tr th { border-bottom: 0px; } video { max-width: 100%; display: block; margin: 0px auto; } iframe { max-width: 100%; width: 100%; border: none; } .highlight td, .highlight tr { border: 0px; } .CodeMirror { height: auto; } .CodeMirror.cm-s-inner { background: inherit; } .CodeMirror-scroll { overflow-y: hidden; overflow-x: auto; z-index: 3; } .CodeMirror-gutter-filler, .CodeMirror-scrollbar-filler { background-color: rgb(255, 255, 255); } .CodeMirror-gutters { border-right: 1px solid rgb(221, 221, 221); background: inherit; white-space: nowrap; } .CodeMirror-linenumber { padding: 0px 3px 0px 5px; text-align: right; color: rgb(153, 153, 153); } .cm-s-inner .cm-keyword { color: rgb(119, 0, 136); } .cm-s-inner .cm-atom, .cm-s-inner.cm-atom { color: rgb(34, 17, 153); } .cm-s-inner .cm-number { color: rgb(17, 102, 68); } .cm-s-inner .cm-def { color: rgb(0, 0, 255); } .cm-s-inner .cm-variable { color: rgb(0, 0, 0); } .cm-s-inner .cm-variable-2 { color: rgb(0, 85, 170); } .cm-s-inner .cm-variable-3 { color: rgb(0, 136, 85); } .cm-s-inner .cm-string { color: rgb(170, 17, 17); } .cm-s-inner .cm-property { color: rgb(0, 0, 0); } .cm-s-inner .cm-operator { color: rgb(152, 26, 26); } .cm-s-inner .cm-comment, .cm-s-inner.cm-comment { color: rgb(170, 85, 0); } .cm-s-inner .cm-string-2 { color: rgb(255, 85, 0); } .cm-s-inner .cm-meta { color: rgb(85, 85, 85); } .cm-s-inner .cm-qualifier { color: rgb(85, 85, 85); } .cm-s-inner .cm-builtin { color: rgb(51, 0, 170); } .cm-s-inner .cm-bracket { color: rgb(153, 153, 119); } .cm-s-inner .cm-tag { color: rgb(17, 119, 0); } .cm-s-inner .cm-attribute { color: rgb(0, 0, 204); } .cm-s-inner .cm-header, .cm-s-inner.cm-header { color: rgb(0, 0, 255); } .cm-s-inner .cm-quote, .cm-s-inner.cm-quote { color: rgb(0, 153, 0); } .cm-s-inner .cm-hr, .cm-s-inner.cm-hr { color: rgb(153, 153, 153); } .cm-s-inner .cm-link, .cm-s-inner.cm-link { color: rgb(0, 0, 204); } .cm-negative { color: rgb(221, 68, 68); } .cm-positive { color: rgb(34, 153, 34); } .cm-header, .cm-strong { font-weight: 700; } .cm-del { text-decoration: line-through; } .cm-em { font-style: italic; } .cm-link { text-decoration: underline; } .cm-error { color: red; } .cm-invalidchar { color: red; } .cm-constant { color: rgb(38, 139, 210); } .cm-defined { color: rgb(181, 137, 0); } div.CodeMirror span.CodeMirror-matchingbracket { color: rgb(0, 255, 0); } div.CodeMirror span.CodeMirror-nonmatchingbracket { color: rgb(255, 34, 34); } .cm-s-inner .CodeMirror-activeline-background { background: inherit; } .CodeMirror { position: relative; overflow: hidden; } .CodeMirror-scroll { height: 100%; outline: 0px; position: relative; box-sizing: content-box; background: inherit; } .CodeMirror-sizer { position: relative; } .CodeMirror-gutter-filler, .CodeMirror-hscrollbar, .CodeMirror-scrollbar-filler, .CodeMirror-vscrollbar { position: absolute; z-index: 6; display: none; } .CodeMirror-vscrollbar { right: 0px; top: 0px; overflow: hidden; } .CodeMirror-hscrollbar { bottom: 0px; left: 0px; overflow: hidden; } .CodeMirror-scrollbar-filler { right: 0px; bottom: 0px; } .CodeMirror-gutter-filler { left: 0px; bottom: 0px; } .CodeMirror-gutters { position: absolute; left: 0px; top: 0px; padding-bottom: 30px; z-index: 3; } .CodeMirror-gutter { white-space: normal; height: 100%; box-sizing: content-box; padding-bottom: 30px; margin-bottom: -32px; display: inline-block; } .CodeMirror-gutter-wrapper { position: absolute; z-index: 4; background: 0px 0px !important; border: none !important; } .CodeMirror-gutter-background { position: absolute; top: 0px; bottom: 0px; z-index: 4; } .CodeMirror-gutter-elt { position: absolute; cursor: default; z-index: 4; } .CodeMirror-lines { cursor: text; } .CodeMirror pre { border-radius: 0px; border-width: 0px; background: 0px 0px; font-family: inherit; font-size: inherit; margin: 0px; white-space: pre; word-wrap: normal; color: inherit; z-index: 2; position: relative; overflow: visible; } .CodeMirror-wrap pre { word-wrap: break-word; white-space: pre-wrap; word-break: normal; } .CodeMirror-code pre { border-right: 30px solid transparent; width: fit-content; } .CodeMirror-wrap .CodeMirror-code pre { border-right: none; width: auto; } .CodeMirror-linebackground { position: absolute; left: 0px; right: 0px; top: 0px; bottom: 0px; z-index: 0; } .CodeMirror-linewidget { position: relative; z-index: 2; overflow: auto; } .CodeMirror-wrap .CodeMirror-scroll { overflow-x: hidden; } .CodeMirror-measure { position: absolute; width: 100%; height: 0px; overflow: hidden; visibility: hidden; } .CodeMirror-measure pre { position: static; } .CodeMirror div.CodeMirror-cursor { position: absolute; visibility: hidden; border-right: none; width: 0px; } .CodeMirror div.CodeMirror-cursor { visibility: hidden; } .CodeMirror-focused div.CodeMirror-cursor { visibility: inherit; } .cm-searching { background: rgba(255, 255, 0, 0.4); } @media print { .CodeMirror div.CodeMirror-cursor { visibility: hidden; } } :root { --side-bar-bg-color: #fafafa; --control-text-color: #777; } html { font-size: 16px; } body { font-family: "Open Sans", "Clear Sans", "Helvetica Neue", Helvetica, Arial, sans-serif; color: rgb(51, 51, 51); line-height: 1.6; } #write { max-width: 860px; margin: 0px auto; padding: 30px 30px 100px; } #write > ul:first-child, #write > ol:first-child { margin-top: 30px; } a { color: rgb(65, 131, 196); } h1, h2, h3, h4, h5, h6 { position: relative; margin-top: 1rem; margin-bottom: 1rem; font-weight: bold; line-height: 1.4; cursor: text; } h1:hover a.anchor, h2:hover a.anchor, h3:hover a.anchor, h4:hover a.anchor, h5:hover a.anchor, h6:hover a.anchor { text-decoration: none; } h1 tt, h1 code { font-size: inherit; } h2 tt, h2 code { font-size: inherit; } h3 tt, h3 code { font-size: inherit; } h4 tt, h4 code { font-size: inherit; } h5 tt, h5 code { font-size: inherit; } h6 tt, h6 code { font-size: inherit; } h1 { padding-bottom: 0.3em; font-size: 2.25em; line-height: 1.2; border-bottom: 1px solid rgb(238, 238, 238); } h2 { padding-bottom: 0.3em; font-size: 1.75em; line-height: 1.225; border-bottom: 1px solid rgb(238, 238, 238); } h3 { font-size: 1.5em; line-height: 1.43; } h4 { font-size: 1.25em; } h5 { font-size: 1em; } h6 { font-size: 1em; color: rgb(119, 119, 119); } p, blockquote, ul, ol, dl, table { margin: 0.8em 0px; } li > ol, li > ul { margin: 0px; } hr { height: 2px; padding: 0px; margin: 16px 0px; background-color: rgb(231, 231, 231); border: 0px none; overflow: hidden; box-sizing: content-box; } li p.first { display: inline-block; } ul, ol { padding-left: 30px; } ul:first-child, ol:first-child { margin-top: 0px; } ul:last-child, ol:last-child { margin-bottom: 0px; } blockquote { border-left: 4px solid rgb(223, 226, 229); padding: 0px 15px; color: rgb(119, 119, 119); } blockquote blockquote { padding-right: 0px; } table { padding: 0px; word-break: initial; } table tr { border-top: 1px solid rgb(223, 226, 229); margin: 0px; padding: 0px; } table tr:nth-child(2n), thead { background-color: rgb(248, 248, 248); } table tr th { font-weight: bold; border-width: 1px 1px 0px; border-top-style: solid; border-right-style: solid; border-left-style: solid; border-top-color: rgb(223, 226, 229); border-right-color: rgb(223, 226, 229); border-left-color: rgb(223, 226, 229); border-image: initial; border-bottom-style: initial; border-bottom-color: initial; text-align: left; margin: 0px; padding: 6px 13px; } table tr td { border: 1px solid rgb(223, 226, 229); text-align: left; margin: 0px; padding: 6px 13px; } table tr th:first-child, table tr td:first-child { margin-top: 0px; } table tr th:last-child, table tr td:last-child { margin-bottom: 0px; } .CodeMirror-lines { padding-left: 4px; } .code-tooltip { box-shadow: rgba(0, 28, 36, 0.3) 0px 1px 1px 0px; border-top: 1px solid rgb(238, 242, 242); } .md-fences, code, tt { border: 1px solid rgb(231, 234, 237); background-color: rgb(248, 248, 248); border-radius: 3px; padding: 2px 4px 0px; font-size: 0.9em; } code { background-color: rgb(243, 244, 244); padding: 0px 2px; } .md-fences { margin-bottom: 15px; margin-top: 15px; padding-top: 8px; padding-bottom: 6px; } .md-task-list-item > input { margin-left: -1.3em; } @media print { html { font-size: 13px; } table, pre { break-inside: avoid; } pre { word-wrap: break-word; } } .md-fences { background-color: rgb(248, 248, 248); } #write pre.md-meta-block { padding: 1rem; font-size: 85%; line-height: 1.45; background-color: rgb(247, 247, 247); border: 0px; border-radius: 3px; color: rgb(119, 119, 119); margin-top: 0px !important; } .mathjax-block > .code-tooltip { bottom: 0.375rem; } .md-mathjax-midline { background: rgb(250, 250, 250); } #write > h3.md-focus::before { left: -1.5625rem; top: 0.375rem; } #write > h4.md-focus::before { left: -1.5625rem; top: 0.285714rem; } #write > h5.md-focus::before { left: -1.5625rem; top: 0.285714rem; } #write > h6.md-focus::before { left: -1.5625rem; top: 0.285714rem; } .md-image > .md-meta { border-radius: 3px; padding: 2px 0px 0px 4px; font-size: 0.9em; color: inherit; } .md-tag { color: rgb(167, 167, 167); opacity: 1; } .md-toc { margin-top: 20px; padding-bottom: 20px; } .sidebar-tabs { border-bottom: none; } #typora-quick-open { border: 1px solid rgb(221, 221, 221); background-color: rgb(248, 248, 248); } #typora-quick-open-item { background-color: rgb(250, 250, 250); border-color: rgb(254, 254, 254) rgb(229, 229, 229) rgb(229, 229, 229) rgb(238, 238, 238); border-style: solid; border-width: 1px; } .on-focus-mode blockquote { border-left-color: rgba(85, 85, 85, 0.12); } header, .context-menu, .megamenu-content, footer { font-family: "Segoe UI", Arial, sans-serif; } .file-node-content:hover .file-node-icon, .file-node-content:hover .file-node-open-state { visibility: visible; } .mac-seamless-mode #typora-sidebar { background-color: var(--side-bar-bg-color); } .md-lang { color: rgb(180, 101, 77); } .html-for-mac .context-menu { --item-hover-bg-color: #E6F0FE; } #md-notification .btn { border: 0px; } .dropdown-menu .divider { border-color: rgb(229, 229, 229); } .typora-export li, .typora-export p, .typora-export, .footnote-line {white-space: normal;} 学生目录：Markdown一二三四与 五六七八九十1. 引文、注释2. 链接3. 图片4. 简单表格5.高亮、顔色等6. 列表、代码块前往我的Blog首页↩&nbsp;一二三四与 五六七八九十&nbsp;1. 引文、注释「拉威福特的《因斯茅斯上空的阴影》1尝起来，就像是在啜饮生鱼血一样呢~」（啦啦啦啦啦啦啦啦啦啦啦哇哈哈哈哈哈哈）&nbsp;&nbsp;2. 链接百度百科: 拉威福特详情&nbsp;3. 图片&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;4. 简单表格&nbsp;快捷键功能Ctrl+C复制Ctrl+X剪切Ctrl+V粘贴&nbsp;5.高亮、顔色等&nbsp;「关于作者霍华德·菲利普·拉威福特，他是1890年生的美国作家，他在世时曾经写下了许多关于太古诸神复活的故事，这些故事在他去世以后被体系化，最终形成了所谓的『克苏鲁神话体系』。自那以来，有很多作家被这种阴暗凄惨的黑暗神话所吸引，以克苏鲁为主题写下了不计其数的文章呢。在故事中登场的诸神，都是长相奇怪的海洋生物，长着触手、鱼鳍啊什么的，散发着生腥味。」&nbsp;6. 列表、代码块&nbsp;html jsjavapython等等xxxxxxxxxx41&lt;span class="post-meta-item-text"&gt;评论数：2 &lt;a href="/2019/06/13/markdown练习/#comments" itemprop="discussionUrl"&gt;3 &lt;/a&gt;4 &lt;/span&gt;&nbsp;前往我的Blog首页↩&nbsp; 1 拉威福特，全名H. P. Lovecraft，1890-1937，恐怖小说作家，《因斯茅斯上空的阴影》（The Shadow Over Innsmouth），为其代表作之一。↩]]></content>
      <categories>
        <category>学习经验</category>
      </categories>
      <tags>
        <tag>-markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Yahoo~!]]></title>
    <url>%2F2019%2F06%2F11%2FYahoo%2F</url>
    <content type="text"><![CDATA[域名&amp;..第一个公网访问的博客改造ing，是基于nodejs的一个网站，用来记一些东西吧，也方便查看。外观风格想做简约可又喜欢乱加东西，搞得不是很美观，暂时用别人的主题做基础，以后慢慢弄吧。现在域名为 Shirtiny.cn 6.13 增加标签、友链、分类、归档、404页面、搜索功能 6.17 增加头像挂件、社交链接 6.18 增加看板娘【随便拉来打工的】 7.16 调整整体色调、不由自主的加了些挂件、增加Valine评论系统 7.29 把Valine换成Gitment【越来越懒】 8.03 拉出来改了下bug、尝试调试移动端适配（放弃）、追加内建标签【想换Spring Boot做了】 8.06 增加视频播放标签 8.23 增设一台服务器，使用子域名server.shirtiny.cn，ip不定 域名购买： 腾讯云 域名解析： DNSPOD 搭建Hexo：哔哩哔哩教程 域名绑定：CN博客教程 解决部署使：CName消失的问题]]></content>
      <categories>
        <category>闲谈</category>
      </categories>
      <tags>
        <tag>开局第一篇 - 测试</tag>
      </tags>
  </entry>
</search>
